
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model SocialLink
 * 
 */
export type SocialLink = $Result.DefaultSelection<Prisma.$SocialLinkPayload>
/**
 * Model FounderProfile
 * 
 */
export type FounderProfile = $Result.DefaultSelection<Prisma.$FounderProfilePayload>
/**
 * Model FundraisingDetails
 * 
 */
export type FundraisingDetails = $Result.DefaultSelection<Prisma.$FundraisingDetailsPayload>
/**
 * Model InvestorProfile
 * 
 */
export type InvestorProfile = $Result.DefaultSelection<Prisma.$InvestorProfilePayload>
/**
 * Model Portfolio
 * 
 */
export type Portfolio = $Result.DefaultSelection<Prisma.$PortfolioPayload>
/**
 * Model BuilderProfile
 * 
 */
export type BuilderProfile = $Result.DefaultSelection<Prisma.$BuilderProfilePayload>
/**
 * Model InvestorVerification
 * 
 */
export type InvestorVerification = $Result.DefaultSelection<Prisma.$InvestorVerificationPayload>
/**
 * Model Video
 * 
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model VideoTranscript
 * 
 */
export type VideoTranscript = $Result.DefaultSelection<Prisma.$VideoTranscriptPayload>
/**
 * Model VideoAnalytics
 * 
 */
export type VideoAnalytics = $Result.DefaultSelection<Prisma.$VideoAnalyticsPayload>
/**
 * Model VideoView
 * 
 */
export type VideoView = $Result.DefaultSelection<Prisma.$VideoViewPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Save
 * 
 */
export type Save = $Result.DefaultSelection<Prisma.$SavePayload>
/**
 * Model SaveList
 * 
 */
export type SaveList = $Result.DefaultSelection<Prisma.$SaveListPayload>
/**
 * Model Share
 * 
 */
export type Share = $Result.DefaultSelection<Prisma.$SharePayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model ExpressInterest
 * 
 */
export type ExpressInterest = $Result.DefaultSelection<Prisma.$ExpressInterestPayload>
/**
 * Model ProfileReveal
 * 
 */
export type ProfileReveal = $Result.DefaultSelection<Prisma.$ProfileRevealPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageLimit
 * 
 */
export type MessageLimit = $Result.DefaultSelection<Prisma.$MessageLimitPayload>
/**
 * Model ContentReport
 * 
 */
export type ContentReport = $Result.DefaultSelection<Prisma.$ContentReportPayload>
/**
 * Model ContentFlag
 * 
 */
export type ContentFlag = $Result.DefaultSelection<Prisma.$ContentFlagPayload>
/**
 * Model ModerationActionRecord
 * 
 */
export type ModerationActionRecord = $Result.DefaultSelection<Prisma.$ModerationActionRecordPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model FeaturedContent
 * 
 */
export type FeaturedContent = $Result.DefaultSelection<Prisma.$FeaturedContentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model FeedPreference
 * 
 */
export type FeedPreference = $Result.DefaultSelection<Prisma.$FeedPreferencePayload>
/**
 * Model SearchHistory
 * 
 */
export type SearchHistory = $Result.DefaultSelection<Prisma.$SearchHistoryPayload>
/**
 * Model OnboardingProgress
 * 
 */
export type OnboardingProgress = $Result.DefaultSelection<Prisma.$OnboardingProgressPayload>
/**
 * Model AccountTypeChange
 * 
 */
export type AccountTypeChange = $Result.DefaultSelection<Prisma.$AccountTypeChangePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AccountType: {
  FOUNDER: 'FOUNDER',
  BUILDER: 'BUILDER',
  INVESTOR: 'INVESTOR',
  LURKER: 'LURKER'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const VerificationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const VideoType: {
  PITCH: 'PITCH',
  UPDATE: 'UPDATE',
  ASK: 'ASK',
  WIN_LOSS: 'WIN_LOSS'
};

export type VideoType = (typeof VideoType)[keyof typeof VideoType]


export const VideoVisibility: {
  PUBLIC: 'PUBLIC',
  COMMUNITY: 'COMMUNITY',
  INVESTORS_ONLY: 'INVESTORS_ONLY'
};

export type VideoVisibility = (typeof VideoVisibility)[keyof typeof VideoVisibility]


export const ConversationStatus: {
  ACTIVE: 'ACTIVE',
  REQUEST: 'REQUEST',
  BLOCKED: 'BLOCKED'
};

export type ConversationStatus = (typeof ConversationStatus)[keyof typeof ConversationStatus]


export const ReportCategory: {
  SPAM: 'SPAM',
  SCAM: 'SCAM',
  INAPPROPRIATE: 'INAPPROPRIATE',
  STOLEN_IDEA: 'STOLEN_IDEA',
  HARASSMENT: 'HARASSMENT'
};

export type ReportCategory = (typeof ReportCategory)[keyof typeof ReportCategory]


export const ModerationAction: {
  WARNING: 'WARNING',
  SUSPEND_7_DAY: 'SUSPEND_7_DAY',
  SUSPEND_30_DAY: 'SUSPEND_30_DAY',
  PERMANENT_BAN: 'PERMANENT_BAN'
};

export type ModerationAction = (typeof ModerationAction)[keyof typeof ModerationAction]


export const SubscriptionTier: {
  FREE: 'FREE',
  FOUNDER_PRO: 'FOUNDER_PRO',
  INVESTOR_PRO: 'INVESTOR_PRO',
  STEALTH_MODE: 'STEALTH_MODE'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const NotificationPriority: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]

}

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type VideoType = $Enums.VideoType

export const VideoType: typeof $Enums.VideoType

export type VideoVisibility = $Enums.VideoVisibility

export const VideoVisibility: typeof $Enums.VideoVisibility

export type ConversationStatus = $Enums.ConversationStatus

export const ConversationStatus: typeof $Enums.ConversationStatus

export type ReportCategory = $Enums.ReportCategory

export const ReportCategory: typeof $Enums.ReportCategory

export type ModerationAction = $Enums.ModerationAction

export const ModerationAction: typeof $Enums.ModerationAction

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs>;

  /**
   * `prisma.socialLink`: Exposes CRUD operations for the **SocialLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialLinks
    * const socialLinks = await prisma.socialLink.findMany()
    * ```
    */
  get socialLink(): Prisma.SocialLinkDelegate<ExtArgs>;

  /**
   * `prisma.founderProfile`: Exposes CRUD operations for the **FounderProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FounderProfiles
    * const founderProfiles = await prisma.founderProfile.findMany()
    * ```
    */
  get founderProfile(): Prisma.FounderProfileDelegate<ExtArgs>;

  /**
   * `prisma.fundraisingDetails`: Exposes CRUD operations for the **FundraisingDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FundraisingDetails
    * const fundraisingDetails = await prisma.fundraisingDetails.findMany()
    * ```
    */
  get fundraisingDetails(): Prisma.FundraisingDetailsDelegate<ExtArgs>;

  /**
   * `prisma.investorProfile`: Exposes CRUD operations for the **InvestorProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvestorProfiles
    * const investorProfiles = await prisma.investorProfile.findMany()
    * ```
    */
  get investorProfile(): Prisma.InvestorProfileDelegate<ExtArgs>;

  /**
   * `prisma.portfolio`: Exposes CRUD operations for the **Portfolio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portfolios
    * const portfolios = await prisma.portfolio.findMany()
    * ```
    */
  get portfolio(): Prisma.PortfolioDelegate<ExtArgs>;

  /**
   * `prisma.builderProfile`: Exposes CRUD operations for the **BuilderProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuilderProfiles
    * const builderProfiles = await prisma.builderProfile.findMany()
    * ```
    */
  get builderProfile(): Prisma.BuilderProfileDelegate<ExtArgs>;

  /**
   * `prisma.investorVerification`: Exposes CRUD operations for the **InvestorVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvestorVerifications
    * const investorVerifications = await prisma.investorVerification.findMany()
    * ```
    */
  get investorVerification(): Prisma.InvestorVerificationDelegate<ExtArgs>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs>;

  /**
   * `prisma.videoTranscript`: Exposes CRUD operations for the **VideoTranscript** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoTranscripts
    * const videoTranscripts = await prisma.videoTranscript.findMany()
    * ```
    */
  get videoTranscript(): Prisma.VideoTranscriptDelegate<ExtArgs>;

  /**
   * `prisma.videoAnalytics`: Exposes CRUD operations for the **VideoAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoAnalytics
    * const videoAnalytics = await prisma.videoAnalytics.findMany()
    * ```
    */
  get videoAnalytics(): Prisma.VideoAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.videoView`: Exposes CRUD operations for the **VideoView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoViews
    * const videoViews = await prisma.videoView.findMany()
    * ```
    */
  get videoView(): Prisma.VideoViewDelegate<ExtArgs>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.save`: Exposes CRUD operations for the **Save** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saves
    * const saves = await prisma.save.findMany()
    * ```
    */
  get save(): Prisma.SaveDelegate<ExtArgs>;

  /**
   * `prisma.saveList`: Exposes CRUD operations for the **SaveList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaveLists
    * const saveLists = await prisma.saveList.findMany()
    * ```
    */
  get saveList(): Prisma.SaveListDelegate<ExtArgs>;

  /**
   * `prisma.share`: Exposes CRUD operations for the **Share** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shares
    * const shares = await prisma.share.findMany()
    * ```
    */
  get share(): Prisma.ShareDelegate<ExtArgs>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs>;

  /**
   * `prisma.expressInterest`: Exposes CRUD operations for the **ExpressInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpressInterests
    * const expressInterests = await prisma.expressInterest.findMany()
    * ```
    */
  get expressInterest(): Prisma.ExpressInterestDelegate<ExtArgs>;

  /**
   * `prisma.profileReveal`: Exposes CRUD operations for the **ProfileReveal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileReveals
    * const profileReveals = await prisma.profileReveal.findMany()
    * ```
    */
  get profileReveal(): Prisma.ProfileRevealDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.messageLimit`: Exposes CRUD operations for the **MessageLimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageLimits
    * const messageLimits = await prisma.messageLimit.findMany()
    * ```
    */
  get messageLimit(): Prisma.MessageLimitDelegate<ExtArgs>;

  /**
   * `prisma.contentReport`: Exposes CRUD operations for the **ContentReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentReports
    * const contentReports = await prisma.contentReport.findMany()
    * ```
    */
  get contentReport(): Prisma.ContentReportDelegate<ExtArgs>;

  /**
   * `prisma.contentFlag`: Exposes CRUD operations for the **ContentFlag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentFlags
    * const contentFlags = await prisma.contentFlag.findMany()
    * ```
    */
  get contentFlag(): Prisma.ContentFlagDelegate<ExtArgs>;

  /**
   * `prisma.moderationActionRecord`: Exposes CRUD operations for the **ModerationActionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModerationActionRecords
    * const moderationActionRecords = await prisma.moderationActionRecord.findMany()
    * ```
    */
  get moderationActionRecord(): Prisma.ModerationActionRecordDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.featuredContent`: Exposes CRUD operations for the **FeaturedContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedContents
    * const featuredContents = await prisma.featuredContent.findMany()
    * ```
    */
  get featuredContent(): Prisma.FeaturedContentDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.feedPreference`: Exposes CRUD operations for the **FeedPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedPreferences
    * const feedPreferences = await prisma.feedPreference.findMany()
    * ```
    */
  get feedPreference(): Prisma.FeedPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.searchHistory`: Exposes CRUD operations for the **SearchHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchHistories
    * const searchHistories = await prisma.searchHistory.findMany()
    * ```
    */
  get searchHistory(): Prisma.SearchHistoryDelegate<ExtArgs>;

  /**
   * `prisma.onboardingProgress`: Exposes CRUD operations for the **OnboardingProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnboardingProgresses
    * const onboardingProgresses = await prisma.onboardingProgress.findMany()
    * ```
    */
  get onboardingProgress(): Prisma.OnboardingProgressDelegate<ExtArgs>;

  /**
   * `prisma.accountTypeChange`: Exposes CRUD operations for the **AccountTypeChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountTypeChanges
    * const accountTypeChanges = await prisma.accountTypeChange.findMany()
    * ```
    */
  get accountTypeChange(): Prisma.AccountTypeChangeDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Block: 'Block',
    Session: 'Session',
    UserProfile: 'UserProfile',
    SocialLink: 'SocialLink',
    FounderProfile: 'FounderProfile',
    FundraisingDetails: 'FundraisingDetails',
    InvestorProfile: 'InvestorProfile',
    Portfolio: 'Portfolio',
    BuilderProfile: 'BuilderProfile',
    InvestorVerification: 'InvestorVerification',
    Video: 'Video',
    VideoTranscript: 'VideoTranscript',
    VideoAnalytics: 'VideoAnalytics',
    VideoView: 'VideoView',
    Like: 'Like',
    Comment: 'Comment',
    Save: 'Save',
    SaveList: 'SaveList',
    Share: 'Share',
    Follow: 'Follow',
    ExpressInterest: 'ExpressInterest',
    ProfileReveal: 'ProfileReveal',
    Conversation: 'Conversation',
    Message: 'Message',
    MessageLimit: 'MessageLimit',
    ContentReport: 'ContentReport',
    ContentFlag: 'ContentFlag',
    ModerationActionRecord: 'ModerationActionRecord',
    Subscription: 'Subscription',
    FeaturedContent: 'FeaturedContent',
    Notification: 'Notification',
    NotificationPreference: 'NotificationPreference',
    FeedPreference: 'FeedPreference',
    SearchHistory: 'SearchHistory',
    OnboardingProgress: 'OnboardingProgress',
    AccountTypeChange: 'AccountTypeChange'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "block" | "session" | "userProfile" | "socialLink" | "founderProfile" | "fundraisingDetails" | "investorProfile" | "portfolio" | "builderProfile" | "investorVerification" | "video" | "videoTranscript" | "videoAnalytics" | "videoView" | "like" | "comment" | "save" | "saveList" | "share" | "follow" | "expressInterest" | "profileReveal" | "conversation" | "message" | "messageLimit" | "contentReport" | "contentFlag" | "moderationActionRecord" | "subscription" | "featuredContent" | "notification" | "notificationPreference" | "feedPreference" | "searchHistory" | "onboardingProgress" | "accountTypeChange"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      SocialLink: {
        payload: Prisma.$SocialLinkPayload<ExtArgs>
        fields: Prisma.SocialLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          findFirst: {
            args: Prisma.SocialLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          findMany: {
            args: Prisma.SocialLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>[]
          }
          create: {
            args: Prisma.SocialLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          createMany: {
            args: Prisma.SocialLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>[]
          }
          delete: {
            args: Prisma.SocialLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          update: {
            args: Prisma.SocialLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          deleteMany: {
            args: Prisma.SocialLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          aggregate: {
            args: Prisma.SocialLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialLink>
          }
          groupBy: {
            args: Prisma.SocialLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialLinkCountArgs<ExtArgs>
            result: $Utils.Optional<SocialLinkCountAggregateOutputType> | number
          }
        }
      }
      FounderProfile: {
        payload: Prisma.$FounderProfilePayload<ExtArgs>
        fields: Prisma.FounderProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FounderProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FounderProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload>
          }
          findFirst: {
            args: Prisma.FounderProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FounderProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload>
          }
          findMany: {
            args: Prisma.FounderProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload>[]
          }
          create: {
            args: Prisma.FounderProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload>
          }
          createMany: {
            args: Prisma.FounderProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FounderProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload>[]
          }
          delete: {
            args: Prisma.FounderProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload>
          }
          update: {
            args: Prisma.FounderProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload>
          }
          deleteMany: {
            args: Prisma.FounderProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FounderProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FounderProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FounderProfilePayload>
          }
          aggregate: {
            args: Prisma.FounderProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFounderProfile>
          }
          groupBy: {
            args: Prisma.FounderProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FounderProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FounderProfileCountArgs<ExtArgs>
            result: $Utils.Optional<FounderProfileCountAggregateOutputType> | number
          }
        }
      }
      FundraisingDetails: {
        payload: Prisma.$FundraisingDetailsPayload<ExtArgs>
        fields: Prisma.FundraisingDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FundraisingDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FundraisingDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload>
          }
          findFirst: {
            args: Prisma.FundraisingDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FundraisingDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload>
          }
          findMany: {
            args: Prisma.FundraisingDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload>[]
          }
          create: {
            args: Prisma.FundraisingDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload>
          }
          createMany: {
            args: Prisma.FundraisingDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FundraisingDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload>[]
          }
          delete: {
            args: Prisma.FundraisingDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload>
          }
          update: {
            args: Prisma.FundraisingDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload>
          }
          deleteMany: {
            args: Prisma.FundraisingDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FundraisingDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FundraisingDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundraisingDetailsPayload>
          }
          aggregate: {
            args: Prisma.FundraisingDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFundraisingDetails>
          }
          groupBy: {
            args: Prisma.FundraisingDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FundraisingDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FundraisingDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<FundraisingDetailsCountAggregateOutputType> | number
          }
        }
      }
      InvestorProfile: {
        payload: Prisma.$InvestorProfilePayload<ExtArgs>
        fields: Prisma.InvestorProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload>
          }
          findFirst: {
            args: Prisma.InvestorProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload>
          }
          findMany: {
            args: Prisma.InvestorProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload>[]
          }
          create: {
            args: Prisma.InvestorProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload>
          }
          createMany: {
            args: Prisma.InvestorProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload>[]
          }
          delete: {
            args: Prisma.InvestorProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload>
          }
          update: {
            args: Prisma.InvestorProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload>
          }
          deleteMany: {
            args: Prisma.InvestorProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvestorProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorProfilePayload>
          }
          aggregate: {
            args: Prisma.InvestorProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestorProfile>
          }
          groupBy: {
            args: Prisma.InvestorProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorProfileCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorProfileCountAggregateOutputType> | number
          }
        }
      }
      Portfolio: {
        payload: Prisma.$PortfolioPayload<ExtArgs>
        fields: Prisma.PortfolioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findFirst: {
            args: Prisma.PortfolioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findMany: {
            args: Prisma.PortfolioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          create: {
            args: Prisma.PortfolioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          createMany: {
            args: Prisma.PortfolioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          delete: {
            args: Prisma.PortfolioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          update: {
            args: Prisma.PortfolioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PortfolioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          aggregate: {
            args: Prisma.PortfolioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolio>
          }
          groupBy: {
            args: Prisma.PortfolioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioCountAggregateOutputType> | number
          }
        }
      }
      BuilderProfile: {
        payload: Prisma.$BuilderProfilePayload<ExtArgs>
        fields: Prisma.BuilderProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuilderProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuilderProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload>
          }
          findFirst: {
            args: Prisma.BuilderProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuilderProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload>
          }
          findMany: {
            args: Prisma.BuilderProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload>[]
          }
          create: {
            args: Prisma.BuilderProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload>
          }
          createMany: {
            args: Prisma.BuilderProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuilderProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload>[]
          }
          delete: {
            args: Prisma.BuilderProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload>
          }
          update: {
            args: Prisma.BuilderProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload>
          }
          deleteMany: {
            args: Prisma.BuilderProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuilderProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuilderProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderProfilePayload>
          }
          aggregate: {
            args: Prisma.BuilderProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilderProfile>
          }
          groupBy: {
            args: Prisma.BuilderProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuilderProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuilderProfileCountArgs<ExtArgs>
            result: $Utils.Optional<BuilderProfileCountAggregateOutputType> | number
          }
        }
      }
      InvestorVerification: {
        payload: Prisma.$InvestorVerificationPayload<ExtArgs>
        fields: Prisma.InvestorVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload>
          }
          findFirst: {
            args: Prisma.InvestorVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload>
          }
          findMany: {
            args: Prisma.InvestorVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload>[]
          }
          create: {
            args: Prisma.InvestorVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload>
          }
          createMany: {
            args: Prisma.InvestorVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload>[]
          }
          delete: {
            args: Prisma.InvestorVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload>
          }
          update: {
            args: Prisma.InvestorVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload>
          }
          deleteMany: {
            args: Prisma.InvestorVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvestorVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorVerificationPayload>
          }
          aggregate: {
            args: Prisma.InvestorVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestorVerification>
          }
          groupBy: {
            args: Prisma.InvestorVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorVerificationCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      VideoTranscript: {
        payload: Prisma.$VideoTranscriptPayload<ExtArgs>
        fields: Prisma.VideoTranscriptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoTranscriptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoTranscriptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload>
          }
          findFirst: {
            args: Prisma.VideoTranscriptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoTranscriptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload>
          }
          findMany: {
            args: Prisma.VideoTranscriptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload>[]
          }
          create: {
            args: Prisma.VideoTranscriptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload>
          }
          createMany: {
            args: Prisma.VideoTranscriptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoTranscriptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload>[]
          }
          delete: {
            args: Prisma.VideoTranscriptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload>
          }
          update: {
            args: Prisma.VideoTranscriptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload>
          }
          deleteMany: {
            args: Prisma.VideoTranscriptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoTranscriptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoTranscriptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoTranscriptPayload>
          }
          aggregate: {
            args: Prisma.VideoTranscriptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoTranscript>
          }
          groupBy: {
            args: Prisma.VideoTranscriptGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoTranscriptGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoTranscriptCountArgs<ExtArgs>
            result: $Utils.Optional<VideoTranscriptCountAggregateOutputType> | number
          }
        }
      }
      VideoAnalytics: {
        payload: Prisma.$VideoAnalyticsPayload<ExtArgs>
        fields: Prisma.VideoAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.VideoAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          findMany: {
            args: Prisma.VideoAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>[]
          }
          create: {
            args: Prisma.VideoAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          createMany: {
            args: Prisma.VideoAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.VideoAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          update: {
            args: Prisma.VideoAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.VideoAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.VideoAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoAnalytics>
          }
          groupBy: {
            args: Prisma.VideoAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<VideoAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      VideoView: {
        payload: Prisma.$VideoViewPayload<ExtArgs>
        fields: Prisma.VideoViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload>
          }
          findFirst: {
            args: Prisma.VideoViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload>
          }
          findMany: {
            args: Prisma.VideoViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload>[]
          }
          create: {
            args: Prisma.VideoViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload>
          }
          createMany: {
            args: Prisma.VideoViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload>[]
          }
          delete: {
            args: Prisma.VideoViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload>
          }
          update: {
            args: Prisma.VideoViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload>
          }
          deleteMany: {
            args: Prisma.VideoViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoViewPayload>
          }
          aggregate: {
            args: Prisma.VideoViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoView>
          }
          groupBy: {
            args: Prisma.VideoViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoViewCountArgs<ExtArgs>
            result: $Utils.Optional<VideoViewCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Save: {
        payload: Prisma.$SavePayload<ExtArgs>
        fields: Prisma.SaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload>
          }
          findFirst: {
            args: Prisma.SaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload>
          }
          findMany: {
            args: Prisma.SaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload>[]
          }
          create: {
            args: Prisma.SaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload>
          }
          createMany: {
            args: Prisma.SaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload>[]
          }
          delete: {
            args: Prisma.SaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload>
          }
          update: {
            args: Prisma.SaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload>
          }
          deleteMany: {
            args: Prisma.SaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavePayload>
          }
          aggregate: {
            args: Prisma.SaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSave>
          }
          groupBy: {
            args: Prisma.SaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaveCountArgs<ExtArgs>
            result: $Utils.Optional<SaveCountAggregateOutputType> | number
          }
        }
      }
      SaveList: {
        payload: Prisma.$SaveListPayload<ExtArgs>
        fields: Prisma.SaveListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaveListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaveListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload>
          }
          findFirst: {
            args: Prisma.SaveListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaveListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload>
          }
          findMany: {
            args: Prisma.SaveListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload>[]
          }
          create: {
            args: Prisma.SaveListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload>
          }
          createMany: {
            args: Prisma.SaveListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaveListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload>[]
          }
          delete: {
            args: Prisma.SaveListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload>
          }
          update: {
            args: Prisma.SaveListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload>
          }
          deleteMany: {
            args: Prisma.SaveListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaveListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaveListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaveListPayload>
          }
          aggregate: {
            args: Prisma.SaveListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaveList>
          }
          groupBy: {
            args: Prisma.SaveListGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaveListGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaveListCountArgs<ExtArgs>
            result: $Utils.Optional<SaveListCountAggregateOutputType> | number
          }
        }
      }
      Share: {
        payload: Prisma.$SharePayload<ExtArgs>
        fields: Prisma.ShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload>
          }
          findFirst: {
            args: Prisma.ShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload>
          }
          findMany: {
            args: Prisma.ShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload>[]
          }
          create: {
            args: Prisma.ShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload>
          }
          createMany: {
            args: Prisma.ShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload>[]
          }
          delete: {
            args: Prisma.ShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload>
          }
          update: {
            args: Prisma.ShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload>
          }
          deleteMany: {
            args: Prisma.ShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharePayload>
          }
          aggregate: {
            args: Prisma.ShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShare>
          }
          groupBy: {
            args: Prisma.ShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareCountArgs<ExtArgs>
            result: $Utils.Optional<ShareCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      ExpressInterest: {
        payload: Prisma.$ExpressInterestPayload<ExtArgs>
        fields: Prisma.ExpressInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpressInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpressInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload>
          }
          findFirst: {
            args: Prisma.ExpressInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpressInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload>
          }
          findMany: {
            args: Prisma.ExpressInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload>[]
          }
          create: {
            args: Prisma.ExpressInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload>
          }
          createMany: {
            args: Prisma.ExpressInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpressInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload>[]
          }
          delete: {
            args: Prisma.ExpressInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload>
          }
          update: {
            args: Prisma.ExpressInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload>
          }
          deleteMany: {
            args: Prisma.ExpressInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpressInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpressInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpressInterestPayload>
          }
          aggregate: {
            args: Prisma.ExpressInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpressInterest>
          }
          groupBy: {
            args: Prisma.ExpressInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpressInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpressInterestCountArgs<ExtArgs>
            result: $Utils.Optional<ExpressInterestCountAggregateOutputType> | number
          }
        }
      }
      ProfileReveal: {
        payload: Prisma.$ProfileRevealPayload<ExtArgs>
        fields: Prisma.ProfileRevealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileRevealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileRevealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload>
          }
          findFirst: {
            args: Prisma.ProfileRevealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileRevealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload>
          }
          findMany: {
            args: Prisma.ProfileRevealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload>[]
          }
          create: {
            args: Prisma.ProfileRevealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload>
          }
          createMany: {
            args: Prisma.ProfileRevealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileRevealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload>[]
          }
          delete: {
            args: Prisma.ProfileRevealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload>
          }
          update: {
            args: Prisma.ProfileRevealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload>
          }
          deleteMany: {
            args: Prisma.ProfileRevealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileRevealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileRevealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileRevealPayload>
          }
          aggregate: {
            args: Prisma.ProfileRevealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileReveal>
          }
          groupBy: {
            args: Prisma.ProfileRevealGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileRevealGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileRevealCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileRevealCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageLimit: {
        payload: Prisma.$MessageLimitPayload<ExtArgs>
        fields: Prisma.MessageLimitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageLimitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageLimitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload>
          }
          findFirst: {
            args: Prisma.MessageLimitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageLimitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload>
          }
          findMany: {
            args: Prisma.MessageLimitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload>[]
          }
          create: {
            args: Prisma.MessageLimitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload>
          }
          createMany: {
            args: Prisma.MessageLimitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageLimitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload>[]
          }
          delete: {
            args: Prisma.MessageLimitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload>
          }
          update: {
            args: Prisma.MessageLimitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload>
          }
          deleteMany: {
            args: Prisma.MessageLimitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageLimitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageLimitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLimitPayload>
          }
          aggregate: {
            args: Prisma.MessageLimitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageLimit>
          }
          groupBy: {
            args: Prisma.MessageLimitGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageLimitGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageLimitCountArgs<ExtArgs>
            result: $Utils.Optional<MessageLimitCountAggregateOutputType> | number
          }
        }
      }
      ContentReport: {
        payload: Prisma.$ContentReportPayload<ExtArgs>
        fields: Prisma.ContentReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload>
          }
          findFirst: {
            args: Prisma.ContentReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload>
          }
          findMany: {
            args: Prisma.ContentReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload>[]
          }
          create: {
            args: Prisma.ContentReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload>
          }
          createMany: {
            args: Prisma.ContentReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload>[]
          }
          delete: {
            args: Prisma.ContentReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload>
          }
          update: {
            args: Prisma.ContentReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload>
          }
          deleteMany: {
            args: Prisma.ContentReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentReportPayload>
          }
          aggregate: {
            args: Prisma.ContentReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentReport>
          }
          groupBy: {
            args: Prisma.ContentReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentReportCountArgs<ExtArgs>
            result: $Utils.Optional<ContentReportCountAggregateOutputType> | number
          }
        }
      }
      ContentFlag: {
        payload: Prisma.$ContentFlagPayload<ExtArgs>
        fields: Prisma.ContentFlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentFlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentFlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload>
          }
          findFirst: {
            args: Prisma.ContentFlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentFlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload>
          }
          findMany: {
            args: Prisma.ContentFlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload>[]
          }
          create: {
            args: Prisma.ContentFlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload>
          }
          createMany: {
            args: Prisma.ContentFlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentFlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload>[]
          }
          delete: {
            args: Prisma.ContentFlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload>
          }
          update: {
            args: Prisma.ContentFlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload>
          }
          deleteMany: {
            args: Prisma.ContentFlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentFlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentFlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentFlagPayload>
          }
          aggregate: {
            args: Prisma.ContentFlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentFlag>
          }
          groupBy: {
            args: Prisma.ContentFlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentFlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentFlagCountArgs<ExtArgs>
            result: $Utils.Optional<ContentFlagCountAggregateOutputType> | number
          }
        }
      }
      ModerationActionRecord: {
        payload: Prisma.$ModerationActionRecordPayload<ExtArgs>
        fields: Prisma.ModerationActionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModerationActionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModerationActionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload>
          }
          findFirst: {
            args: Prisma.ModerationActionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModerationActionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload>
          }
          findMany: {
            args: Prisma.ModerationActionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload>[]
          }
          create: {
            args: Prisma.ModerationActionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload>
          }
          createMany: {
            args: Prisma.ModerationActionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModerationActionRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload>[]
          }
          delete: {
            args: Prisma.ModerationActionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload>
          }
          update: {
            args: Prisma.ModerationActionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload>
          }
          deleteMany: {
            args: Prisma.ModerationActionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModerationActionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModerationActionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModerationActionRecordPayload>
          }
          aggregate: {
            args: Prisma.ModerationActionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModerationActionRecord>
          }
          groupBy: {
            args: Prisma.ModerationActionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModerationActionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModerationActionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ModerationActionRecordCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      FeaturedContent: {
        payload: Prisma.$FeaturedContentPayload<ExtArgs>
        fields: Prisma.FeaturedContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload>
          }
          findFirst: {
            args: Prisma.FeaturedContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload>
          }
          findMany: {
            args: Prisma.FeaturedContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload>[]
          }
          create: {
            args: Prisma.FeaturedContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload>
          }
          createMany: {
            args: Prisma.FeaturedContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload>[]
          }
          delete: {
            args: Prisma.FeaturedContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload>
          }
          update: {
            args: Prisma.FeaturedContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload>
          }
          deleteMany: {
            args: Prisma.FeaturedContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeaturedContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedContentPayload>
          }
          aggregate: {
            args: Prisma.FeaturedContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedContent>
          }
          groupBy: {
            args: Prisma.FeaturedContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedContentCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedContentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      FeedPreference: {
        payload: Prisma.$FeedPreferencePayload<ExtArgs>
        fields: Prisma.FeedPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload>
          }
          findFirst: {
            args: Prisma.FeedPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload>
          }
          findMany: {
            args: Prisma.FeedPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload>[]
          }
          create: {
            args: Prisma.FeedPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload>
          }
          createMany: {
            args: Prisma.FeedPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload>[]
          }
          delete: {
            args: Prisma.FeedPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload>
          }
          update: {
            args: Prisma.FeedPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload>
          }
          deleteMany: {
            args: Prisma.FeedPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPreferencePayload>
          }
          aggregate: {
            args: Prisma.FeedPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedPreference>
          }
          groupBy: {
            args: Prisma.FeedPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<FeedPreferenceCountAggregateOutputType> | number
          }
        }
      }
      SearchHistory: {
        payload: Prisma.$SearchHistoryPayload<ExtArgs>
        fields: Prisma.SearchHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findFirst: {
            args: Prisma.SearchHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findMany: {
            args: Prisma.SearchHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          create: {
            args: Prisma.SearchHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          createMany: {
            args: Prisma.SearchHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          delete: {
            args: Prisma.SearchHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          update: {
            args: Prisma.SearchHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SearchHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          aggregate: {
            args: Prisma.SearchHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchHistory>
          }
          groupBy: {
            args: Prisma.SearchHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryCountAggregateOutputType> | number
          }
        }
      }
      OnboardingProgress: {
        payload: Prisma.$OnboardingProgressPayload<ExtArgs>
        fields: Prisma.OnboardingProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnboardingProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnboardingProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          findFirst: {
            args: Prisma.OnboardingProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnboardingProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          findMany: {
            args: Prisma.OnboardingProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>[]
          }
          create: {
            args: Prisma.OnboardingProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          createMany: {
            args: Prisma.OnboardingProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnboardingProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>[]
          }
          delete: {
            args: Prisma.OnboardingProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          update: {
            args: Prisma.OnboardingProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          deleteMany: {
            args: Prisma.OnboardingProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnboardingProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OnboardingProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingProgressPayload>
          }
          aggregate: {
            args: Prisma.OnboardingProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnboardingProgress>
          }
          groupBy: {
            args: Prisma.OnboardingProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnboardingProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnboardingProgressCountArgs<ExtArgs>
            result: $Utils.Optional<OnboardingProgressCountAggregateOutputType> | number
          }
        }
      }
      AccountTypeChange: {
        payload: Prisma.$AccountTypeChangePayload<ExtArgs>
        fields: Prisma.AccountTypeChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountTypeChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountTypeChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload>
          }
          findFirst: {
            args: Prisma.AccountTypeChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountTypeChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload>
          }
          findMany: {
            args: Prisma.AccountTypeChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload>[]
          }
          create: {
            args: Prisma.AccountTypeChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload>
          }
          createMany: {
            args: Prisma.AccountTypeChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountTypeChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload>[]
          }
          delete: {
            args: Prisma.AccountTypeChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload>
          }
          update: {
            args: Prisma.AccountTypeChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload>
          }
          deleteMany: {
            args: Prisma.AccountTypeChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountTypeChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountTypeChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountTypeChangePayload>
          }
          aggregate: {
            args: Prisma.AccountTypeChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountTypeChange>
          }
          groupBy: {
            args: Prisma.AccountTypeChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountTypeChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountTypeChangeCountArgs<ExtArgs>
            result: $Utils.Optional<AccountTypeChangeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    videos: number
    comments: number
    likes: number
    saves: number
    shares: number
    videoViews: number
    following: number
    followers: number
    sentMessages: number
    conversations1: number
    conversations2: number
    expressedInterests: number
    receivedInterests: number
    profileRevealsAsInvestor: number
    profileRevealsAsFounder: number
    notifications: number
    notificationPrefs: number
    contentReports: number
    moderationActions: number
    sessions: number
    searchHistory: number
    accountTypeChanges: number
    messagesSent: number
    blockedUsers: number
    blockedBy: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | UserCountOutputTypeCountVideosArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    likes?: boolean | UserCountOutputTypeCountLikesArgs
    saves?: boolean | UserCountOutputTypeCountSavesArgs
    shares?: boolean | UserCountOutputTypeCountSharesArgs
    videoViews?: boolean | UserCountOutputTypeCountVideoViewsArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    conversations1?: boolean | UserCountOutputTypeCountConversations1Args
    conversations2?: boolean | UserCountOutputTypeCountConversations2Args
    expressedInterests?: boolean | UserCountOutputTypeCountExpressedInterestsArgs
    receivedInterests?: boolean | UserCountOutputTypeCountReceivedInterestsArgs
    profileRevealsAsInvestor?: boolean | UserCountOutputTypeCountProfileRevealsAsInvestorArgs
    profileRevealsAsFounder?: boolean | UserCountOutputTypeCountProfileRevealsAsFounderArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    notificationPrefs?: boolean | UserCountOutputTypeCountNotificationPrefsArgs
    contentReports?: boolean | UserCountOutputTypeCountContentReportsArgs
    moderationActions?: boolean | UserCountOutputTypeCountModerationActionsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    searchHistory?: boolean | UserCountOutputTypeCountSearchHistoryArgs
    accountTypeChanges?: boolean | UserCountOutputTypeCountAccountTypeChangesArgs
    messagesSent?: boolean | UserCountOutputTypeCountMessagesSentArgs
    blockedUsers?: boolean | UserCountOutputTypeCountBlockedUsersArgs
    blockedBy?: boolean | UserCountOutputTypeCountBlockedByArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVideoViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversations1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversations2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpressedInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpressInterestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpressInterestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfileRevealsAsInvestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileRevealWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfileRevealsAsFounderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileRevealWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContentReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModerationActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationActionRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountTypeChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountTypeChangeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLimitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }


  /**
   * Count Type UserProfileCountOutputType
   */

  export type UserProfileCountOutputType = {
    socialLinks: number
  }

  export type UserProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    socialLinks?: boolean | UserProfileCountOutputTypeCountSocialLinksArgs
  }

  // Custom InputTypes
  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileCountOutputType
     */
    select?: UserProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountSocialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLinkWhereInput
  }


  /**
   * Count Type InvestorProfileCountOutputType
   */

  export type InvestorProfileCountOutputType = {
    portfolio: number
  }

  export type InvestorProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | InvestorProfileCountOutputTypeCountPortfolioArgs
  }

  // Custom InputTypes
  /**
   * InvestorProfileCountOutputType without action
   */
  export type InvestorProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfileCountOutputType
     */
    select?: InvestorProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvestorProfileCountOutputType without action
   */
  export type InvestorProfileCountOutputTypeCountPortfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
  }


  /**
   * Count Type VideoCountOutputType
   */

  export type VideoCountOutputType = {
    comments: number
    likes: number
    saves: number
    shares: number
    views: number
    reports: number
    expressInterests: number
  }

  export type VideoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | VideoCountOutputTypeCountCommentsArgs
    likes?: boolean | VideoCountOutputTypeCountLikesArgs
    saves?: boolean | VideoCountOutputTypeCountSavesArgs
    shares?: boolean | VideoCountOutputTypeCountSharesArgs
    views?: boolean | VideoCountOutputTypeCountViewsArgs
    reports?: boolean | VideoCountOutputTypeCountReportsArgs
    expressInterests?: boolean | VideoCountOutputTypeCountExpressInterestsArgs
  }

  // Custom InputTypes
  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCountOutputType
     */
    select?: VideoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountSavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaveWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoViewWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentReportWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountExpressInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpressInterestWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type SaveListCountOutputType
   */

  export type SaveListCountOutputType = {
    saves: number
  }

  export type SaveListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saves?: boolean | SaveListCountOutputTypeCountSavesArgs
  }

  // Custom InputTypes
  /**
   * SaveListCountOutputType without action
   */
  export type SaveListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveListCountOutputType
     */
    select?: SaveListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaveListCountOutputType without action
   */
  export type SaveListCountOutputTypeCountSavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaveWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    accountType: $Enums.AccountType | null
    isVerified: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    resetPasswordToken: string | null
    resetPasswordExpires: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    accountType: $Enums.AccountType | null
    isVerified: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    resetPasswordToken: string | null
    resetPasswordExpires: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    accountType: number
    isVerified: number
    isActive: number
    createdAt: number
    updatedAt: number
    resetPasswordToken: number
    resetPasswordExpires: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    accountType?: true
    isVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    resetPasswordToken?: true
    resetPasswordExpires?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    accountType?: true
    isVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    resetPasswordToken?: true
    resetPasswordExpires?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    accountType?: true
    isVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    resetPasswordToken?: true
    resetPasswordExpires?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    accountType: $Enums.AccountType
    isVerified: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    resetPasswordToken: string | null
    resetPasswordExpires: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    accountType?: boolean
    isVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpires?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    founderProfile?: boolean | User$founderProfileArgs<ExtArgs>
    investorProfile?: boolean | User$investorProfileArgs<ExtArgs>
    builderProfile?: boolean | User$builderProfileArgs<ExtArgs>
    investorVerification?: boolean | User$investorVerificationArgs<ExtArgs>
    videos?: boolean | User$videosArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    saves?: boolean | User$savesArgs<ExtArgs>
    shares?: boolean | User$sharesArgs<ExtArgs>
    videoViews?: boolean | User$videoViewsArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    conversations1?: boolean | User$conversations1Args<ExtArgs>
    conversations2?: boolean | User$conversations2Args<ExtArgs>
    expressedInterests?: boolean | User$expressedInterestsArgs<ExtArgs>
    receivedInterests?: boolean | User$receivedInterestsArgs<ExtArgs>
    profileRevealsAsInvestor?: boolean | User$profileRevealsAsInvestorArgs<ExtArgs>
    profileRevealsAsFounder?: boolean | User$profileRevealsAsFounderArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notificationPrefs?: boolean | User$notificationPrefsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    contentReports?: boolean | User$contentReportsArgs<ExtArgs>
    moderationActions?: boolean | User$moderationActionsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    onboardingProgress?: boolean | User$onboardingProgressArgs<ExtArgs>
    accountTypeChanges?: boolean | User$accountTypeChangesArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    feedPreferences?: boolean | User$feedPreferencesArgs<ExtArgs>
    blockedUsers?: boolean | User$blockedUsersArgs<ExtArgs>
    blockedBy?: boolean | User$blockedByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    accountType?: boolean
    isVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    accountType?: boolean
    isVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpires?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    founderProfile?: boolean | User$founderProfileArgs<ExtArgs>
    investorProfile?: boolean | User$investorProfileArgs<ExtArgs>
    builderProfile?: boolean | User$builderProfileArgs<ExtArgs>
    investorVerification?: boolean | User$investorVerificationArgs<ExtArgs>
    videos?: boolean | User$videosArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    saves?: boolean | User$savesArgs<ExtArgs>
    shares?: boolean | User$sharesArgs<ExtArgs>
    videoViews?: boolean | User$videoViewsArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    conversations1?: boolean | User$conversations1Args<ExtArgs>
    conversations2?: boolean | User$conversations2Args<ExtArgs>
    expressedInterests?: boolean | User$expressedInterestsArgs<ExtArgs>
    receivedInterests?: boolean | User$receivedInterestsArgs<ExtArgs>
    profileRevealsAsInvestor?: boolean | User$profileRevealsAsInvestorArgs<ExtArgs>
    profileRevealsAsFounder?: boolean | User$profileRevealsAsFounderArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notificationPrefs?: boolean | User$notificationPrefsArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    contentReports?: boolean | User$contentReportsArgs<ExtArgs>
    moderationActions?: boolean | User$moderationActionsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    searchHistory?: boolean | User$searchHistoryArgs<ExtArgs>
    onboardingProgress?: boolean | User$onboardingProgressArgs<ExtArgs>
    accountTypeChanges?: boolean | User$accountTypeChangesArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    feedPreferences?: boolean | User$feedPreferencesArgs<ExtArgs>
    blockedUsers?: boolean | User$blockedUsersArgs<ExtArgs>
    blockedBy?: boolean | User$blockedByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs> | null
      founderProfile: Prisma.$FounderProfilePayload<ExtArgs> | null
      investorProfile: Prisma.$InvestorProfilePayload<ExtArgs> | null
      builderProfile: Prisma.$BuilderProfilePayload<ExtArgs> | null
      investorVerification: Prisma.$InvestorVerificationPayload<ExtArgs> | null
      videos: Prisma.$VideoPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      saves: Prisma.$SavePayload<ExtArgs>[]
      shares: Prisma.$SharePayload<ExtArgs>[]
      videoViews: Prisma.$VideoViewPayload<ExtArgs>[]
      following: Prisma.$FollowPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      conversations1: Prisma.$ConversationPayload<ExtArgs>[]
      conversations2: Prisma.$ConversationPayload<ExtArgs>[]
      expressedInterests: Prisma.$ExpressInterestPayload<ExtArgs>[]
      receivedInterests: Prisma.$ExpressInterestPayload<ExtArgs>[]
      profileRevealsAsInvestor: Prisma.$ProfileRevealPayload<ExtArgs>[]
      profileRevealsAsFounder: Prisma.$ProfileRevealPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      notificationPrefs: Prisma.$NotificationPreferencePayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      contentReports: Prisma.$ContentReportPayload<ExtArgs>[]
      moderationActions: Prisma.$ModerationActionRecordPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      searchHistory: Prisma.$SearchHistoryPayload<ExtArgs>[]
      onboardingProgress: Prisma.$OnboardingProgressPayload<ExtArgs> | null
      accountTypeChanges: Prisma.$AccountTypeChangePayload<ExtArgs>[]
      messagesSent: Prisma.$MessageLimitPayload<ExtArgs>[]
      feedPreferences: Prisma.$FeedPreferencePayload<ExtArgs> | null
      blockedUsers: Prisma.$BlockPayload<ExtArgs>[]
      blockedBy: Prisma.$BlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      accountType: $Enums.AccountType
      isVerified: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      resetPasswordToken: string | null
      resetPasswordExpires: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    founderProfile<T extends User$founderProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$founderProfileArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    investorProfile<T extends User$investorProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$investorProfileArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    builderProfile<T extends User$builderProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$builderProfileArgs<ExtArgs>>): Prisma__BuilderProfileClient<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    investorVerification<T extends User$investorVerificationArgs<ExtArgs> = {}>(args?: Subset<T, User$investorVerificationArgs<ExtArgs>>): Prisma__InvestorVerificationClient<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    videos<T extends User$videosArgs<ExtArgs> = {}>(args?: Subset<T, User$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends User$likesArgs<ExtArgs> = {}>(args?: Subset<T, User$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    saves<T extends User$savesArgs<ExtArgs> = {}>(args?: Subset<T, User$savesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "findMany"> | Null>
    shares<T extends User$sharesArgs<ExtArgs> = {}>(args?: Subset<T, User$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "findMany"> | Null>
    videoViews<T extends User$videoViewsArgs<ExtArgs> = {}>(args?: Subset<T, User$videoViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "findMany"> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany"> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    conversations1<T extends User$conversations1Args<ExtArgs> = {}>(args?: Subset<T, User$conversations1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany"> | Null>
    conversations2<T extends User$conversations2Args<ExtArgs> = {}>(args?: Subset<T, User$conversations2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany"> | Null>
    expressedInterests<T extends User$expressedInterestsArgs<ExtArgs> = {}>(args?: Subset<T, User$expressedInterestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "findMany"> | Null>
    receivedInterests<T extends User$receivedInterestsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedInterestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "findMany"> | Null>
    profileRevealsAsInvestor<T extends User$profileRevealsAsInvestorArgs<ExtArgs> = {}>(args?: Subset<T, User$profileRevealsAsInvestorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "findMany"> | Null>
    profileRevealsAsFounder<T extends User$profileRevealsAsFounderArgs<ExtArgs> = {}>(args?: Subset<T, User$profileRevealsAsFounderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    notificationPrefs<T extends User$notificationPrefsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPrefsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany"> | Null>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    contentReports<T extends User$contentReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$contentReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "findMany"> | Null>
    moderationActions<T extends User$moderationActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$moderationActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    searchHistory<T extends User$searchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$searchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    onboardingProgress<T extends User$onboardingProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$onboardingProgressArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    accountTypeChanges<T extends User$accountTypeChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$accountTypeChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "findMany"> | Null>
    messagesSent<T extends User$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "findMany"> | Null>
    feedPreferences<T extends User$feedPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$feedPreferencesArgs<ExtArgs>>): Prisma__FeedPreferenceClient<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    blockedUsers<T extends User$blockedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$blockedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany"> | Null>
    blockedBy<T extends User$blockedByArgs<ExtArgs> = {}>(args?: Subset<T, User$blockedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly accountType: FieldRef<"User", 'AccountType'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly resetPasswordToken: FieldRef<"User", 'String'>
    readonly resetPasswordExpires: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.founderProfile
   */
  export type User$founderProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    where?: FounderProfileWhereInput
  }

  /**
   * User.investorProfile
   */
  export type User$investorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    where?: InvestorProfileWhereInput
  }

  /**
   * User.builderProfile
   */
  export type User$builderProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    where?: BuilderProfileWhereInput
  }

  /**
   * User.investorVerification
   */
  export type User$investorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    where?: InvestorVerificationWhereInput
  }

  /**
   * User.videos
   */
  export type User$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.likes
   */
  export type User$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.saves
   */
  export type User$savesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    where?: SaveWhereInput
    orderBy?: SaveOrderByWithRelationInput | SaveOrderByWithRelationInput[]
    cursor?: SaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaveScalarFieldEnum | SaveScalarFieldEnum[]
  }

  /**
   * User.shares
   */
  export type User$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    where?: ShareWhereInput
    orderBy?: ShareOrderByWithRelationInput | ShareOrderByWithRelationInput[]
    cursor?: ShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareScalarFieldEnum | ShareScalarFieldEnum[]
  }

  /**
   * User.videoViews
   */
  export type User$videoViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    where?: VideoViewWhereInput
    orderBy?: VideoViewOrderByWithRelationInput | VideoViewOrderByWithRelationInput[]
    cursor?: VideoViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoViewScalarFieldEnum | VideoViewScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.conversations1
   */
  export type User$conversations1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.conversations2
   */
  export type User$conversations2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.expressedInterests
   */
  export type User$expressedInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    where?: ExpressInterestWhereInput
    orderBy?: ExpressInterestOrderByWithRelationInput | ExpressInterestOrderByWithRelationInput[]
    cursor?: ExpressInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpressInterestScalarFieldEnum | ExpressInterestScalarFieldEnum[]
  }

  /**
   * User.receivedInterests
   */
  export type User$receivedInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    where?: ExpressInterestWhereInput
    orderBy?: ExpressInterestOrderByWithRelationInput | ExpressInterestOrderByWithRelationInput[]
    cursor?: ExpressInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpressInterestScalarFieldEnum | ExpressInterestScalarFieldEnum[]
  }

  /**
   * User.profileRevealsAsInvestor
   */
  export type User$profileRevealsAsInvestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    where?: ProfileRevealWhereInput
    orderBy?: ProfileRevealOrderByWithRelationInput | ProfileRevealOrderByWithRelationInput[]
    cursor?: ProfileRevealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileRevealScalarFieldEnum | ProfileRevealScalarFieldEnum[]
  }

  /**
   * User.profileRevealsAsFounder
   */
  export type User$profileRevealsAsFounderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    where?: ProfileRevealWhereInput
    orderBy?: ProfileRevealOrderByWithRelationInput | ProfileRevealOrderByWithRelationInput[]
    cursor?: ProfileRevealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileRevealScalarFieldEnum | ProfileRevealScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.notificationPrefs
   */
  export type User$notificationPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    cursor?: NotificationPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User.contentReports
   */
  export type User$contentReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    where?: ContentReportWhereInput
    orderBy?: ContentReportOrderByWithRelationInput | ContentReportOrderByWithRelationInput[]
    cursor?: ContentReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentReportScalarFieldEnum | ContentReportScalarFieldEnum[]
  }

  /**
   * User.moderationActions
   */
  export type User$moderationActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    where?: ModerationActionRecordWhereInput
    orderBy?: ModerationActionRecordOrderByWithRelationInput | ModerationActionRecordOrderByWithRelationInput[]
    cursor?: ModerationActionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModerationActionRecordScalarFieldEnum | ModerationActionRecordScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.searchHistory
   */
  export type User$searchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    cursor?: SearchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * User.onboardingProgress
   */
  export type User$onboardingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    where?: OnboardingProgressWhereInput
  }

  /**
   * User.accountTypeChanges
   */
  export type User$accountTypeChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    where?: AccountTypeChangeWhereInput
    orderBy?: AccountTypeChangeOrderByWithRelationInput | AccountTypeChangeOrderByWithRelationInput[]
    cursor?: AccountTypeChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountTypeChangeScalarFieldEnum | AccountTypeChangeScalarFieldEnum[]
  }

  /**
   * User.messagesSent
   */
  export type User$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    where?: MessageLimitWhereInput
    orderBy?: MessageLimitOrderByWithRelationInput | MessageLimitOrderByWithRelationInput[]
    cursor?: MessageLimitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageLimitScalarFieldEnum | MessageLimitScalarFieldEnum[]
  }

  /**
   * User.feedPreferences
   */
  export type User$feedPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    where?: FeedPreferenceWhereInput
  }

  /**
   * User.blockedUsers
   */
  export type User$blockedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * User.blockedBy
   */
  export type User$blockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockMinAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedId: string | null
    createdAt: Date | null
  }

  export type BlockMaxAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedId: string | null
    createdAt: Date | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    blockerId: number
    blockedId: number
    createdAt: number
    _all: number
  }


  export type BlockMinAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: string
    blockerId: string
    blockedId: string
    createdAt: Date
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
  }

  export type BlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      blocker: Prisma.$UserPayload<ExtArgs>
      blocked: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockerId: string
      blockedId: string
      createdAt: Date
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocker<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    blocked<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */ 
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'String'>
    readonly blockerId: FieldRef<"Block", 'String'>
    readonly blockedId: FieldRef<"Block", 'String'>
    readonly createdAt: FieldRef<"Block", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block createManyAndReturn
   */
  export type BlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    device: string | null
    ip: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    device: string | null
    ip: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    device: number
    ip: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    device?: true
    ip?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    device?: true
    ip?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    device?: true
    ip?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    device: string | null
    ip: string | null
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    device?: boolean
    ip?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    device?: boolean
    ip?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    device?: boolean
    ip?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      device: string | null
      ip: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly device: FieldRef<"Session", 'String'>
    readonly ip: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    avatar: string | null
    bio: string | null
    location: string | null
    website: string | null
    isPublic: boolean | null
    showInSearch: boolean | null
    showActivityStatus: boolean | null
    allowMessagesFromEveryone: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    avatar: string | null
    bio: string | null
    location: string | null
    website: string | null
    isPublic: boolean | null
    showInSearch: boolean | null
    showActivityStatus: boolean | null
    allowMessagesFromEveryone: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    avatar: number
    bio: number
    location: number
    website: number
    isPublic: number
    showInSearch: number
    showActivityStatus: number
    allowMessagesFromEveryone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    avatar?: true
    bio?: true
    location?: true
    website?: true
    isPublic?: true
    showInSearch?: true
    showActivityStatus?: true
    allowMessagesFromEveryone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    avatar?: true
    bio?: true
    location?: true
    website?: true
    isPublic?: true
    showInSearch?: true
    showActivityStatus?: true
    allowMessagesFromEveryone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    avatar?: true
    bio?: true
    location?: true
    website?: true
    isPublic?: true
    showInSearch?: true
    showActivityStatus?: true
    allowMessagesFromEveryone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    avatar: string | null
    bio: string | null
    location: string | null
    website: string | null
    isPublic: boolean
    showInSearch: boolean
    showActivityStatus: boolean
    allowMessagesFromEveryone: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    avatar?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    socialLinks?: boolean | UserProfile$socialLinksArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    avatar?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    avatar?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    socialLinks?: boolean | UserProfile$socialLinksArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      socialLinks: Prisma.$SocialLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      avatar: string | null
      bio: string | null
      location: string | null
      website: string | null
      isPublic: boolean
      showInSearch: boolean
      showActivityStatus: boolean
      allowMessagesFromEveryone: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    socialLinks<T extends UserProfile$socialLinksArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$socialLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */ 
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly avatar: FieldRef<"UserProfile", 'String'>
    readonly bio: FieldRef<"UserProfile", 'String'>
    readonly location: FieldRef<"UserProfile", 'String'>
    readonly website: FieldRef<"UserProfile", 'String'>
    readonly isPublic: FieldRef<"UserProfile", 'Boolean'>
    readonly showInSearch: FieldRef<"UserProfile", 'Boolean'>
    readonly showActivityStatus: FieldRef<"UserProfile", 'Boolean'>
    readonly allowMessagesFromEveryone: FieldRef<"UserProfile", 'Boolean'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile.socialLinks
   */
  export type UserProfile$socialLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    where?: SocialLinkWhereInput
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    cursor?: SocialLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model SocialLink
   */

  export type AggregateSocialLink = {
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  export type SocialLinkMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    platform: string | null
    url: string | null
  }

  export type SocialLinkMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    platform: string | null
    url: string | null
  }

  export type SocialLinkCountAggregateOutputType = {
    id: number
    profileId: number
    platform: number
    url: number
    _all: number
  }


  export type SocialLinkMinAggregateInputType = {
    id?: true
    profileId?: true
    platform?: true
    url?: true
  }

  export type SocialLinkMaxAggregateInputType = {
    id?: true
    profileId?: true
    platform?: true
    url?: true
  }

  export type SocialLinkCountAggregateInputType = {
    id?: true
    profileId?: true
    platform?: true
    url?: true
    _all?: true
  }

  export type SocialLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLink to aggregate.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialLinks
    **/
    _count?: true | SocialLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialLinkMaxAggregateInputType
  }

  export type GetSocialLinkAggregateType<T extends SocialLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialLink[P]>
      : GetScalarType<T[P], AggregateSocialLink[P]>
  }




  export type SocialLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLinkWhereInput
    orderBy?: SocialLinkOrderByWithAggregationInput | SocialLinkOrderByWithAggregationInput[]
    by: SocialLinkScalarFieldEnum[] | SocialLinkScalarFieldEnum
    having?: SocialLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialLinkCountAggregateInputType | true
    _min?: SocialLinkMinAggregateInputType
    _max?: SocialLinkMaxAggregateInputType
  }

  export type SocialLinkGroupByOutputType = {
    id: string
    profileId: string
    platform: string
    url: string
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  type GetSocialLinkGroupByPayload<T extends SocialLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
        }
      >
    >


  export type SocialLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    platform?: boolean
    url?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialLink"]>

  export type SocialLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    platform?: boolean
    url?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialLink"]>

  export type SocialLinkSelectScalar = {
    id?: boolean
    profileId?: boolean
    platform?: boolean
    url?: boolean
  }

  export type SocialLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type SocialLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $SocialLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialLink"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      platform: string
      url: string
    }, ExtArgs["result"]["socialLink"]>
    composites: {}
  }

  type SocialLinkGetPayload<S extends boolean | null | undefined | SocialLinkDefaultArgs> = $Result.GetResult<Prisma.$SocialLinkPayload, S>

  type SocialLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SocialLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SocialLinkCountAggregateInputType | true
    }

  export interface SocialLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialLink'], meta: { name: 'SocialLink' } }
    /**
     * Find zero or one SocialLink that matches the filter.
     * @param {SocialLinkFindUniqueArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialLinkFindUniqueArgs>(args: SelectSubset<T, SocialLinkFindUniqueArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SocialLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SocialLinkFindUniqueOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SocialLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindFirstArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialLinkFindFirstArgs>(args?: SelectSubset<T, SocialLinkFindFirstArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SocialLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindFirstOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialLinks
     * const socialLinks = await prisma.socialLink.findMany()
     * 
     * // Get first 10 SocialLinks
     * const socialLinks = await prisma.socialLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialLinkFindManyArgs>(args?: SelectSubset<T, SocialLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SocialLink.
     * @param {SocialLinkCreateArgs} args - Arguments to create a SocialLink.
     * @example
     * // Create one SocialLink
     * const SocialLink = await prisma.socialLink.create({
     *   data: {
     *     // ... data to create a SocialLink
     *   }
     * })
     * 
     */
    create<T extends SocialLinkCreateArgs>(args: SelectSubset<T, SocialLinkCreateArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SocialLinks.
     * @param {SocialLinkCreateManyArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLink = await prisma.socialLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialLinkCreateManyArgs>(args?: SelectSubset<T, SocialLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialLinks and returns the data saved in the database.
     * @param {SocialLinkCreateManyAndReturnArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLink = await prisma.socialLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialLinks and only return the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SocialLink.
     * @param {SocialLinkDeleteArgs} args - Arguments to delete one SocialLink.
     * @example
     * // Delete one SocialLink
     * const SocialLink = await prisma.socialLink.delete({
     *   where: {
     *     // ... filter to delete one SocialLink
     *   }
     * })
     * 
     */
    delete<T extends SocialLinkDeleteArgs>(args: SelectSubset<T, SocialLinkDeleteArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SocialLink.
     * @param {SocialLinkUpdateArgs} args - Arguments to update one SocialLink.
     * @example
     * // Update one SocialLink
     * const socialLink = await prisma.socialLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialLinkUpdateArgs>(args: SelectSubset<T, SocialLinkUpdateArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SocialLinks.
     * @param {SocialLinkDeleteManyArgs} args - Arguments to filter SocialLinks to delete.
     * @example
     * // Delete a few SocialLinks
     * const { count } = await prisma.socialLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialLinkDeleteManyArgs>(args?: SelectSubset<T, SocialLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialLinks
     * const socialLink = await prisma.socialLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialLinkUpdateManyArgs>(args: SelectSubset<T, SocialLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialLink.
     * @param {SocialLinkUpsertArgs} args - Arguments to update or create a SocialLink.
     * @example
     * // Update or create a SocialLink
     * const socialLink = await prisma.socialLink.upsert({
     *   create: {
     *     // ... data to create a SocialLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialLink we want to update
     *   }
     * })
     */
    upsert<T extends SocialLinkUpsertArgs>(args: SelectSubset<T, SocialLinkUpsertArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkCountArgs} args - Arguments to filter SocialLinks to count.
     * @example
     * // Count the number of SocialLinks
     * const count = await prisma.socialLink.count({
     *   where: {
     *     // ... the filter for the SocialLinks we want to count
     *   }
     * })
    **/
    count<T extends SocialLinkCountArgs>(
      args?: Subset<T, SocialLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialLinkAggregateArgs>(args: Subset<T, SocialLinkAggregateArgs>): Prisma.PrismaPromise<GetSocialLinkAggregateType<T>>

    /**
     * Group by SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialLinkGroupByArgs['orderBy'] }
        : { orderBy?: SocialLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialLink model
   */
  readonly fields: SocialLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialLink model
   */ 
  interface SocialLinkFieldRefs {
    readonly id: FieldRef<"SocialLink", 'String'>
    readonly profileId: FieldRef<"SocialLink", 'String'>
    readonly platform: FieldRef<"SocialLink", 'String'>
    readonly url: FieldRef<"SocialLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SocialLink findUnique
   */
  export type SocialLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink findUniqueOrThrow
   */
  export type SocialLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink findFirst
   */
  export type SocialLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink findFirstOrThrow
   */
  export type SocialLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink findMany
   */
  export type SocialLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink create
   */
  export type SocialLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialLink.
     */
    data: XOR<SocialLinkCreateInput, SocialLinkUncheckedCreateInput>
  }

  /**
   * SocialLink createMany
   */
  export type SocialLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialLinks.
     */
    data: SocialLinkCreateManyInput | SocialLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialLink createManyAndReturn
   */
  export type SocialLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SocialLinks.
     */
    data: SocialLinkCreateManyInput | SocialLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialLink update
   */
  export type SocialLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialLink.
     */
    data: XOR<SocialLinkUpdateInput, SocialLinkUncheckedUpdateInput>
    /**
     * Choose, which SocialLink to update.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink updateMany
   */
  export type SocialLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialLinks.
     */
    data: XOR<SocialLinkUpdateManyMutationInput, SocialLinkUncheckedUpdateManyInput>
    /**
     * Filter which SocialLinks to update
     */
    where?: SocialLinkWhereInput
  }

  /**
   * SocialLink upsert
   */
  export type SocialLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialLink to update in case it exists.
     */
    where: SocialLinkWhereUniqueInput
    /**
     * In case the SocialLink found by the `where` argument doesn't exist, create a new SocialLink with this data.
     */
    create: XOR<SocialLinkCreateInput, SocialLinkUncheckedCreateInput>
    /**
     * In case the SocialLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialLinkUpdateInput, SocialLinkUncheckedUpdateInput>
  }

  /**
   * SocialLink delete
   */
  export type SocialLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter which SocialLink to delete.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink deleteMany
   */
  export type SocialLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLinks to delete
     */
    where?: SocialLinkWhereInput
  }

  /**
   * SocialLink without action
   */
  export type SocialLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
  }


  /**
   * Model FounderProfile
   */

  export type AggregateFounderProfile = {
    _count: FounderProfileCountAggregateOutputType | null
    _min: FounderProfileMinAggregateOutputType | null
    _max: FounderProfileMaxAggregateOutputType | null
  }

  export type FounderProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tagline: string | null
    companyName: string | null
    industry: string | null
    lookingForFunding: boolean | null
    lookingForCofounder: boolean | null
    lookingForFeedback: boolean | null
    previousVentures: string | null
    education: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tagline: string | null
    companyName: string | null
    industry: string | null
    lookingForFunding: boolean | null
    lookingForCofounder: boolean | null
    lookingForFeedback: boolean | null
    previousVentures: string | null
    education: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FounderProfileCountAggregateOutputType = {
    id: number
    userId: number
    tagline: number
    companyName: number
    industry: number
    lookingForFunding: number
    lookingForCofounder: number
    lookingForFeedback: number
    previousVentures: number
    education: number
    skills: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FounderProfileMinAggregateInputType = {
    id?: true
    userId?: true
    tagline?: true
    companyName?: true
    industry?: true
    lookingForFunding?: true
    lookingForCofounder?: true
    lookingForFeedback?: true
    previousVentures?: true
    education?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    tagline?: true
    companyName?: true
    industry?: true
    lookingForFunding?: true
    lookingForCofounder?: true
    lookingForFeedback?: true
    previousVentures?: true
    education?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FounderProfileCountAggregateInputType = {
    id?: true
    userId?: true
    tagline?: true
    companyName?: true
    industry?: true
    lookingForFunding?: true
    lookingForCofounder?: true
    lookingForFeedback?: true
    previousVentures?: true
    education?: true
    skills?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FounderProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FounderProfile to aggregate.
     */
    where?: FounderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderProfiles to fetch.
     */
    orderBy?: FounderProfileOrderByWithRelationInput | FounderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FounderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FounderProfiles
    **/
    _count?: true | FounderProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FounderProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FounderProfileMaxAggregateInputType
  }

  export type GetFounderProfileAggregateType<T extends FounderProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateFounderProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFounderProfile[P]>
      : GetScalarType<T[P], AggregateFounderProfile[P]>
  }




  export type FounderProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FounderProfileWhereInput
    orderBy?: FounderProfileOrderByWithAggregationInput | FounderProfileOrderByWithAggregationInput[]
    by: FounderProfileScalarFieldEnum[] | FounderProfileScalarFieldEnum
    having?: FounderProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FounderProfileCountAggregateInputType | true
    _min?: FounderProfileMinAggregateInputType
    _max?: FounderProfileMaxAggregateInputType
  }

  export type FounderProfileGroupByOutputType = {
    id: string
    userId: string
    tagline: string | null
    companyName: string | null
    industry: string | null
    lookingForFunding: boolean
    lookingForCofounder: boolean
    lookingForFeedback: boolean
    previousVentures: string | null
    education: string | null
    skills: string[]
    createdAt: Date
    updatedAt: Date
    _count: FounderProfileCountAggregateOutputType | null
    _min: FounderProfileMinAggregateOutputType | null
    _max: FounderProfileMaxAggregateOutputType | null
  }

  type GetFounderProfileGroupByPayload<T extends FounderProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FounderProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FounderProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FounderProfileGroupByOutputType[P]>
            : GetScalarType<T[P], FounderProfileGroupByOutputType[P]>
        }
      >
    >


  export type FounderProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tagline?: boolean
    companyName?: boolean
    industry?: boolean
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: boolean
    education?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    fundraisingDetails?: boolean | FounderProfile$fundraisingDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["founderProfile"]>

  export type FounderProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tagline?: boolean
    companyName?: boolean
    industry?: boolean
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: boolean
    education?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["founderProfile"]>

  export type FounderProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    tagline?: boolean
    companyName?: boolean
    industry?: boolean
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: boolean
    education?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FounderProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    fundraisingDetails?: boolean | FounderProfile$fundraisingDetailsArgs<ExtArgs>
  }
  export type FounderProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FounderProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FounderProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      fundraisingDetails: Prisma.$FundraisingDetailsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tagline: string | null
      companyName: string | null
      industry: string | null
      lookingForFunding: boolean
      lookingForCofounder: boolean
      lookingForFeedback: boolean
      previousVentures: string | null
      education: string | null
      skills: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["founderProfile"]>
    composites: {}
  }

  type FounderProfileGetPayload<S extends boolean | null | undefined | FounderProfileDefaultArgs> = $Result.GetResult<Prisma.$FounderProfilePayload, S>

  type FounderProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FounderProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FounderProfileCountAggregateInputType | true
    }

  export interface FounderProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FounderProfile'], meta: { name: 'FounderProfile' } }
    /**
     * Find zero or one FounderProfile that matches the filter.
     * @param {FounderProfileFindUniqueArgs} args - Arguments to find a FounderProfile
     * @example
     * // Get one FounderProfile
     * const founderProfile = await prisma.founderProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FounderProfileFindUniqueArgs>(args: SelectSubset<T, FounderProfileFindUniqueArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FounderProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FounderProfileFindUniqueOrThrowArgs} args - Arguments to find a FounderProfile
     * @example
     * // Get one FounderProfile
     * const founderProfile = await prisma.founderProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FounderProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, FounderProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FounderProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderProfileFindFirstArgs} args - Arguments to find a FounderProfile
     * @example
     * // Get one FounderProfile
     * const founderProfile = await prisma.founderProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FounderProfileFindFirstArgs>(args?: SelectSubset<T, FounderProfileFindFirstArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FounderProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderProfileFindFirstOrThrowArgs} args - Arguments to find a FounderProfile
     * @example
     * // Get one FounderProfile
     * const founderProfile = await prisma.founderProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FounderProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, FounderProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FounderProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FounderProfiles
     * const founderProfiles = await prisma.founderProfile.findMany()
     * 
     * // Get first 10 FounderProfiles
     * const founderProfiles = await prisma.founderProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const founderProfileWithIdOnly = await prisma.founderProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FounderProfileFindManyArgs>(args?: SelectSubset<T, FounderProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FounderProfile.
     * @param {FounderProfileCreateArgs} args - Arguments to create a FounderProfile.
     * @example
     * // Create one FounderProfile
     * const FounderProfile = await prisma.founderProfile.create({
     *   data: {
     *     // ... data to create a FounderProfile
     *   }
     * })
     * 
     */
    create<T extends FounderProfileCreateArgs>(args: SelectSubset<T, FounderProfileCreateArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FounderProfiles.
     * @param {FounderProfileCreateManyArgs} args - Arguments to create many FounderProfiles.
     * @example
     * // Create many FounderProfiles
     * const founderProfile = await prisma.founderProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FounderProfileCreateManyArgs>(args?: SelectSubset<T, FounderProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FounderProfiles and returns the data saved in the database.
     * @param {FounderProfileCreateManyAndReturnArgs} args - Arguments to create many FounderProfiles.
     * @example
     * // Create many FounderProfiles
     * const founderProfile = await prisma.founderProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FounderProfiles and only return the `id`
     * const founderProfileWithIdOnly = await prisma.founderProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FounderProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, FounderProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FounderProfile.
     * @param {FounderProfileDeleteArgs} args - Arguments to delete one FounderProfile.
     * @example
     * // Delete one FounderProfile
     * const FounderProfile = await prisma.founderProfile.delete({
     *   where: {
     *     // ... filter to delete one FounderProfile
     *   }
     * })
     * 
     */
    delete<T extends FounderProfileDeleteArgs>(args: SelectSubset<T, FounderProfileDeleteArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FounderProfile.
     * @param {FounderProfileUpdateArgs} args - Arguments to update one FounderProfile.
     * @example
     * // Update one FounderProfile
     * const founderProfile = await prisma.founderProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FounderProfileUpdateArgs>(args: SelectSubset<T, FounderProfileUpdateArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FounderProfiles.
     * @param {FounderProfileDeleteManyArgs} args - Arguments to filter FounderProfiles to delete.
     * @example
     * // Delete a few FounderProfiles
     * const { count } = await prisma.founderProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FounderProfileDeleteManyArgs>(args?: SelectSubset<T, FounderProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FounderProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FounderProfiles
     * const founderProfile = await prisma.founderProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FounderProfileUpdateManyArgs>(args: SelectSubset<T, FounderProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FounderProfile.
     * @param {FounderProfileUpsertArgs} args - Arguments to update or create a FounderProfile.
     * @example
     * // Update or create a FounderProfile
     * const founderProfile = await prisma.founderProfile.upsert({
     *   create: {
     *     // ... data to create a FounderProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FounderProfile we want to update
     *   }
     * })
     */
    upsert<T extends FounderProfileUpsertArgs>(args: SelectSubset<T, FounderProfileUpsertArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FounderProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderProfileCountArgs} args - Arguments to filter FounderProfiles to count.
     * @example
     * // Count the number of FounderProfiles
     * const count = await prisma.founderProfile.count({
     *   where: {
     *     // ... the filter for the FounderProfiles we want to count
     *   }
     * })
    **/
    count<T extends FounderProfileCountArgs>(
      args?: Subset<T, FounderProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FounderProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FounderProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FounderProfileAggregateArgs>(args: Subset<T, FounderProfileAggregateArgs>): Prisma.PrismaPromise<GetFounderProfileAggregateType<T>>

    /**
     * Group by FounderProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FounderProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FounderProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FounderProfileGroupByArgs['orderBy'] }
        : { orderBy?: FounderProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FounderProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFounderProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FounderProfile model
   */
  readonly fields: FounderProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FounderProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FounderProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fundraisingDetails<T extends FounderProfile$fundraisingDetailsArgs<ExtArgs> = {}>(args?: Subset<T, FounderProfile$fundraisingDetailsArgs<ExtArgs>>): Prisma__FundraisingDetailsClient<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FounderProfile model
   */ 
  interface FounderProfileFieldRefs {
    readonly id: FieldRef<"FounderProfile", 'String'>
    readonly userId: FieldRef<"FounderProfile", 'String'>
    readonly tagline: FieldRef<"FounderProfile", 'String'>
    readonly companyName: FieldRef<"FounderProfile", 'String'>
    readonly industry: FieldRef<"FounderProfile", 'String'>
    readonly lookingForFunding: FieldRef<"FounderProfile", 'Boolean'>
    readonly lookingForCofounder: FieldRef<"FounderProfile", 'Boolean'>
    readonly lookingForFeedback: FieldRef<"FounderProfile", 'Boolean'>
    readonly previousVentures: FieldRef<"FounderProfile", 'String'>
    readonly education: FieldRef<"FounderProfile", 'String'>
    readonly skills: FieldRef<"FounderProfile", 'String[]'>
    readonly createdAt: FieldRef<"FounderProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"FounderProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FounderProfile findUnique
   */
  export type FounderProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    /**
     * Filter, which FounderProfile to fetch.
     */
    where: FounderProfileWhereUniqueInput
  }

  /**
   * FounderProfile findUniqueOrThrow
   */
  export type FounderProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    /**
     * Filter, which FounderProfile to fetch.
     */
    where: FounderProfileWhereUniqueInput
  }

  /**
   * FounderProfile findFirst
   */
  export type FounderProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    /**
     * Filter, which FounderProfile to fetch.
     */
    where?: FounderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderProfiles to fetch.
     */
    orderBy?: FounderProfileOrderByWithRelationInput | FounderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FounderProfiles.
     */
    cursor?: FounderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FounderProfiles.
     */
    distinct?: FounderProfileScalarFieldEnum | FounderProfileScalarFieldEnum[]
  }

  /**
   * FounderProfile findFirstOrThrow
   */
  export type FounderProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    /**
     * Filter, which FounderProfile to fetch.
     */
    where?: FounderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderProfiles to fetch.
     */
    orderBy?: FounderProfileOrderByWithRelationInput | FounderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FounderProfiles.
     */
    cursor?: FounderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FounderProfiles.
     */
    distinct?: FounderProfileScalarFieldEnum | FounderProfileScalarFieldEnum[]
  }

  /**
   * FounderProfile findMany
   */
  export type FounderProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    /**
     * Filter, which FounderProfiles to fetch.
     */
    where?: FounderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FounderProfiles to fetch.
     */
    orderBy?: FounderProfileOrderByWithRelationInput | FounderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FounderProfiles.
     */
    cursor?: FounderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FounderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FounderProfiles.
     */
    skip?: number
    distinct?: FounderProfileScalarFieldEnum | FounderProfileScalarFieldEnum[]
  }

  /**
   * FounderProfile create
   */
  export type FounderProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a FounderProfile.
     */
    data: XOR<FounderProfileCreateInput, FounderProfileUncheckedCreateInput>
  }

  /**
   * FounderProfile createMany
   */
  export type FounderProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FounderProfiles.
     */
    data: FounderProfileCreateManyInput | FounderProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FounderProfile createManyAndReturn
   */
  export type FounderProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FounderProfiles.
     */
    data: FounderProfileCreateManyInput | FounderProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FounderProfile update
   */
  export type FounderProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a FounderProfile.
     */
    data: XOR<FounderProfileUpdateInput, FounderProfileUncheckedUpdateInput>
    /**
     * Choose, which FounderProfile to update.
     */
    where: FounderProfileWhereUniqueInput
  }

  /**
   * FounderProfile updateMany
   */
  export type FounderProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FounderProfiles.
     */
    data: XOR<FounderProfileUpdateManyMutationInput, FounderProfileUncheckedUpdateManyInput>
    /**
     * Filter which FounderProfiles to update
     */
    where?: FounderProfileWhereInput
  }

  /**
   * FounderProfile upsert
   */
  export type FounderProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the FounderProfile to update in case it exists.
     */
    where: FounderProfileWhereUniqueInput
    /**
     * In case the FounderProfile found by the `where` argument doesn't exist, create a new FounderProfile with this data.
     */
    create: XOR<FounderProfileCreateInput, FounderProfileUncheckedCreateInput>
    /**
     * In case the FounderProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FounderProfileUpdateInput, FounderProfileUncheckedUpdateInput>
  }

  /**
   * FounderProfile delete
   */
  export type FounderProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
    /**
     * Filter which FounderProfile to delete.
     */
    where: FounderProfileWhereUniqueInput
  }

  /**
   * FounderProfile deleteMany
   */
  export type FounderProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FounderProfiles to delete
     */
    where?: FounderProfileWhereInput
  }

  /**
   * FounderProfile.fundraisingDetails
   */
  export type FounderProfile$fundraisingDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    where?: FundraisingDetailsWhereInput
  }

  /**
   * FounderProfile without action
   */
  export type FounderProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FounderProfile
     */
    select?: FounderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FounderProfileInclude<ExtArgs> | null
  }


  /**
   * Model FundraisingDetails
   */

  export type AggregateFundraisingDetails = {
    _count: FundraisingDetailsCountAggregateOutputType | null
    _avg: FundraisingDetailsAvgAggregateOutputType | null
    _sum: FundraisingDetailsSumAggregateOutputType | null
    _min: FundraisingDetailsMinAggregateOutputType | null
    _max: FundraisingDetailsMaxAggregateOutputType | null
  }

  export type FundraisingDetailsAvgAggregateOutputType = {
    amount: number | null
  }

  export type FundraisingDetailsSumAggregateOutputType = {
    amount: number | null
  }

  export type FundraisingDetailsMinAggregateOutputType = {
    id: string | null
    founderId: string | null
    stage: string | null
    amount: number | null
    industry: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FundraisingDetailsMaxAggregateOutputType = {
    id: string | null
    founderId: string | null
    stage: string | null
    amount: number | null
    industry: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FundraisingDetailsCountAggregateOutputType = {
    id: number
    founderId: number
    stage: number
    amount: number
    industry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FundraisingDetailsAvgAggregateInputType = {
    amount?: true
  }

  export type FundraisingDetailsSumAggregateInputType = {
    amount?: true
  }

  export type FundraisingDetailsMinAggregateInputType = {
    id?: true
    founderId?: true
    stage?: true
    amount?: true
    industry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FundraisingDetailsMaxAggregateInputType = {
    id?: true
    founderId?: true
    stage?: true
    amount?: true
    industry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FundraisingDetailsCountAggregateInputType = {
    id?: true
    founderId?: true
    stage?: true
    amount?: true
    industry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FundraisingDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FundraisingDetails to aggregate.
     */
    where?: FundraisingDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FundraisingDetails to fetch.
     */
    orderBy?: FundraisingDetailsOrderByWithRelationInput | FundraisingDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FundraisingDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FundraisingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FundraisingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FundraisingDetails
    **/
    _count?: true | FundraisingDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FundraisingDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FundraisingDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FundraisingDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FundraisingDetailsMaxAggregateInputType
  }

  export type GetFundraisingDetailsAggregateType<T extends FundraisingDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateFundraisingDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFundraisingDetails[P]>
      : GetScalarType<T[P], AggregateFundraisingDetails[P]>
  }




  export type FundraisingDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FundraisingDetailsWhereInput
    orderBy?: FundraisingDetailsOrderByWithAggregationInput | FundraisingDetailsOrderByWithAggregationInput[]
    by: FundraisingDetailsScalarFieldEnum[] | FundraisingDetailsScalarFieldEnum
    having?: FundraisingDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FundraisingDetailsCountAggregateInputType | true
    _avg?: FundraisingDetailsAvgAggregateInputType
    _sum?: FundraisingDetailsSumAggregateInputType
    _min?: FundraisingDetailsMinAggregateInputType
    _max?: FundraisingDetailsMaxAggregateInputType
  }

  export type FundraisingDetailsGroupByOutputType = {
    id: string
    founderId: string
    stage: string
    amount: number | null
    industry: string | null
    createdAt: Date
    updatedAt: Date
    _count: FundraisingDetailsCountAggregateOutputType | null
    _avg: FundraisingDetailsAvgAggregateOutputType | null
    _sum: FundraisingDetailsSumAggregateOutputType | null
    _min: FundraisingDetailsMinAggregateOutputType | null
    _max: FundraisingDetailsMaxAggregateOutputType | null
  }

  type GetFundraisingDetailsGroupByPayload<T extends FundraisingDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FundraisingDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FundraisingDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FundraisingDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], FundraisingDetailsGroupByOutputType[P]>
        }
      >
    >


  export type FundraisingDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    stage?: boolean
    amount?: boolean
    industry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founderProfile?: boolean | FounderProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fundraisingDetails"]>

  export type FundraisingDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    founderId?: boolean
    stage?: boolean
    amount?: boolean
    industry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founderProfile?: boolean | FounderProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fundraisingDetails"]>

  export type FundraisingDetailsSelectScalar = {
    id?: boolean
    founderId?: boolean
    stage?: boolean
    amount?: boolean
    industry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FundraisingDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founderProfile?: boolean | FounderProfileDefaultArgs<ExtArgs>
  }
  export type FundraisingDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founderProfile?: boolean | FounderProfileDefaultArgs<ExtArgs>
  }

  export type $FundraisingDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FundraisingDetails"
    objects: {
      founderProfile: Prisma.$FounderProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      founderId: string
      stage: string
      amount: number | null
      industry: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fundraisingDetails"]>
    composites: {}
  }

  type FundraisingDetailsGetPayload<S extends boolean | null | undefined | FundraisingDetailsDefaultArgs> = $Result.GetResult<Prisma.$FundraisingDetailsPayload, S>

  type FundraisingDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FundraisingDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FundraisingDetailsCountAggregateInputType | true
    }

  export interface FundraisingDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FundraisingDetails'], meta: { name: 'FundraisingDetails' } }
    /**
     * Find zero or one FundraisingDetails that matches the filter.
     * @param {FundraisingDetailsFindUniqueArgs} args - Arguments to find a FundraisingDetails
     * @example
     * // Get one FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FundraisingDetailsFindUniqueArgs>(args: SelectSubset<T, FundraisingDetailsFindUniqueArgs<ExtArgs>>): Prisma__FundraisingDetailsClient<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FundraisingDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FundraisingDetailsFindUniqueOrThrowArgs} args - Arguments to find a FundraisingDetails
     * @example
     * // Get one FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FundraisingDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, FundraisingDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FundraisingDetailsClient<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FundraisingDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundraisingDetailsFindFirstArgs} args - Arguments to find a FundraisingDetails
     * @example
     * // Get one FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FundraisingDetailsFindFirstArgs>(args?: SelectSubset<T, FundraisingDetailsFindFirstArgs<ExtArgs>>): Prisma__FundraisingDetailsClient<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FundraisingDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundraisingDetailsFindFirstOrThrowArgs} args - Arguments to find a FundraisingDetails
     * @example
     * // Get one FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FundraisingDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, FundraisingDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FundraisingDetailsClient<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FundraisingDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundraisingDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.findMany()
     * 
     * // Get first 10 FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fundraisingDetailsWithIdOnly = await prisma.fundraisingDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FundraisingDetailsFindManyArgs>(args?: SelectSubset<T, FundraisingDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FundraisingDetails.
     * @param {FundraisingDetailsCreateArgs} args - Arguments to create a FundraisingDetails.
     * @example
     * // Create one FundraisingDetails
     * const FundraisingDetails = await prisma.fundraisingDetails.create({
     *   data: {
     *     // ... data to create a FundraisingDetails
     *   }
     * })
     * 
     */
    create<T extends FundraisingDetailsCreateArgs>(args: SelectSubset<T, FundraisingDetailsCreateArgs<ExtArgs>>): Prisma__FundraisingDetailsClient<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FundraisingDetails.
     * @param {FundraisingDetailsCreateManyArgs} args - Arguments to create many FundraisingDetails.
     * @example
     * // Create many FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FundraisingDetailsCreateManyArgs>(args?: SelectSubset<T, FundraisingDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FundraisingDetails and returns the data saved in the database.
     * @param {FundraisingDetailsCreateManyAndReturnArgs} args - Arguments to create many FundraisingDetails.
     * @example
     * // Create many FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FundraisingDetails and only return the `id`
     * const fundraisingDetailsWithIdOnly = await prisma.fundraisingDetails.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FundraisingDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, FundraisingDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FundraisingDetails.
     * @param {FundraisingDetailsDeleteArgs} args - Arguments to delete one FundraisingDetails.
     * @example
     * // Delete one FundraisingDetails
     * const FundraisingDetails = await prisma.fundraisingDetails.delete({
     *   where: {
     *     // ... filter to delete one FundraisingDetails
     *   }
     * })
     * 
     */
    delete<T extends FundraisingDetailsDeleteArgs>(args: SelectSubset<T, FundraisingDetailsDeleteArgs<ExtArgs>>): Prisma__FundraisingDetailsClient<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FundraisingDetails.
     * @param {FundraisingDetailsUpdateArgs} args - Arguments to update one FundraisingDetails.
     * @example
     * // Update one FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FundraisingDetailsUpdateArgs>(args: SelectSubset<T, FundraisingDetailsUpdateArgs<ExtArgs>>): Prisma__FundraisingDetailsClient<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FundraisingDetails.
     * @param {FundraisingDetailsDeleteManyArgs} args - Arguments to filter FundraisingDetails to delete.
     * @example
     * // Delete a few FundraisingDetails
     * const { count } = await prisma.fundraisingDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FundraisingDetailsDeleteManyArgs>(args?: SelectSubset<T, FundraisingDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FundraisingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundraisingDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FundraisingDetailsUpdateManyArgs>(args: SelectSubset<T, FundraisingDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FundraisingDetails.
     * @param {FundraisingDetailsUpsertArgs} args - Arguments to update or create a FundraisingDetails.
     * @example
     * // Update or create a FundraisingDetails
     * const fundraisingDetails = await prisma.fundraisingDetails.upsert({
     *   create: {
     *     // ... data to create a FundraisingDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FundraisingDetails we want to update
     *   }
     * })
     */
    upsert<T extends FundraisingDetailsUpsertArgs>(args: SelectSubset<T, FundraisingDetailsUpsertArgs<ExtArgs>>): Prisma__FundraisingDetailsClient<$Result.GetResult<Prisma.$FundraisingDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FundraisingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundraisingDetailsCountArgs} args - Arguments to filter FundraisingDetails to count.
     * @example
     * // Count the number of FundraisingDetails
     * const count = await prisma.fundraisingDetails.count({
     *   where: {
     *     // ... the filter for the FundraisingDetails we want to count
     *   }
     * })
    **/
    count<T extends FundraisingDetailsCountArgs>(
      args?: Subset<T, FundraisingDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FundraisingDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FundraisingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundraisingDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FundraisingDetailsAggregateArgs>(args: Subset<T, FundraisingDetailsAggregateArgs>): Prisma.PrismaPromise<GetFundraisingDetailsAggregateType<T>>

    /**
     * Group by FundraisingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundraisingDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FundraisingDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FundraisingDetailsGroupByArgs['orderBy'] }
        : { orderBy?: FundraisingDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FundraisingDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFundraisingDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FundraisingDetails model
   */
  readonly fields: FundraisingDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FundraisingDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FundraisingDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founderProfile<T extends FounderProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FounderProfileDefaultArgs<ExtArgs>>): Prisma__FounderProfileClient<$Result.GetResult<Prisma.$FounderProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FundraisingDetails model
   */ 
  interface FundraisingDetailsFieldRefs {
    readonly id: FieldRef<"FundraisingDetails", 'String'>
    readonly founderId: FieldRef<"FundraisingDetails", 'String'>
    readonly stage: FieldRef<"FundraisingDetails", 'String'>
    readonly amount: FieldRef<"FundraisingDetails", 'Int'>
    readonly industry: FieldRef<"FundraisingDetails", 'String'>
    readonly createdAt: FieldRef<"FundraisingDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"FundraisingDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FundraisingDetails findUnique
   */
  export type FundraisingDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FundraisingDetails to fetch.
     */
    where: FundraisingDetailsWhereUniqueInput
  }

  /**
   * FundraisingDetails findUniqueOrThrow
   */
  export type FundraisingDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FundraisingDetails to fetch.
     */
    where: FundraisingDetailsWhereUniqueInput
  }

  /**
   * FundraisingDetails findFirst
   */
  export type FundraisingDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FundraisingDetails to fetch.
     */
    where?: FundraisingDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FundraisingDetails to fetch.
     */
    orderBy?: FundraisingDetailsOrderByWithRelationInput | FundraisingDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FundraisingDetails.
     */
    cursor?: FundraisingDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FundraisingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FundraisingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FundraisingDetails.
     */
    distinct?: FundraisingDetailsScalarFieldEnum | FundraisingDetailsScalarFieldEnum[]
  }

  /**
   * FundraisingDetails findFirstOrThrow
   */
  export type FundraisingDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FundraisingDetails to fetch.
     */
    where?: FundraisingDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FundraisingDetails to fetch.
     */
    orderBy?: FundraisingDetailsOrderByWithRelationInput | FundraisingDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FundraisingDetails.
     */
    cursor?: FundraisingDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FundraisingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FundraisingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FundraisingDetails.
     */
    distinct?: FundraisingDetailsScalarFieldEnum | FundraisingDetailsScalarFieldEnum[]
  }

  /**
   * FundraisingDetails findMany
   */
  export type FundraisingDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FundraisingDetails to fetch.
     */
    where?: FundraisingDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FundraisingDetails to fetch.
     */
    orderBy?: FundraisingDetailsOrderByWithRelationInput | FundraisingDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FundraisingDetails.
     */
    cursor?: FundraisingDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FundraisingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FundraisingDetails.
     */
    skip?: number
    distinct?: FundraisingDetailsScalarFieldEnum | FundraisingDetailsScalarFieldEnum[]
  }

  /**
   * FundraisingDetails create
   */
  export type FundraisingDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a FundraisingDetails.
     */
    data: XOR<FundraisingDetailsCreateInput, FundraisingDetailsUncheckedCreateInput>
  }

  /**
   * FundraisingDetails createMany
   */
  export type FundraisingDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FundraisingDetails.
     */
    data: FundraisingDetailsCreateManyInput | FundraisingDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FundraisingDetails createManyAndReturn
   */
  export type FundraisingDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FundraisingDetails.
     */
    data: FundraisingDetailsCreateManyInput | FundraisingDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FundraisingDetails update
   */
  export type FundraisingDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a FundraisingDetails.
     */
    data: XOR<FundraisingDetailsUpdateInput, FundraisingDetailsUncheckedUpdateInput>
    /**
     * Choose, which FundraisingDetails to update.
     */
    where: FundraisingDetailsWhereUniqueInput
  }

  /**
   * FundraisingDetails updateMany
   */
  export type FundraisingDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FundraisingDetails.
     */
    data: XOR<FundraisingDetailsUpdateManyMutationInput, FundraisingDetailsUncheckedUpdateManyInput>
    /**
     * Filter which FundraisingDetails to update
     */
    where?: FundraisingDetailsWhereInput
  }

  /**
   * FundraisingDetails upsert
   */
  export type FundraisingDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the FundraisingDetails to update in case it exists.
     */
    where: FundraisingDetailsWhereUniqueInput
    /**
     * In case the FundraisingDetails found by the `where` argument doesn't exist, create a new FundraisingDetails with this data.
     */
    create: XOR<FundraisingDetailsCreateInput, FundraisingDetailsUncheckedCreateInput>
    /**
     * In case the FundraisingDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FundraisingDetailsUpdateInput, FundraisingDetailsUncheckedUpdateInput>
  }

  /**
   * FundraisingDetails delete
   */
  export type FundraisingDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
    /**
     * Filter which FundraisingDetails to delete.
     */
    where: FundraisingDetailsWhereUniqueInput
  }

  /**
   * FundraisingDetails deleteMany
   */
  export type FundraisingDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FundraisingDetails to delete
     */
    where?: FundraisingDetailsWhereInput
  }

  /**
   * FundraisingDetails without action
   */
  export type FundraisingDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraisingDetails
     */
    select?: FundraisingDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundraisingDetailsInclude<ExtArgs> | null
  }


  /**
   * Model InvestorProfile
   */

  export type AggregateInvestorProfile = {
    _count: InvestorProfileCountAggregateOutputType | null
    _avg: InvestorProfileAvgAggregateOutputType | null
    _sum: InvestorProfileSumAggregateOutputType | null
    _min: InvestorProfileMinAggregateOutputType | null
    _max: InvestorProfileMaxAggregateOutputType | null
  }

  export type InvestorProfileAvgAggregateOutputType = {
    checkSizeMin: number | null
    checkSizeMax: number | null
  }

  export type InvestorProfileSumAggregateOutputType = {
    checkSizeMin: number | null
    checkSizeMax: number | null
  }

  export type InvestorProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firm: string | null
    title: string | null
    thesis: string | null
    thesisVideo: string | null
    checkSizeMin: number | null
    checkSizeMax: number | null
    isPublicMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firm: string | null
    title: string | null
    thesis: string | null
    thesisVideo: string | null
    checkSizeMin: number | null
    checkSizeMax: number | null
    isPublicMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorProfileCountAggregateOutputType = {
    id: number
    userId: number
    firm: number
    title: number
    thesis: number
    thesisVideo: number
    checkSizeMin: number
    checkSizeMax: number
    stages: number
    industries: number
    geographies: number
    isPublicMode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorProfileAvgAggregateInputType = {
    checkSizeMin?: true
    checkSizeMax?: true
  }

  export type InvestorProfileSumAggregateInputType = {
    checkSizeMin?: true
    checkSizeMax?: true
  }

  export type InvestorProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firm?: true
    title?: true
    thesis?: true
    thesisVideo?: true
    checkSizeMin?: true
    checkSizeMax?: true
    isPublicMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firm?: true
    title?: true
    thesis?: true
    thesisVideo?: true
    checkSizeMin?: true
    checkSizeMax?: true
    isPublicMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firm?: true
    title?: true
    thesis?: true
    thesisVideo?: true
    checkSizeMin?: true
    checkSizeMax?: true
    stages?: true
    industries?: true
    geographies?: true
    isPublicMode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorProfile to aggregate.
     */
    where?: InvestorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorProfiles to fetch.
     */
    orderBy?: InvestorProfileOrderByWithRelationInput | InvestorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvestorProfiles
    **/
    _count?: true | InvestorProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestorProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestorProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorProfileMaxAggregateInputType
  }

  export type GetInvestorProfileAggregateType<T extends InvestorProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestorProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestorProfile[P]>
      : GetScalarType<T[P], AggregateInvestorProfile[P]>
  }




  export type InvestorProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorProfileWhereInput
    orderBy?: InvestorProfileOrderByWithAggregationInput | InvestorProfileOrderByWithAggregationInput[]
    by: InvestorProfileScalarFieldEnum[] | InvestorProfileScalarFieldEnum
    having?: InvestorProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorProfileCountAggregateInputType | true
    _avg?: InvestorProfileAvgAggregateInputType
    _sum?: InvestorProfileSumAggregateInputType
    _min?: InvestorProfileMinAggregateInputType
    _max?: InvestorProfileMaxAggregateInputType
  }

  export type InvestorProfileGroupByOutputType = {
    id: string
    userId: string
    firm: string | null
    title: string | null
    thesis: string | null
    thesisVideo: string | null
    checkSizeMin: number | null
    checkSizeMax: number | null
    stages: string[]
    industries: string[]
    geographies: string[]
    isPublicMode: boolean
    createdAt: Date
    updatedAt: Date
    _count: InvestorProfileCountAggregateOutputType | null
    _avg: InvestorProfileAvgAggregateOutputType | null
    _sum: InvestorProfileSumAggregateOutputType | null
    _min: InvestorProfileMinAggregateOutputType | null
    _max: InvestorProfileMaxAggregateOutputType | null
  }

  type GetInvestorProfileGroupByPayload<T extends InvestorProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorProfileGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorProfileGroupByOutputType[P]>
        }
      >
    >


  export type InvestorProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firm?: boolean
    title?: boolean
    thesis?: boolean
    thesisVideo?: boolean
    checkSizeMin?: boolean
    checkSizeMax?: boolean
    stages?: boolean
    industries?: boolean
    geographies?: boolean
    isPublicMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    portfolio?: boolean | InvestorProfile$portfolioArgs<ExtArgs>
    _count?: boolean | InvestorProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorProfile"]>

  export type InvestorProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firm?: boolean
    title?: boolean
    thesis?: boolean
    thesisVideo?: boolean
    checkSizeMin?: boolean
    checkSizeMax?: boolean
    stages?: boolean
    industries?: boolean
    geographies?: boolean
    isPublicMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorProfile"]>

  export type InvestorProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    firm?: boolean
    title?: boolean
    thesis?: boolean
    thesisVideo?: boolean
    checkSizeMin?: boolean
    checkSizeMax?: boolean
    stages?: boolean
    industries?: boolean
    geographies?: boolean
    isPublicMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    portfolio?: boolean | InvestorProfile$portfolioArgs<ExtArgs>
    _count?: boolean | InvestorProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvestorProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvestorProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvestorProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      portfolio: Prisma.$PortfolioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firm: string | null
      title: string | null
      thesis: string | null
      thesisVideo: string | null
      checkSizeMin: number | null
      checkSizeMax: number | null
      stages: string[]
      industries: string[]
      geographies: string[]
      isPublicMode: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investorProfile"]>
    composites: {}
  }

  type InvestorProfileGetPayload<S extends boolean | null | undefined | InvestorProfileDefaultArgs> = $Result.GetResult<Prisma.$InvestorProfilePayload, S>

  type InvestorProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvestorProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvestorProfileCountAggregateInputType | true
    }

  export interface InvestorProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvestorProfile'], meta: { name: 'InvestorProfile' } }
    /**
     * Find zero or one InvestorProfile that matches the filter.
     * @param {InvestorProfileFindUniqueArgs} args - Arguments to find a InvestorProfile
     * @example
     * // Get one InvestorProfile
     * const investorProfile = await prisma.investorProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorProfileFindUniqueArgs>(args: SelectSubset<T, InvestorProfileFindUniqueArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvestorProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvestorProfileFindUniqueOrThrowArgs} args - Arguments to find a InvestorProfile
     * @example
     * // Get one InvestorProfile
     * const investorProfile = await prisma.investorProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvestorProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorProfileFindFirstArgs} args - Arguments to find a InvestorProfile
     * @example
     * // Get one InvestorProfile
     * const investorProfile = await prisma.investorProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorProfileFindFirstArgs>(args?: SelectSubset<T, InvestorProfileFindFirstArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvestorProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorProfileFindFirstOrThrowArgs} args - Arguments to find a InvestorProfile
     * @example
     * // Get one InvestorProfile
     * const investorProfile = await prisma.investorProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvestorProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvestorProfiles
     * const investorProfiles = await prisma.investorProfile.findMany()
     * 
     * // Get first 10 InvestorProfiles
     * const investorProfiles = await prisma.investorProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorProfileWithIdOnly = await prisma.investorProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorProfileFindManyArgs>(args?: SelectSubset<T, InvestorProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvestorProfile.
     * @param {InvestorProfileCreateArgs} args - Arguments to create a InvestorProfile.
     * @example
     * // Create one InvestorProfile
     * const InvestorProfile = await prisma.investorProfile.create({
     *   data: {
     *     // ... data to create a InvestorProfile
     *   }
     * })
     * 
     */
    create<T extends InvestorProfileCreateArgs>(args: SelectSubset<T, InvestorProfileCreateArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvestorProfiles.
     * @param {InvestorProfileCreateManyArgs} args - Arguments to create many InvestorProfiles.
     * @example
     * // Create many InvestorProfiles
     * const investorProfile = await prisma.investorProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorProfileCreateManyArgs>(args?: SelectSubset<T, InvestorProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvestorProfiles and returns the data saved in the database.
     * @param {InvestorProfileCreateManyAndReturnArgs} args - Arguments to create many InvestorProfiles.
     * @example
     * // Create many InvestorProfiles
     * const investorProfile = await prisma.investorProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvestorProfiles and only return the `id`
     * const investorProfileWithIdOnly = await prisma.investorProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvestorProfile.
     * @param {InvestorProfileDeleteArgs} args - Arguments to delete one InvestorProfile.
     * @example
     * // Delete one InvestorProfile
     * const InvestorProfile = await prisma.investorProfile.delete({
     *   where: {
     *     // ... filter to delete one InvestorProfile
     *   }
     * })
     * 
     */
    delete<T extends InvestorProfileDeleteArgs>(args: SelectSubset<T, InvestorProfileDeleteArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvestorProfile.
     * @param {InvestorProfileUpdateArgs} args - Arguments to update one InvestorProfile.
     * @example
     * // Update one InvestorProfile
     * const investorProfile = await prisma.investorProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorProfileUpdateArgs>(args: SelectSubset<T, InvestorProfileUpdateArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvestorProfiles.
     * @param {InvestorProfileDeleteManyArgs} args - Arguments to filter InvestorProfiles to delete.
     * @example
     * // Delete a few InvestorProfiles
     * const { count } = await prisma.investorProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorProfileDeleteManyArgs>(args?: SelectSubset<T, InvestorProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvestorProfiles
     * const investorProfile = await prisma.investorProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorProfileUpdateManyArgs>(args: SelectSubset<T, InvestorProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvestorProfile.
     * @param {InvestorProfileUpsertArgs} args - Arguments to update or create a InvestorProfile.
     * @example
     * // Update or create a InvestorProfile
     * const investorProfile = await prisma.investorProfile.upsert({
     *   create: {
     *     // ... data to create a InvestorProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvestorProfile we want to update
     *   }
     * })
     */
    upsert<T extends InvestorProfileUpsertArgs>(args: SelectSubset<T, InvestorProfileUpsertArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvestorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorProfileCountArgs} args - Arguments to filter InvestorProfiles to count.
     * @example
     * // Count the number of InvestorProfiles
     * const count = await prisma.investorProfile.count({
     *   where: {
     *     // ... the filter for the InvestorProfiles we want to count
     *   }
     * })
    **/
    count<T extends InvestorProfileCountArgs>(
      args?: Subset<T, InvestorProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvestorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorProfileAggregateArgs>(args: Subset<T, InvestorProfileAggregateArgs>): Prisma.PrismaPromise<GetInvestorProfileAggregateType<T>>

    /**
     * Group by InvestorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorProfileGroupByArgs['orderBy'] }
        : { orderBy?: InvestorProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvestorProfile model
   */
  readonly fields: InvestorProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvestorProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    portfolio<T extends InvestorProfile$portfolioArgs<ExtArgs> = {}>(args?: Subset<T, InvestorProfile$portfolioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvestorProfile model
   */ 
  interface InvestorProfileFieldRefs {
    readonly id: FieldRef<"InvestorProfile", 'String'>
    readonly userId: FieldRef<"InvestorProfile", 'String'>
    readonly firm: FieldRef<"InvestorProfile", 'String'>
    readonly title: FieldRef<"InvestorProfile", 'String'>
    readonly thesis: FieldRef<"InvestorProfile", 'String'>
    readonly thesisVideo: FieldRef<"InvestorProfile", 'String'>
    readonly checkSizeMin: FieldRef<"InvestorProfile", 'Int'>
    readonly checkSizeMax: FieldRef<"InvestorProfile", 'Int'>
    readonly stages: FieldRef<"InvestorProfile", 'String[]'>
    readonly industries: FieldRef<"InvestorProfile", 'String[]'>
    readonly geographies: FieldRef<"InvestorProfile", 'String[]'>
    readonly isPublicMode: FieldRef<"InvestorProfile", 'Boolean'>
    readonly createdAt: FieldRef<"InvestorProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"InvestorProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvestorProfile findUnique
   */
  export type InvestorProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    /**
     * Filter, which InvestorProfile to fetch.
     */
    where: InvestorProfileWhereUniqueInput
  }

  /**
   * InvestorProfile findUniqueOrThrow
   */
  export type InvestorProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    /**
     * Filter, which InvestorProfile to fetch.
     */
    where: InvestorProfileWhereUniqueInput
  }

  /**
   * InvestorProfile findFirst
   */
  export type InvestorProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    /**
     * Filter, which InvestorProfile to fetch.
     */
    where?: InvestorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorProfiles to fetch.
     */
    orderBy?: InvestorProfileOrderByWithRelationInput | InvestorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorProfiles.
     */
    cursor?: InvestorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorProfiles.
     */
    distinct?: InvestorProfileScalarFieldEnum | InvestorProfileScalarFieldEnum[]
  }

  /**
   * InvestorProfile findFirstOrThrow
   */
  export type InvestorProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    /**
     * Filter, which InvestorProfile to fetch.
     */
    where?: InvestorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorProfiles to fetch.
     */
    orderBy?: InvestorProfileOrderByWithRelationInput | InvestorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorProfiles.
     */
    cursor?: InvestorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorProfiles.
     */
    distinct?: InvestorProfileScalarFieldEnum | InvestorProfileScalarFieldEnum[]
  }

  /**
   * InvestorProfile findMany
   */
  export type InvestorProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    /**
     * Filter, which InvestorProfiles to fetch.
     */
    where?: InvestorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorProfiles to fetch.
     */
    orderBy?: InvestorProfileOrderByWithRelationInput | InvestorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvestorProfiles.
     */
    cursor?: InvestorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorProfiles.
     */
    skip?: number
    distinct?: InvestorProfileScalarFieldEnum | InvestorProfileScalarFieldEnum[]
  }

  /**
   * InvestorProfile create
   */
  export type InvestorProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a InvestorProfile.
     */
    data: XOR<InvestorProfileCreateInput, InvestorProfileUncheckedCreateInput>
  }

  /**
   * InvestorProfile createMany
   */
  export type InvestorProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvestorProfiles.
     */
    data: InvestorProfileCreateManyInput | InvestorProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvestorProfile createManyAndReturn
   */
  export type InvestorProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvestorProfiles.
     */
    data: InvestorProfileCreateManyInput | InvestorProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorProfile update
   */
  export type InvestorProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a InvestorProfile.
     */
    data: XOR<InvestorProfileUpdateInput, InvestorProfileUncheckedUpdateInput>
    /**
     * Choose, which InvestorProfile to update.
     */
    where: InvestorProfileWhereUniqueInput
  }

  /**
   * InvestorProfile updateMany
   */
  export type InvestorProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvestorProfiles.
     */
    data: XOR<InvestorProfileUpdateManyMutationInput, InvestorProfileUncheckedUpdateManyInput>
    /**
     * Filter which InvestorProfiles to update
     */
    where?: InvestorProfileWhereInput
  }

  /**
   * InvestorProfile upsert
   */
  export type InvestorProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the InvestorProfile to update in case it exists.
     */
    where: InvestorProfileWhereUniqueInput
    /**
     * In case the InvestorProfile found by the `where` argument doesn't exist, create a new InvestorProfile with this data.
     */
    create: XOR<InvestorProfileCreateInput, InvestorProfileUncheckedCreateInput>
    /**
     * In case the InvestorProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorProfileUpdateInput, InvestorProfileUncheckedUpdateInput>
  }

  /**
   * InvestorProfile delete
   */
  export type InvestorProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
    /**
     * Filter which InvestorProfile to delete.
     */
    where: InvestorProfileWhereUniqueInput
  }

  /**
   * InvestorProfile deleteMany
   */
  export type InvestorProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorProfiles to delete
     */
    where?: InvestorProfileWhereInput
  }

  /**
   * InvestorProfile.portfolio
   */
  export type InvestorProfile$portfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    cursor?: PortfolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * InvestorProfile without action
   */
  export type InvestorProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorProfile
     */
    select?: InvestorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorProfileInclude<ExtArgs> | null
  }


  /**
   * Model Portfolio
   */

  export type AggregatePortfolio = {
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  export type PortfolioAvgAggregateOutputType = {
    investmentYear: number | null
  }

  export type PortfolioSumAggregateOutputType = {
    investmentYear: number | null
  }

  export type PortfolioMinAggregateOutputType = {
    id: string | null
    investorProfileId: string | null
    companyName: string | null
    companyUrl: string | null
    investmentYear: number | null
  }

  export type PortfolioMaxAggregateOutputType = {
    id: string | null
    investorProfileId: string | null
    companyName: string | null
    companyUrl: string | null
    investmentYear: number | null
  }

  export type PortfolioCountAggregateOutputType = {
    id: number
    investorProfileId: number
    companyName: number
    companyUrl: number
    investmentYear: number
    _all: number
  }


  export type PortfolioAvgAggregateInputType = {
    investmentYear?: true
  }

  export type PortfolioSumAggregateInputType = {
    investmentYear?: true
  }

  export type PortfolioMinAggregateInputType = {
    id?: true
    investorProfileId?: true
    companyName?: true
    companyUrl?: true
    investmentYear?: true
  }

  export type PortfolioMaxAggregateInputType = {
    id?: true
    investorProfileId?: true
    companyName?: true
    companyUrl?: true
    investmentYear?: true
  }

  export type PortfolioCountAggregateInputType = {
    id?: true
    investorProfileId?: true
    companyName?: true
    companyUrl?: true
    investmentYear?: true
    _all?: true
  }

  export type PortfolioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolio to aggregate.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Portfolios
    **/
    _count?: true | PortfolioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortfolioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortfolioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioMaxAggregateInputType
  }

  export type GetPortfolioAggregateType<T extends PortfolioAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio[P]>
      : GetScalarType<T[P], AggregatePortfolio[P]>
  }




  export type PortfolioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithAggregationInput | PortfolioOrderByWithAggregationInput[]
    by: PortfolioScalarFieldEnum[] | PortfolioScalarFieldEnum
    having?: PortfolioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioCountAggregateInputType | true
    _avg?: PortfolioAvgAggregateInputType
    _sum?: PortfolioSumAggregateInputType
    _min?: PortfolioMinAggregateInputType
    _max?: PortfolioMaxAggregateInputType
  }

  export type PortfolioGroupByOutputType = {
    id: string
    investorProfileId: string
    companyName: string
    companyUrl: string | null
    investmentYear: number | null
    _count: PortfolioCountAggregateOutputType | null
    _avg: PortfolioAvgAggregateOutputType | null
    _sum: PortfolioSumAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  type GetPortfolioGroupByPayload<T extends PortfolioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorProfileId?: boolean
    companyName?: boolean
    companyUrl?: boolean
    investmentYear?: boolean
    investorProfile?: boolean | InvestorProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorProfileId?: boolean
    companyName?: boolean
    companyUrl?: boolean
    investmentYear?: boolean
    investorProfile?: boolean | InvestorProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectScalar = {
    id?: boolean
    investorProfileId?: boolean
    companyName?: boolean
    companyUrl?: boolean
    investmentYear?: boolean
  }

  export type PortfolioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investorProfile?: boolean | InvestorProfileDefaultArgs<ExtArgs>
  }
  export type PortfolioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investorProfile?: boolean | InvestorProfileDefaultArgs<ExtArgs>
  }

  export type $PortfolioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Portfolio"
    objects: {
      investorProfile: Prisma.$InvestorProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      investorProfileId: string
      companyName: string
      companyUrl: string | null
      investmentYear: number | null
    }, ExtArgs["result"]["portfolio"]>
    composites: {}
  }

  type PortfolioGetPayload<S extends boolean | null | undefined | PortfolioDefaultArgs> = $Result.GetResult<Prisma.$PortfolioPayload, S>

  type PortfolioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PortfolioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PortfolioCountAggregateInputType | true
    }

  export interface PortfolioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Portfolio'], meta: { name: 'Portfolio' } }
    /**
     * Find zero or one Portfolio that matches the filter.
     * @param {PortfolioFindUniqueArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioFindUniqueArgs>(args: SelectSubset<T, PortfolioFindUniqueArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Portfolio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PortfolioFindUniqueOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Portfolio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioFindFirstArgs>(args?: SelectSubset<T, PortfolioFindFirstArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Portfolio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Portfolios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolios
     * const portfolios = await prisma.portfolio.findMany()
     * 
     * // Get first 10 Portfolios
     * const portfolios = await prisma.portfolio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioFindManyArgs>(args?: SelectSubset<T, PortfolioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Portfolio.
     * @param {PortfolioCreateArgs} args - Arguments to create a Portfolio.
     * @example
     * // Create one Portfolio
     * const Portfolio = await prisma.portfolio.create({
     *   data: {
     *     // ... data to create a Portfolio
     *   }
     * })
     * 
     */
    create<T extends PortfolioCreateArgs>(args: SelectSubset<T, PortfolioCreateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Portfolios.
     * @param {PortfolioCreateManyArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioCreateManyArgs>(args?: SelectSubset<T, PortfolioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Portfolios and returns the data saved in the database.
     * @param {PortfolioCreateManyAndReturnArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Portfolio.
     * @param {PortfolioDeleteArgs} args - Arguments to delete one Portfolio.
     * @example
     * // Delete one Portfolio
     * const Portfolio = await prisma.portfolio.delete({
     *   where: {
     *     // ... filter to delete one Portfolio
     *   }
     * })
     * 
     */
    delete<T extends PortfolioDeleteArgs>(args: SelectSubset<T, PortfolioDeleteArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Portfolio.
     * @param {PortfolioUpdateArgs} args - Arguments to update one Portfolio.
     * @example
     * // Update one Portfolio
     * const portfolio = await prisma.portfolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioUpdateArgs>(args: SelectSubset<T, PortfolioUpdateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Portfolios.
     * @param {PortfolioDeleteManyArgs} args - Arguments to filter Portfolios to delete.
     * @example
     * // Delete a few Portfolios
     * const { count } = await prisma.portfolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioDeleteManyArgs>(args?: SelectSubset<T, PortfolioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioUpdateManyArgs>(args: SelectSubset<T, PortfolioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Portfolio.
     * @param {PortfolioUpsertArgs} args - Arguments to update or create a Portfolio.
     * @example
     * // Update or create a Portfolio
     * const portfolio = await prisma.portfolio.upsert({
     *   create: {
     *     // ... data to create a Portfolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioUpsertArgs>(args: SelectSubset<T, PortfolioUpsertArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCountArgs} args - Arguments to filter Portfolios to count.
     * @example
     * // Count the number of Portfolios
     * const count = await prisma.portfolio.count({
     *   where: {
     *     // ... the filter for the Portfolios we want to count
     *   }
     * })
    **/
    count<T extends PortfolioCountArgs>(
      args?: Subset<T, PortfolioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioAggregateArgs>(args: Subset<T, PortfolioAggregateArgs>): Prisma.PrismaPromise<GetPortfolioAggregateType<T>>

    /**
     * Group by Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Portfolio model
   */
  readonly fields: PortfolioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Portfolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investorProfile<T extends InvestorProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorProfileDefaultArgs<ExtArgs>>): Prisma__InvestorProfileClient<$Result.GetResult<Prisma.$InvestorProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Portfolio model
   */ 
  interface PortfolioFieldRefs {
    readonly id: FieldRef<"Portfolio", 'String'>
    readonly investorProfileId: FieldRef<"Portfolio", 'String'>
    readonly companyName: FieldRef<"Portfolio", 'String'>
    readonly companyUrl: FieldRef<"Portfolio", 'String'>
    readonly investmentYear: FieldRef<"Portfolio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Portfolio findUnique
   */
  export type PortfolioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findUniqueOrThrow
   */
  export type PortfolioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findFirst
   */
  export type PortfolioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findFirstOrThrow
   */
  export type PortfolioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findMany
   */
  export type PortfolioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolios to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio create
   */
  export type PortfolioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to create a Portfolio.
     */
    data: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
  }

  /**
   * Portfolio createMany
   */
  export type PortfolioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Portfolio createManyAndReturn
   */
  export type PortfolioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio update
   */
  export type PortfolioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to update a Portfolio.
     */
    data: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
    /**
     * Choose, which Portfolio to update.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio updateMany
   */
  export type PortfolioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
  }

  /**
   * Portfolio upsert
   */
  export type PortfolioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The filter to search for the Portfolio to update in case it exists.
     */
    where: PortfolioWhereUniqueInput
    /**
     * In case the Portfolio found by the `where` argument doesn't exist, create a new Portfolio with this data.
     */
    create: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
    /**
     * In case the Portfolio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
  }

  /**
   * Portfolio delete
   */
  export type PortfolioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter which Portfolio to delete.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio deleteMany
   */
  export type PortfolioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolios to delete
     */
    where?: PortfolioWhereInput
  }

  /**
   * Portfolio without action
   */
  export type PortfolioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
  }


  /**
   * Model BuilderProfile
   */

  export type AggregateBuilderProfile = {
    _count: BuilderProfileCountAggregateOutputType | null
    _min: BuilderProfileMinAggregateOutputType | null
    _max: BuilderProfileMaxAggregateOutputType | null
  }

  export type BuilderProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    availability: string | null
    lookingForProject: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuilderProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    availability: string | null
    lookingForProject: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuilderProfileCountAggregateOutputType = {
    id: number
    userId: number
    skills: number
    portfolioUrls: number
    availability: number
    lookingForProject: number
    industryInterests: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuilderProfileMinAggregateInputType = {
    id?: true
    userId?: true
    availability?: true
    lookingForProject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuilderProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    availability?: true
    lookingForProject?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuilderProfileCountAggregateInputType = {
    id?: true
    userId?: true
    skills?: true
    portfolioUrls?: true
    availability?: true
    lookingForProject?: true
    industryInterests?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuilderProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuilderProfile to aggregate.
     */
    where?: BuilderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuilderProfiles to fetch.
     */
    orderBy?: BuilderProfileOrderByWithRelationInput | BuilderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuilderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuilderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuilderProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuilderProfiles
    **/
    _count?: true | BuilderProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuilderProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuilderProfileMaxAggregateInputType
  }

  export type GetBuilderProfileAggregateType<T extends BuilderProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilderProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilderProfile[P]>
      : GetScalarType<T[P], AggregateBuilderProfile[P]>
  }




  export type BuilderProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuilderProfileWhereInput
    orderBy?: BuilderProfileOrderByWithAggregationInput | BuilderProfileOrderByWithAggregationInput[]
    by: BuilderProfileScalarFieldEnum[] | BuilderProfileScalarFieldEnum
    having?: BuilderProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuilderProfileCountAggregateInputType | true
    _min?: BuilderProfileMinAggregateInputType
    _max?: BuilderProfileMaxAggregateInputType
  }

  export type BuilderProfileGroupByOutputType = {
    id: string
    userId: string
    skills: string[]
    portfolioUrls: string[]
    availability: string
    lookingForProject: boolean
    industryInterests: string[]
    createdAt: Date
    updatedAt: Date
    _count: BuilderProfileCountAggregateOutputType | null
    _min: BuilderProfileMinAggregateOutputType | null
    _max: BuilderProfileMaxAggregateOutputType | null
  }

  type GetBuilderProfileGroupByPayload<T extends BuilderProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuilderProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuilderProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuilderProfileGroupByOutputType[P]>
            : GetScalarType<T[P], BuilderProfileGroupByOutputType[P]>
        }
      >
    >


  export type BuilderProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skills?: boolean
    portfolioUrls?: boolean
    availability?: boolean
    lookingForProject?: boolean
    industryInterests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["builderProfile"]>

  export type BuilderProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    skills?: boolean
    portfolioUrls?: boolean
    availability?: boolean
    lookingForProject?: boolean
    industryInterests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["builderProfile"]>

  export type BuilderProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    skills?: boolean
    portfolioUrls?: boolean
    availability?: boolean
    lookingForProject?: boolean
    industryInterests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuilderProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BuilderProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BuilderProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuilderProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      skills: string[]
      portfolioUrls: string[]
      availability: string
      lookingForProject: boolean
      industryInterests: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["builderProfile"]>
    composites: {}
  }

  type BuilderProfileGetPayload<S extends boolean | null | undefined | BuilderProfileDefaultArgs> = $Result.GetResult<Prisma.$BuilderProfilePayload, S>

  type BuilderProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuilderProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuilderProfileCountAggregateInputType | true
    }

  export interface BuilderProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuilderProfile'], meta: { name: 'BuilderProfile' } }
    /**
     * Find zero or one BuilderProfile that matches the filter.
     * @param {BuilderProfileFindUniqueArgs} args - Arguments to find a BuilderProfile
     * @example
     * // Get one BuilderProfile
     * const builderProfile = await prisma.builderProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuilderProfileFindUniqueArgs>(args: SelectSubset<T, BuilderProfileFindUniqueArgs<ExtArgs>>): Prisma__BuilderProfileClient<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BuilderProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuilderProfileFindUniqueOrThrowArgs} args - Arguments to find a BuilderProfile
     * @example
     * // Get one BuilderProfile
     * const builderProfile = await prisma.builderProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuilderProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, BuilderProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuilderProfileClient<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BuilderProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderProfileFindFirstArgs} args - Arguments to find a BuilderProfile
     * @example
     * // Get one BuilderProfile
     * const builderProfile = await prisma.builderProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuilderProfileFindFirstArgs>(args?: SelectSubset<T, BuilderProfileFindFirstArgs<ExtArgs>>): Prisma__BuilderProfileClient<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BuilderProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderProfileFindFirstOrThrowArgs} args - Arguments to find a BuilderProfile
     * @example
     * // Get one BuilderProfile
     * const builderProfile = await prisma.builderProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuilderProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, BuilderProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuilderProfileClient<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BuilderProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuilderProfiles
     * const builderProfiles = await prisma.builderProfile.findMany()
     * 
     * // Get first 10 BuilderProfiles
     * const builderProfiles = await prisma.builderProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const builderProfileWithIdOnly = await prisma.builderProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuilderProfileFindManyArgs>(args?: SelectSubset<T, BuilderProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BuilderProfile.
     * @param {BuilderProfileCreateArgs} args - Arguments to create a BuilderProfile.
     * @example
     * // Create one BuilderProfile
     * const BuilderProfile = await prisma.builderProfile.create({
     *   data: {
     *     // ... data to create a BuilderProfile
     *   }
     * })
     * 
     */
    create<T extends BuilderProfileCreateArgs>(args: SelectSubset<T, BuilderProfileCreateArgs<ExtArgs>>): Prisma__BuilderProfileClient<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BuilderProfiles.
     * @param {BuilderProfileCreateManyArgs} args - Arguments to create many BuilderProfiles.
     * @example
     * // Create many BuilderProfiles
     * const builderProfile = await prisma.builderProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuilderProfileCreateManyArgs>(args?: SelectSubset<T, BuilderProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BuilderProfiles and returns the data saved in the database.
     * @param {BuilderProfileCreateManyAndReturnArgs} args - Arguments to create many BuilderProfiles.
     * @example
     * // Create many BuilderProfiles
     * const builderProfile = await prisma.builderProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BuilderProfiles and only return the `id`
     * const builderProfileWithIdOnly = await prisma.builderProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuilderProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, BuilderProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BuilderProfile.
     * @param {BuilderProfileDeleteArgs} args - Arguments to delete one BuilderProfile.
     * @example
     * // Delete one BuilderProfile
     * const BuilderProfile = await prisma.builderProfile.delete({
     *   where: {
     *     // ... filter to delete one BuilderProfile
     *   }
     * })
     * 
     */
    delete<T extends BuilderProfileDeleteArgs>(args: SelectSubset<T, BuilderProfileDeleteArgs<ExtArgs>>): Prisma__BuilderProfileClient<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BuilderProfile.
     * @param {BuilderProfileUpdateArgs} args - Arguments to update one BuilderProfile.
     * @example
     * // Update one BuilderProfile
     * const builderProfile = await prisma.builderProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuilderProfileUpdateArgs>(args: SelectSubset<T, BuilderProfileUpdateArgs<ExtArgs>>): Prisma__BuilderProfileClient<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BuilderProfiles.
     * @param {BuilderProfileDeleteManyArgs} args - Arguments to filter BuilderProfiles to delete.
     * @example
     * // Delete a few BuilderProfiles
     * const { count } = await prisma.builderProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuilderProfileDeleteManyArgs>(args?: SelectSubset<T, BuilderProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuilderProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuilderProfiles
     * const builderProfile = await prisma.builderProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuilderProfileUpdateManyArgs>(args: SelectSubset<T, BuilderProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuilderProfile.
     * @param {BuilderProfileUpsertArgs} args - Arguments to update or create a BuilderProfile.
     * @example
     * // Update or create a BuilderProfile
     * const builderProfile = await prisma.builderProfile.upsert({
     *   create: {
     *     // ... data to create a BuilderProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuilderProfile we want to update
     *   }
     * })
     */
    upsert<T extends BuilderProfileUpsertArgs>(args: SelectSubset<T, BuilderProfileUpsertArgs<ExtArgs>>): Prisma__BuilderProfileClient<$Result.GetResult<Prisma.$BuilderProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BuilderProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderProfileCountArgs} args - Arguments to filter BuilderProfiles to count.
     * @example
     * // Count the number of BuilderProfiles
     * const count = await prisma.builderProfile.count({
     *   where: {
     *     // ... the filter for the BuilderProfiles we want to count
     *   }
     * })
    **/
    count<T extends BuilderProfileCountArgs>(
      args?: Subset<T, BuilderProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuilderProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuilderProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuilderProfileAggregateArgs>(args: Subset<T, BuilderProfileAggregateArgs>): Prisma.PrismaPromise<GetBuilderProfileAggregateType<T>>

    /**
     * Group by BuilderProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuilderProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuilderProfileGroupByArgs['orderBy'] }
        : { orderBy?: BuilderProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuilderProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuilderProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuilderProfile model
   */
  readonly fields: BuilderProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuilderProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuilderProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuilderProfile model
   */ 
  interface BuilderProfileFieldRefs {
    readonly id: FieldRef<"BuilderProfile", 'String'>
    readonly userId: FieldRef<"BuilderProfile", 'String'>
    readonly skills: FieldRef<"BuilderProfile", 'String[]'>
    readonly portfolioUrls: FieldRef<"BuilderProfile", 'String[]'>
    readonly availability: FieldRef<"BuilderProfile", 'String'>
    readonly lookingForProject: FieldRef<"BuilderProfile", 'Boolean'>
    readonly industryInterests: FieldRef<"BuilderProfile", 'String[]'>
    readonly createdAt: FieldRef<"BuilderProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"BuilderProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuilderProfile findUnique
   */
  export type BuilderProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    /**
     * Filter, which BuilderProfile to fetch.
     */
    where: BuilderProfileWhereUniqueInput
  }

  /**
   * BuilderProfile findUniqueOrThrow
   */
  export type BuilderProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    /**
     * Filter, which BuilderProfile to fetch.
     */
    where: BuilderProfileWhereUniqueInput
  }

  /**
   * BuilderProfile findFirst
   */
  export type BuilderProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    /**
     * Filter, which BuilderProfile to fetch.
     */
    where?: BuilderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuilderProfiles to fetch.
     */
    orderBy?: BuilderProfileOrderByWithRelationInput | BuilderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuilderProfiles.
     */
    cursor?: BuilderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuilderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuilderProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuilderProfiles.
     */
    distinct?: BuilderProfileScalarFieldEnum | BuilderProfileScalarFieldEnum[]
  }

  /**
   * BuilderProfile findFirstOrThrow
   */
  export type BuilderProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    /**
     * Filter, which BuilderProfile to fetch.
     */
    where?: BuilderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuilderProfiles to fetch.
     */
    orderBy?: BuilderProfileOrderByWithRelationInput | BuilderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuilderProfiles.
     */
    cursor?: BuilderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuilderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuilderProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuilderProfiles.
     */
    distinct?: BuilderProfileScalarFieldEnum | BuilderProfileScalarFieldEnum[]
  }

  /**
   * BuilderProfile findMany
   */
  export type BuilderProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    /**
     * Filter, which BuilderProfiles to fetch.
     */
    where?: BuilderProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuilderProfiles to fetch.
     */
    orderBy?: BuilderProfileOrderByWithRelationInput | BuilderProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuilderProfiles.
     */
    cursor?: BuilderProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuilderProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuilderProfiles.
     */
    skip?: number
    distinct?: BuilderProfileScalarFieldEnum | BuilderProfileScalarFieldEnum[]
  }

  /**
   * BuilderProfile create
   */
  export type BuilderProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a BuilderProfile.
     */
    data: XOR<BuilderProfileCreateInput, BuilderProfileUncheckedCreateInput>
  }

  /**
   * BuilderProfile createMany
   */
  export type BuilderProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuilderProfiles.
     */
    data: BuilderProfileCreateManyInput | BuilderProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuilderProfile createManyAndReturn
   */
  export type BuilderProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BuilderProfiles.
     */
    data: BuilderProfileCreateManyInput | BuilderProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BuilderProfile update
   */
  export type BuilderProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a BuilderProfile.
     */
    data: XOR<BuilderProfileUpdateInput, BuilderProfileUncheckedUpdateInput>
    /**
     * Choose, which BuilderProfile to update.
     */
    where: BuilderProfileWhereUniqueInput
  }

  /**
   * BuilderProfile updateMany
   */
  export type BuilderProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuilderProfiles.
     */
    data: XOR<BuilderProfileUpdateManyMutationInput, BuilderProfileUncheckedUpdateManyInput>
    /**
     * Filter which BuilderProfiles to update
     */
    where?: BuilderProfileWhereInput
  }

  /**
   * BuilderProfile upsert
   */
  export type BuilderProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the BuilderProfile to update in case it exists.
     */
    where: BuilderProfileWhereUniqueInput
    /**
     * In case the BuilderProfile found by the `where` argument doesn't exist, create a new BuilderProfile with this data.
     */
    create: XOR<BuilderProfileCreateInput, BuilderProfileUncheckedCreateInput>
    /**
     * In case the BuilderProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuilderProfileUpdateInput, BuilderProfileUncheckedUpdateInput>
  }

  /**
   * BuilderProfile delete
   */
  export type BuilderProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
    /**
     * Filter which BuilderProfile to delete.
     */
    where: BuilderProfileWhereUniqueInput
  }

  /**
   * BuilderProfile deleteMany
   */
  export type BuilderProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuilderProfiles to delete
     */
    where?: BuilderProfileWhereInput
  }

  /**
   * BuilderProfile without action
   */
  export type BuilderProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderProfile
     */
    select?: BuilderProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuilderProfileInclude<ExtArgs> | null
  }


  /**
   * Model InvestorVerification
   */

  export type AggregateInvestorVerification = {
    _count: InvestorVerificationCountAggregateOutputType | null
    _min: InvestorVerificationMinAggregateOutputType | null
    _max: InvestorVerificationMaxAggregateOutputType | null
  }

  export type InvestorVerificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    linkedinUrl: string | null
    proofUrl: string | null
    proofDocument: string | null
    status: $Enums.VerificationStatus | null
    reviewerNotes: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorVerificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    linkedinUrl: string | null
    proofUrl: string | null
    proofDocument: string | null
    status: $Enums.VerificationStatus | null
    reviewerNotes: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorVerificationCountAggregateOutputType = {
    id: number
    userId: number
    linkedinUrl: number
    proofUrl: number
    proofDocument: number
    status: number
    reviewerNotes: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorVerificationMinAggregateInputType = {
    id?: true
    userId?: true
    linkedinUrl?: true
    proofUrl?: true
    proofDocument?: true
    status?: true
    reviewerNotes?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorVerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    linkedinUrl?: true
    proofUrl?: true
    proofDocument?: true
    status?: true
    reviewerNotes?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorVerificationCountAggregateInputType = {
    id?: true
    userId?: true
    linkedinUrl?: true
    proofUrl?: true
    proofDocument?: true
    status?: true
    reviewerNotes?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorVerification to aggregate.
     */
    where?: InvestorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorVerifications to fetch.
     */
    orderBy?: InvestorVerificationOrderByWithRelationInput | InvestorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvestorVerifications
    **/
    _count?: true | InvestorVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorVerificationMaxAggregateInputType
  }

  export type GetInvestorVerificationAggregateType<T extends InvestorVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestorVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestorVerification[P]>
      : GetScalarType<T[P], AggregateInvestorVerification[P]>
  }




  export type InvestorVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorVerificationWhereInput
    orderBy?: InvestorVerificationOrderByWithAggregationInput | InvestorVerificationOrderByWithAggregationInput[]
    by: InvestorVerificationScalarFieldEnum[] | InvestorVerificationScalarFieldEnum
    having?: InvestorVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorVerificationCountAggregateInputType | true
    _min?: InvestorVerificationMinAggregateInputType
    _max?: InvestorVerificationMaxAggregateInputType
  }

  export type InvestorVerificationGroupByOutputType = {
    id: string
    userId: string
    linkedinUrl: string | null
    proofUrl: string | null
    proofDocument: string | null
    status: $Enums.VerificationStatus
    reviewerNotes: string | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InvestorVerificationCountAggregateOutputType | null
    _min: InvestorVerificationMinAggregateOutputType | null
    _max: InvestorVerificationMaxAggregateOutputType | null
  }

  type GetInvestorVerificationGroupByPayload<T extends InvestorVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorVerificationGroupByOutputType[P]>
        }
      >
    >


  export type InvestorVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    linkedinUrl?: boolean
    proofUrl?: boolean
    proofDocument?: boolean
    status?: boolean
    reviewerNotes?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorVerification"]>

  export type InvestorVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    linkedinUrl?: boolean
    proofUrl?: boolean
    proofDocument?: boolean
    status?: boolean
    reviewerNotes?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorVerification"]>

  export type InvestorVerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    linkedinUrl?: boolean
    proofUrl?: boolean
    proofDocument?: boolean
    status?: boolean
    reviewerNotes?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvestorVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvestorVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvestorVerification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      linkedinUrl: string | null
      proofUrl: string | null
      proofDocument: string | null
      status: $Enums.VerificationStatus
      reviewerNotes: string | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investorVerification"]>
    composites: {}
  }

  type InvestorVerificationGetPayload<S extends boolean | null | undefined | InvestorVerificationDefaultArgs> = $Result.GetResult<Prisma.$InvestorVerificationPayload, S>

  type InvestorVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvestorVerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvestorVerificationCountAggregateInputType | true
    }

  export interface InvestorVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvestorVerification'], meta: { name: 'InvestorVerification' } }
    /**
     * Find zero or one InvestorVerification that matches the filter.
     * @param {InvestorVerificationFindUniqueArgs} args - Arguments to find a InvestorVerification
     * @example
     * // Get one InvestorVerification
     * const investorVerification = await prisma.investorVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorVerificationFindUniqueArgs>(args: SelectSubset<T, InvestorVerificationFindUniqueArgs<ExtArgs>>): Prisma__InvestorVerificationClient<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvestorVerification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvestorVerificationFindUniqueOrThrowArgs} args - Arguments to find a InvestorVerification
     * @example
     * // Get one InvestorVerification
     * const investorVerification = await prisma.investorVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorVerificationClient<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvestorVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorVerificationFindFirstArgs} args - Arguments to find a InvestorVerification
     * @example
     * // Get one InvestorVerification
     * const investorVerification = await prisma.investorVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorVerificationFindFirstArgs>(args?: SelectSubset<T, InvestorVerificationFindFirstArgs<ExtArgs>>): Prisma__InvestorVerificationClient<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvestorVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorVerificationFindFirstOrThrowArgs} args - Arguments to find a InvestorVerification
     * @example
     * // Get one InvestorVerification
     * const investorVerification = await prisma.investorVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorVerificationClient<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvestorVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvestorVerifications
     * const investorVerifications = await prisma.investorVerification.findMany()
     * 
     * // Get first 10 InvestorVerifications
     * const investorVerifications = await prisma.investorVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorVerificationWithIdOnly = await prisma.investorVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorVerificationFindManyArgs>(args?: SelectSubset<T, InvestorVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvestorVerification.
     * @param {InvestorVerificationCreateArgs} args - Arguments to create a InvestorVerification.
     * @example
     * // Create one InvestorVerification
     * const InvestorVerification = await prisma.investorVerification.create({
     *   data: {
     *     // ... data to create a InvestorVerification
     *   }
     * })
     * 
     */
    create<T extends InvestorVerificationCreateArgs>(args: SelectSubset<T, InvestorVerificationCreateArgs<ExtArgs>>): Prisma__InvestorVerificationClient<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvestorVerifications.
     * @param {InvestorVerificationCreateManyArgs} args - Arguments to create many InvestorVerifications.
     * @example
     * // Create many InvestorVerifications
     * const investorVerification = await prisma.investorVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorVerificationCreateManyArgs>(args?: SelectSubset<T, InvestorVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvestorVerifications and returns the data saved in the database.
     * @param {InvestorVerificationCreateManyAndReturnArgs} args - Arguments to create many InvestorVerifications.
     * @example
     * // Create many InvestorVerifications
     * const investorVerification = await prisma.investorVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvestorVerifications and only return the `id`
     * const investorVerificationWithIdOnly = await prisma.investorVerification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvestorVerification.
     * @param {InvestorVerificationDeleteArgs} args - Arguments to delete one InvestorVerification.
     * @example
     * // Delete one InvestorVerification
     * const InvestorVerification = await prisma.investorVerification.delete({
     *   where: {
     *     // ... filter to delete one InvestorVerification
     *   }
     * })
     * 
     */
    delete<T extends InvestorVerificationDeleteArgs>(args: SelectSubset<T, InvestorVerificationDeleteArgs<ExtArgs>>): Prisma__InvestorVerificationClient<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvestorVerification.
     * @param {InvestorVerificationUpdateArgs} args - Arguments to update one InvestorVerification.
     * @example
     * // Update one InvestorVerification
     * const investorVerification = await prisma.investorVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorVerificationUpdateArgs>(args: SelectSubset<T, InvestorVerificationUpdateArgs<ExtArgs>>): Prisma__InvestorVerificationClient<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvestorVerifications.
     * @param {InvestorVerificationDeleteManyArgs} args - Arguments to filter InvestorVerifications to delete.
     * @example
     * // Delete a few InvestorVerifications
     * const { count } = await prisma.investorVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorVerificationDeleteManyArgs>(args?: SelectSubset<T, InvestorVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvestorVerifications
     * const investorVerification = await prisma.investorVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorVerificationUpdateManyArgs>(args: SelectSubset<T, InvestorVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvestorVerification.
     * @param {InvestorVerificationUpsertArgs} args - Arguments to update or create a InvestorVerification.
     * @example
     * // Update or create a InvestorVerification
     * const investorVerification = await prisma.investorVerification.upsert({
     *   create: {
     *     // ... data to create a InvestorVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvestorVerification we want to update
     *   }
     * })
     */
    upsert<T extends InvestorVerificationUpsertArgs>(args: SelectSubset<T, InvestorVerificationUpsertArgs<ExtArgs>>): Prisma__InvestorVerificationClient<$Result.GetResult<Prisma.$InvestorVerificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvestorVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorVerificationCountArgs} args - Arguments to filter InvestorVerifications to count.
     * @example
     * // Count the number of InvestorVerifications
     * const count = await prisma.investorVerification.count({
     *   where: {
     *     // ... the filter for the InvestorVerifications we want to count
     *   }
     * })
    **/
    count<T extends InvestorVerificationCountArgs>(
      args?: Subset<T, InvestorVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvestorVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorVerificationAggregateArgs>(args: Subset<T, InvestorVerificationAggregateArgs>): Prisma.PrismaPromise<GetInvestorVerificationAggregateType<T>>

    /**
     * Group by InvestorVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorVerificationGroupByArgs['orderBy'] }
        : { orderBy?: InvestorVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvestorVerification model
   */
  readonly fields: InvestorVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvestorVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvestorVerification model
   */ 
  interface InvestorVerificationFieldRefs {
    readonly id: FieldRef<"InvestorVerification", 'String'>
    readonly userId: FieldRef<"InvestorVerification", 'String'>
    readonly linkedinUrl: FieldRef<"InvestorVerification", 'String'>
    readonly proofUrl: FieldRef<"InvestorVerification", 'String'>
    readonly proofDocument: FieldRef<"InvestorVerification", 'String'>
    readonly status: FieldRef<"InvestorVerification", 'VerificationStatus'>
    readonly reviewerNotes: FieldRef<"InvestorVerification", 'String'>
    readonly reviewedAt: FieldRef<"InvestorVerification", 'DateTime'>
    readonly createdAt: FieldRef<"InvestorVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"InvestorVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvestorVerification findUnique
   */
  export type InvestorVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorVerification to fetch.
     */
    where: InvestorVerificationWhereUniqueInput
  }

  /**
   * InvestorVerification findUniqueOrThrow
   */
  export type InvestorVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorVerification to fetch.
     */
    where: InvestorVerificationWhereUniqueInput
  }

  /**
   * InvestorVerification findFirst
   */
  export type InvestorVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorVerification to fetch.
     */
    where?: InvestorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorVerifications to fetch.
     */
    orderBy?: InvestorVerificationOrderByWithRelationInput | InvestorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorVerifications.
     */
    cursor?: InvestorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorVerifications.
     */
    distinct?: InvestorVerificationScalarFieldEnum | InvestorVerificationScalarFieldEnum[]
  }

  /**
   * InvestorVerification findFirstOrThrow
   */
  export type InvestorVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorVerification to fetch.
     */
    where?: InvestorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorVerifications to fetch.
     */
    orderBy?: InvestorVerificationOrderByWithRelationInput | InvestorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorVerifications.
     */
    cursor?: InvestorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorVerifications.
     */
    distinct?: InvestorVerificationScalarFieldEnum | InvestorVerificationScalarFieldEnum[]
  }

  /**
   * InvestorVerification findMany
   */
  export type InvestorVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which InvestorVerifications to fetch.
     */
    where?: InvestorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorVerifications to fetch.
     */
    orderBy?: InvestorVerificationOrderByWithRelationInput | InvestorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvestorVerifications.
     */
    cursor?: InvestorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorVerifications.
     */
    skip?: number
    distinct?: InvestorVerificationScalarFieldEnum | InvestorVerificationScalarFieldEnum[]
  }

  /**
   * InvestorVerification create
   */
  export type InvestorVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a InvestorVerification.
     */
    data: XOR<InvestorVerificationCreateInput, InvestorVerificationUncheckedCreateInput>
  }

  /**
   * InvestorVerification createMany
   */
  export type InvestorVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvestorVerifications.
     */
    data: InvestorVerificationCreateManyInput | InvestorVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvestorVerification createManyAndReturn
   */
  export type InvestorVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvestorVerifications.
     */
    data: InvestorVerificationCreateManyInput | InvestorVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorVerification update
   */
  export type InvestorVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a InvestorVerification.
     */
    data: XOR<InvestorVerificationUpdateInput, InvestorVerificationUncheckedUpdateInput>
    /**
     * Choose, which InvestorVerification to update.
     */
    where: InvestorVerificationWhereUniqueInput
  }

  /**
   * InvestorVerification updateMany
   */
  export type InvestorVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvestorVerifications.
     */
    data: XOR<InvestorVerificationUpdateManyMutationInput, InvestorVerificationUncheckedUpdateManyInput>
    /**
     * Filter which InvestorVerifications to update
     */
    where?: InvestorVerificationWhereInput
  }

  /**
   * InvestorVerification upsert
   */
  export type InvestorVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the InvestorVerification to update in case it exists.
     */
    where: InvestorVerificationWhereUniqueInput
    /**
     * In case the InvestorVerification found by the `where` argument doesn't exist, create a new InvestorVerification with this data.
     */
    create: XOR<InvestorVerificationCreateInput, InvestorVerificationUncheckedCreateInput>
    /**
     * In case the InvestorVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorVerificationUpdateInput, InvestorVerificationUncheckedUpdateInput>
  }

  /**
   * InvestorVerification delete
   */
  export type InvestorVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
    /**
     * Filter which InvestorVerification to delete.
     */
    where: InvestorVerificationWhereUniqueInput
  }

  /**
   * InvestorVerification deleteMany
   */
  export type InvestorVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorVerifications to delete
     */
    where?: InvestorVerificationWhereInput
  }

  /**
   * InvestorVerification without action
   */
  export type InvestorVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorVerification
     */
    select?: InvestorVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorVerificationInclude<ExtArgs> | null
  }


  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    duration: number | null
    qualityScore: number | null
    viewCount: number | null
    likeCount: number | null
    commentCount: number | null
    shareCount: number | null
  }

  export type VideoSumAggregateOutputType = {
    duration: number | null
    qualityScore: number | null
    viewCount: number | null
    likeCount: number | null
    commentCount: number | null
    shareCount: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: string | null
    userId: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    type: $Enums.VideoType | null
    visibility: $Enums.VideoVisibility | null
    isPinned: boolean | null
    caption: string | null
    duration: number | null
    qualityScore: number | null
    viewCount: number | null
    likeCount: number | null
    commentCount: number | null
    shareCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    videoUrl: string | null
    thumbnailUrl: string | null
    type: $Enums.VideoType | null
    visibility: $Enums.VideoVisibility | null
    isPinned: boolean | null
    caption: string | null
    duration: number | null
    qualityScore: number | null
    viewCount: number | null
    likeCount: number | null
    commentCount: number | null
    shareCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    userId: number
    videoUrl: number
    thumbnailUrl: number
    type: number
    visibility: number
    isPinned: number
    caption: number
    duration: number
    tags: number
    qualityScore: number
    viewCount: number
    likeCount: number
    commentCount: number
    shareCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    duration?: true
    qualityScore?: true
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
  }

  export type VideoSumAggregateInputType = {
    duration?: true
    qualityScore?: true
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    userId?: true
    videoUrl?: true
    thumbnailUrl?: true
    type?: true
    visibility?: true
    isPinned?: true
    caption?: true
    duration?: true
    qualityScore?: true
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    userId?: true
    videoUrl?: true
    thumbnailUrl?: true
    type?: true
    visibility?: true
    isPinned?: true
    caption?: true
    duration?: true
    qualityScore?: true
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    userId?: true
    videoUrl?: true
    thumbnailUrl?: true
    type?: true
    visibility?: true
    isPinned?: true
    caption?: true
    duration?: true
    tags?: true
    qualityScore?: true
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    id: string
    userId: string
    videoUrl: string
    thumbnailUrl: string | null
    type: $Enums.VideoType
    visibility: $Enums.VideoVisibility
    isPinned: boolean
    caption: string | null
    duration: number
    tags: string[]
    qualityScore: number | null
    viewCount: number
    likeCount: number
    commentCount: number
    shareCount: number
    createdAt: Date
    updatedAt: Date
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    type?: boolean
    visibility?: boolean
    isPinned?: boolean
    caption?: boolean
    duration?: boolean
    tags?: boolean
    qualityScore?: boolean
    viewCount?: boolean
    likeCount?: boolean
    commentCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transcript?: boolean | Video$transcriptArgs<ExtArgs>
    analytics?: boolean | Video$analyticsArgs<ExtArgs>
    comments?: boolean | Video$commentsArgs<ExtArgs>
    likes?: boolean | Video$likesArgs<ExtArgs>
    saves?: boolean | Video$savesArgs<ExtArgs>
    shares?: boolean | Video$sharesArgs<ExtArgs>
    views?: boolean | Video$viewsArgs<ExtArgs>
    reports?: boolean | Video$reportsArgs<ExtArgs>
    expressInterests?: boolean | Video$expressInterestsArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    type?: boolean
    visibility?: boolean
    isPinned?: boolean
    caption?: boolean
    duration?: boolean
    tags?: boolean
    qualityScore?: boolean
    viewCount?: boolean
    likeCount?: boolean
    commentCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectScalar = {
    id?: boolean
    userId?: boolean
    videoUrl?: boolean
    thumbnailUrl?: boolean
    type?: boolean
    visibility?: boolean
    isPinned?: boolean
    caption?: boolean
    duration?: boolean
    tags?: boolean
    qualityScore?: boolean
    viewCount?: boolean
    likeCount?: boolean
    commentCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transcript?: boolean | Video$transcriptArgs<ExtArgs>
    analytics?: boolean | Video$analyticsArgs<ExtArgs>
    comments?: boolean | Video$commentsArgs<ExtArgs>
    likes?: boolean | Video$likesArgs<ExtArgs>
    saves?: boolean | Video$savesArgs<ExtArgs>
    shares?: boolean | Video$sharesArgs<ExtArgs>
    views?: boolean | Video$viewsArgs<ExtArgs>
    reports?: boolean | Video$reportsArgs<ExtArgs>
    expressInterests?: boolean | Video$expressInterestsArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transcript: Prisma.$VideoTranscriptPayload<ExtArgs> | null
      analytics: Prisma.$VideoAnalyticsPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      saves: Prisma.$SavePayload<ExtArgs>[]
      shares: Prisma.$SharePayload<ExtArgs>[]
      views: Prisma.$VideoViewPayload<ExtArgs>[]
      reports: Prisma.$ContentReportPayload<ExtArgs>[]
      expressInterests: Prisma.$ExpressInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      videoUrl: string
      thumbnailUrl: string | null
      type: $Enums.VideoType
      visibility: $Enums.VideoVisibility
      isPinned: boolean
      caption: string | null
      duration: number
      tags: string[]
      qualityScore: number | null
      viewCount: number
      likeCount: number
      commentCount: number
      shareCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFindUniqueArgs>(args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFindFirstArgs>(args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFindManyArgs>(args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends VideoCreateArgs>(args: SelectSubset<T, VideoCreateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Videos.
     * @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCreateManyArgs>(args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videos and returns the data saved in the database.
     * @param {VideoCreateManyAndReturnArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends VideoDeleteArgs>(args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoUpdateArgs>(args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoDeleteManyArgs>(args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoUpdateManyArgs>(args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends VideoUpsertArgs>(args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transcript<T extends Video$transcriptArgs<ExtArgs> = {}>(args?: Subset<T, Video$transcriptArgs<ExtArgs>>): Prisma__VideoTranscriptClient<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    analytics<T extends Video$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Video$analyticsArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comments<T extends Video$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Video$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends Video$likesArgs<ExtArgs> = {}>(args?: Subset<T, Video$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    saves<T extends Video$savesArgs<ExtArgs> = {}>(args?: Subset<T, Video$savesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "findMany"> | Null>
    shares<T extends Video$sharesArgs<ExtArgs> = {}>(args?: Subset<T, Video$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "findMany"> | Null>
    views<T extends Video$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Video$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Video$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Video$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "findMany"> | Null>
    expressInterests<T extends Video$expressInterestsArgs<ExtArgs> = {}>(args?: Subset<T, Video$expressInterestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Video model
   */ 
  interface VideoFieldRefs {
    readonly id: FieldRef<"Video", 'String'>
    readonly userId: FieldRef<"Video", 'String'>
    readonly videoUrl: FieldRef<"Video", 'String'>
    readonly thumbnailUrl: FieldRef<"Video", 'String'>
    readonly type: FieldRef<"Video", 'VideoType'>
    readonly visibility: FieldRef<"Video", 'VideoVisibility'>
    readonly isPinned: FieldRef<"Video", 'Boolean'>
    readonly caption: FieldRef<"Video", 'String'>
    readonly duration: FieldRef<"Video", 'Int'>
    readonly tags: FieldRef<"Video", 'String[]'>
    readonly qualityScore: FieldRef<"Video", 'Int'>
    readonly viewCount: FieldRef<"Video", 'Int'>
    readonly likeCount: FieldRef<"Video", 'Int'>
    readonly commentCount: FieldRef<"Video", 'Int'>
    readonly shareCount: FieldRef<"Video", 'Int'>
    readonly createdAt: FieldRef<"Video", 'DateTime'>
    readonly updatedAt: FieldRef<"Video", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }

  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Video createManyAndReturn
   */
  export type VideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
  }

  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }

  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
  }

  /**
   * Video.transcript
   */
  export type Video$transcriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    where?: VideoTranscriptWhereInput
  }

  /**
   * Video.analytics
   */
  export type Video$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    where?: VideoAnalyticsWhereInput
  }

  /**
   * Video.comments
   */
  export type Video$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Video.likes
   */
  export type Video$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Video.saves
   */
  export type Video$savesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    where?: SaveWhereInput
    orderBy?: SaveOrderByWithRelationInput | SaveOrderByWithRelationInput[]
    cursor?: SaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaveScalarFieldEnum | SaveScalarFieldEnum[]
  }

  /**
   * Video.shares
   */
  export type Video$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    where?: ShareWhereInput
    orderBy?: ShareOrderByWithRelationInput | ShareOrderByWithRelationInput[]
    cursor?: ShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareScalarFieldEnum | ShareScalarFieldEnum[]
  }

  /**
   * Video.views
   */
  export type Video$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    where?: VideoViewWhereInput
    orderBy?: VideoViewOrderByWithRelationInput | VideoViewOrderByWithRelationInput[]
    cursor?: VideoViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoViewScalarFieldEnum | VideoViewScalarFieldEnum[]
  }

  /**
   * Video.reports
   */
  export type Video$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    where?: ContentReportWhereInput
    orderBy?: ContentReportOrderByWithRelationInput | ContentReportOrderByWithRelationInput[]
    cursor?: ContentReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentReportScalarFieldEnum | ContentReportScalarFieldEnum[]
  }

  /**
   * Video.expressInterests
   */
  export type Video$expressInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    where?: ExpressInterestWhereInput
    orderBy?: ExpressInterestOrderByWithRelationInput | ExpressInterestOrderByWithRelationInput[]
    cursor?: ExpressInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpressInterestScalarFieldEnum | ExpressInterestScalarFieldEnum[]
  }

  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
  }


  /**
   * Model VideoTranscript
   */

  export type AggregateVideoTranscript = {
    _count: VideoTranscriptCountAggregateOutputType | null
    _min: VideoTranscriptMinAggregateOutputType | null
    _max: VideoTranscriptMaxAggregateOutputType | null
  }

  export type VideoTranscriptMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type VideoTranscriptMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type VideoTranscriptCountAggregateOutputType = {
    id: number
    videoId: number
    text: number
    createdAt: number
    _all: number
  }


  export type VideoTranscriptMinAggregateInputType = {
    id?: true
    videoId?: true
    text?: true
    createdAt?: true
  }

  export type VideoTranscriptMaxAggregateInputType = {
    id?: true
    videoId?: true
    text?: true
    createdAt?: true
  }

  export type VideoTranscriptCountAggregateInputType = {
    id?: true
    videoId?: true
    text?: true
    createdAt?: true
    _all?: true
  }

  export type VideoTranscriptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoTranscript to aggregate.
     */
    where?: VideoTranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoTranscripts to fetch.
     */
    orderBy?: VideoTranscriptOrderByWithRelationInput | VideoTranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoTranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoTranscripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoTranscripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoTranscripts
    **/
    _count?: true | VideoTranscriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoTranscriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoTranscriptMaxAggregateInputType
  }

  export type GetVideoTranscriptAggregateType<T extends VideoTranscriptAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoTranscript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoTranscript[P]>
      : GetScalarType<T[P], AggregateVideoTranscript[P]>
  }




  export type VideoTranscriptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoTranscriptWhereInput
    orderBy?: VideoTranscriptOrderByWithAggregationInput | VideoTranscriptOrderByWithAggregationInput[]
    by: VideoTranscriptScalarFieldEnum[] | VideoTranscriptScalarFieldEnum
    having?: VideoTranscriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoTranscriptCountAggregateInputType | true
    _min?: VideoTranscriptMinAggregateInputType
    _max?: VideoTranscriptMaxAggregateInputType
  }

  export type VideoTranscriptGroupByOutputType = {
    id: string
    videoId: string
    text: string
    createdAt: Date
    _count: VideoTranscriptCountAggregateOutputType | null
    _min: VideoTranscriptMinAggregateOutputType | null
    _max: VideoTranscriptMaxAggregateOutputType | null
  }

  type GetVideoTranscriptGroupByPayload<T extends VideoTranscriptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoTranscriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoTranscriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoTranscriptGroupByOutputType[P]>
            : GetScalarType<T[P], VideoTranscriptGroupByOutputType[P]>
        }
      >
    >


  export type VideoTranscriptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    text?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoTranscript"]>

  export type VideoTranscriptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    text?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoTranscript"]>

  export type VideoTranscriptSelectScalar = {
    id?: boolean
    videoId?: boolean
    text?: boolean
    createdAt?: boolean
  }

  export type VideoTranscriptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }
  export type VideoTranscriptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }

  export type $VideoTranscriptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoTranscript"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      text: string
      createdAt: Date
    }, ExtArgs["result"]["videoTranscript"]>
    composites: {}
  }

  type VideoTranscriptGetPayload<S extends boolean | null | undefined | VideoTranscriptDefaultArgs> = $Result.GetResult<Prisma.$VideoTranscriptPayload, S>

  type VideoTranscriptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoTranscriptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoTranscriptCountAggregateInputType | true
    }

  export interface VideoTranscriptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoTranscript'], meta: { name: 'VideoTranscript' } }
    /**
     * Find zero or one VideoTranscript that matches the filter.
     * @param {VideoTranscriptFindUniqueArgs} args - Arguments to find a VideoTranscript
     * @example
     * // Get one VideoTranscript
     * const videoTranscript = await prisma.videoTranscript.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoTranscriptFindUniqueArgs>(args: SelectSubset<T, VideoTranscriptFindUniqueArgs<ExtArgs>>): Prisma__VideoTranscriptClient<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoTranscript that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoTranscriptFindUniqueOrThrowArgs} args - Arguments to find a VideoTranscript
     * @example
     * // Get one VideoTranscript
     * const videoTranscript = await prisma.videoTranscript.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoTranscriptFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoTranscriptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoTranscriptClient<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoTranscript that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoTranscriptFindFirstArgs} args - Arguments to find a VideoTranscript
     * @example
     * // Get one VideoTranscript
     * const videoTranscript = await prisma.videoTranscript.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoTranscriptFindFirstArgs>(args?: SelectSubset<T, VideoTranscriptFindFirstArgs<ExtArgs>>): Prisma__VideoTranscriptClient<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoTranscript that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoTranscriptFindFirstOrThrowArgs} args - Arguments to find a VideoTranscript
     * @example
     * // Get one VideoTranscript
     * const videoTranscript = await prisma.videoTranscript.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoTranscriptFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoTranscriptFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoTranscriptClient<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoTranscripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoTranscriptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoTranscripts
     * const videoTranscripts = await prisma.videoTranscript.findMany()
     * 
     * // Get first 10 VideoTranscripts
     * const videoTranscripts = await prisma.videoTranscript.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoTranscriptWithIdOnly = await prisma.videoTranscript.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoTranscriptFindManyArgs>(args?: SelectSubset<T, VideoTranscriptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoTranscript.
     * @param {VideoTranscriptCreateArgs} args - Arguments to create a VideoTranscript.
     * @example
     * // Create one VideoTranscript
     * const VideoTranscript = await prisma.videoTranscript.create({
     *   data: {
     *     // ... data to create a VideoTranscript
     *   }
     * })
     * 
     */
    create<T extends VideoTranscriptCreateArgs>(args: SelectSubset<T, VideoTranscriptCreateArgs<ExtArgs>>): Prisma__VideoTranscriptClient<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoTranscripts.
     * @param {VideoTranscriptCreateManyArgs} args - Arguments to create many VideoTranscripts.
     * @example
     * // Create many VideoTranscripts
     * const videoTranscript = await prisma.videoTranscript.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoTranscriptCreateManyArgs>(args?: SelectSubset<T, VideoTranscriptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoTranscripts and returns the data saved in the database.
     * @param {VideoTranscriptCreateManyAndReturnArgs} args - Arguments to create many VideoTranscripts.
     * @example
     * // Create many VideoTranscripts
     * const videoTranscript = await prisma.videoTranscript.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoTranscripts and only return the `id`
     * const videoTranscriptWithIdOnly = await prisma.videoTranscript.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoTranscriptCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoTranscriptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoTranscript.
     * @param {VideoTranscriptDeleteArgs} args - Arguments to delete one VideoTranscript.
     * @example
     * // Delete one VideoTranscript
     * const VideoTranscript = await prisma.videoTranscript.delete({
     *   where: {
     *     // ... filter to delete one VideoTranscript
     *   }
     * })
     * 
     */
    delete<T extends VideoTranscriptDeleteArgs>(args: SelectSubset<T, VideoTranscriptDeleteArgs<ExtArgs>>): Prisma__VideoTranscriptClient<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoTranscript.
     * @param {VideoTranscriptUpdateArgs} args - Arguments to update one VideoTranscript.
     * @example
     * // Update one VideoTranscript
     * const videoTranscript = await prisma.videoTranscript.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoTranscriptUpdateArgs>(args: SelectSubset<T, VideoTranscriptUpdateArgs<ExtArgs>>): Prisma__VideoTranscriptClient<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoTranscripts.
     * @param {VideoTranscriptDeleteManyArgs} args - Arguments to filter VideoTranscripts to delete.
     * @example
     * // Delete a few VideoTranscripts
     * const { count } = await prisma.videoTranscript.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoTranscriptDeleteManyArgs>(args?: SelectSubset<T, VideoTranscriptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoTranscripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoTranscriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoTranscripts
     * const videoTranscript = await prisma.videoTranscript.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoTranscriptUpdateManyArgs>(args: SelectSubset<T, VideoTranscriptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoTranscript.
     * @param {VideoTranscriptUpsertArgs} args - Arguments to update or create a VideoTranscript.
     * @example
     * // Update or create a VideoTranscript
     * const videoTranscript = await prisma.videoTranscript.upsert({
     *   create: {
     *     // ... data to create a VideoTranscript
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoTranscript we want to update
     *   }
     * })
     */
    upsert<T extends VideoTranscriptUpsertArgs>(args: SelectSubset<T, VideoTranscriptUpsertArgs<ExtArgs>>): Prisma__VideoTranscriptClient<$Result.GetResult<Prisma.$VideoTranscriptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoTranscripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoTranscriptCountArgs} args - Arguments to filter VideoTranscripts to count.
     * @example
     * // Count the number of VideoTranscripts
     * const count = await prisma.videoTranscript.count({
     *   where: {
     *     // ... the filter for the VideoTranscripts we want to count
     *   }
     * })
    **/
    count<T extends VideoTranscriptCountArgs>(
      args?: Subset<T, VideoTranscriptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoTranscriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoTranscript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoTranscriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoTranscriptAggregateArgs>(args: Subset<T, VideoTranscriptAggregateArgs>): Prisma.PrismaPromise<GetVideoTranscriptAggregateType<T>>

    /**
     * Group by VideoTranscript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoTranscriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoTranscriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoTranscriptGroupByArgs['orderBy'] }
        : { orderBy?: VideoTranscriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoTranscriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoTranscriptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoTranscript model
   */
  readonly fields: VideoTranscriptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoTranscript.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoTranscriptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoTranscript model
   */ 
  interface VideoTranscriptFieldRefs {
    readonly id: FieldRef<"VideoTranscript", 'String'>
    readonly videoId: FieldRef<"VideoTranscript", 'String'>
    readonly text: FieldRef<"VideoTranscript", 'String'>
    readonly createdAt: FieldRef<"VideoTranscript", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoTranscript findUnique
   */
  export type VideoTranscriptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    /**
     * Filter, which VideoTranscript to fetch.
     */
    where: VideoTranscriptWhereUniqueInput
  }

  /**
   * VideoTranscript findUniqueOrThrow
   */
  export type VideoTranscriptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    /**
     * Filter, which VideoTranscript to fetch.
     */
    where: VideoTranscriptWhereUniqueInput
  }

  /**
   * VideoTranscript findFirst
   */
  export type VideoTranscriptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    /**
     * Filter, which VideoTranscript to fetch.
     */
    where?: VideoTranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoTranscripts to fetch.
     */
    orderBy?: VideoTranscriptOrderByWithRelationInput | VideoTranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoTranscripts.
     */
    cursor?: VideoTranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoTranscripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoTranscripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoTranscripts.
     */
    distinct?: VideoTranscriptScalarFieldEnum | VideoTranscriptScalarFieldEnum[]
  }

  /**
   * VideoTranscript findFirstOrThrow
   */
  export type VideoTranscriptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    /**
     * Filter, which VideoTranscript to fetch.
     */
    where?: VideoTranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoTranscripts to fetch.
     */
    orderBy?: VideoTranscriptOrderByWithRelationInput | VideoTranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoTranscripts.
     */
    cursor?: VideoTranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoTranscripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoTranscripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoTranscripts.
     */
    distinct?: VideoTranscriptScalarFieldEnum | VideoTranscriptScalarFieldEnum[]
  }

  /**
   * VideoTranscript findMany
   */
  export type VideoTranscriptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    /**
     * Filter, which VideoTranscripts to fetch.
     */
    where?: VideoTranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoTranscripts to fetch.
     */
    orderBy?: VideoTranscriptOrderByWithRelationInput | VideoTranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoTranscripts.
     */
    cursor?: VideoTranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoTranscripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoTranscripts.
     */
    skip?: number
    distinct?: VideoTranscriptScalarFieldEnum | VideoTranscriptScalarFieldEnum[]
  }

  /**
   * VideoTranscript create
   */
  export type VideoTranscriptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoTranscript.
     */
    data: XOR<VideoTranscriptCreateInput, VideoTranscriptUncheckedCreateInput>
  }

  /**
   * VideoTranscript createMany
   */
  export type VideoTranscriptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoTranscripts.
     */
    data: VideoTranscriptCreateManyInput | VideoTranscriptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoTranscript createManyAndReturn
   */
  export type VideoTranscriptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoTranscripts.
     */
    data: VideoTranscriptCreateManyInput | VideoTranscriptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoTranscript update
   */
  export type VideoTranscriptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoTranscript.
     */
    data: XOR<VideoTranscriptUpdateInput, VideoTranscriptUncheckedUpdateInput>
    /**
     * Choose, which VideoTranscript to update.
     */
    where: VideoTranscriptWhereUniqueInput
  }

  /**
   * VideoTranscript updateMany
   */
  export type VideoTranscriptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoTranscripts.
     */
    data: XOR<VideoTranscriptUpdateManyMutationInput, VideoTranscriptUncheckedUpdateManyInput>
    /**
     * Filter which VideoTranscripts to update
     */
    where?: VideoTranscriptWhereInput
  }

  /**
   * VideoTranscript upsert
   */
  export type VideoTranscriptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoTranscript to update in case it exists.
     */
    where: VideoTranscriptWhereUniqueInput
    /**
     * In case the VideoTranscript found by the `where` argument doesn't exist, create a new VideoTranscript with this data.
     */
    create: XOR<VideoTranscriptCreateInput, VideoTranscriptUncheckedCreateInput>
    /**
     * In case the VideoTranscript was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoTranscriptUpdateInput, VideoTranscriptUncheckedUpdateInput>
  }

  /**
   * VideoTranscript delete
   */
  export type VideoTranscriptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
    /**
     * Filter which VideoTranscript to delete.
     */
    where: VideoTranscriptWhereUniqueInput
  }

  /**
   * VideoTranscript deleteMany
   */
  export type VideoTranscriptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoTranscripts to delete
     */
    where?: VideoTranscriptWhereInput
  }

  /**
   * VideoTranscript without action
   */
  export type VideoTranscriptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoTranscript
     */
    select?: VideoTranscriptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoTranscriptInclude<ExtArgs> | null
  }


  /**
   * Model VideoAnalytics
   */

  export type AggregateVideoAnalytics = {
    _count: VideoAnalyticsCountAggregateOutputType | null
    _avg: VideoAnalyticsAvgAggregateOutputType | null
    _sum: VideoAnalyticsSumAggregateOutputType | null
    _min: VideoAnalyticsMinAggregateOutputType | null
    _max: VideoAnalyticsMaxAggregateOutputType | null
  }

  export type VideoAnalyticsAvgAggregateOutputType = {
    totalViews: number | null
    uniqueViews: number | null
    investorViews: number | null
    founderViews: number | null
    builderViews: number | null
    averageWatchTime: number | null
    completionRate: number | null
    replayRate: number | null
  }

  export type VideoAnalyticsSumAggregateOutputType = {
    totalViews: number | null
    uniqueViews: number | null
    investorViews: number | null
    founderViews: number | null
    builderViews: number | null
    averageWatchTime: number | null
    completionRate: number | null
    replayRate: number | null
  }

  export type VideoAnalyticsMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    totalViews: number | null
    uniqueViews: number | null
    investorViews: number | null
    founderViews: number | null
    builderViews: number | null
    averageWatchTime: number | null
    completionRate: number | null
    replayRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoAnalyticsMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    totalViews: number | null
    uniqueViews: number | null
    investorViews: number | null
    founderViews: number | null
    builderViews: number | null
    averageWatchTime: number | null
    completionRate: number | null
    replayRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoAnalyticsCountAggregateOutputType = {
    id: number
    videoId: number
    totalViews: number
    uniqueViews: number
    investorViews: number
    founderViews: number
    builderViews: number
    averageWatchTime: number
    completionRate: number
    replayRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoAnalyticsAvgAggregateInputType = {
    totalViews?: true
    uniqueViews?: true
    investorViews?: true
    founderViews?: true
    builderViews?: true
    averageWatchTime?: true
    completionRate?: true
    replayRate?: true
  }

  export type VideoAnalyticsSumAggregateInputType = {
    totalViews?: true
    uniqueViews?: true
    investorViews?: true
    founderViews?: true
    builderViews?: true
    averageWatchTime?: true
    completionRate?: true
    replayRate?: true
  }

  export type VideoAnalyticsMinAggregateInputType = {
    id?: true
    videoId?: true
    totalViews?: true
    uniqueViews?: true
    investorViews?: true
    founderViews?: true
    builderViews?: true
    averageWatchTime?: true
    completionRate?: true
    replayRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoAnalyticsMaxAggregateInputType = {
    id?: true
    videoId?: true
    totalViews?: true
    uniqueViews?: true
    investorViews?: true
    founderViews?: true
    builderViews?: true
    averageWatchTime?: true
    completionRate?: true
    replayRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoAnalyticsCountAggregateInputType = {
    id?: true
    videoId?: true
    totalViews?: true
    uniqueViews?: true
    investorViews?: true
    founderViews?: true
    builderViews?: true
    averageWatchTime?: true
    completionRate?: true
    replayRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoAnalytics to aggregate.
     */
    where?: VideoAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoAnalytics to fetch.
     */
    orderBy?: VideoAnalyticsOrderByWithRelationInput | VideoAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoAnalytics
    **/
    _count?: true | VideoAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoAnalyticsMaxAggregateInputType
  }

  export type GetVideoAnalyticsAggregateType<T extends VideoAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoAnalytics[P]>
      : GetScalarType<T[P], AggregateVideoAnalytics[P]>
  }




  export type VideoAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoAnalyticsWhereInput
    orderBy?: VideoAnalyticsOrderByWithAggregationInput | VideoAnalyticsOrderByWithAggregationInput[]
    by: VideoAnalyticsScalarFieldEnum[] | VideoAnalyticsScalarFieldEnum
    having?: VideoAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoAnalyticsCountAggregateInputType | true
    _avg?: VideoAnalyticsAvgAggregateInputType
    _sum?: VideoAnalyticsSumAggregateInputType
    _min?: VideoAnalyticsMinAggregateInputType
    _max?: VideoAnalyticsMaxAggregateInputType
  }

  export type VideoAnalyticsGroupByOutputType = {
    id: string
    videoId: string
    totalViews: number
    uniqueViews: number
    investorViews: number
    founderViews: number
    builderViews: number
    averageWatchTime: number
    completionRate: number
    replayRate: number
    createdAt: Date
    updatedAt: Date
    _count: VideoAnalyticsCountAggregateOutputType | null
    _avg: VideoAnalyticsAvgAggregateOutputType | null
    _sum: VideoAnalyticsSumAggregateOutputType | null
    _min: VideoAnalyticsMinAggregateOutputType | null
    _max: VideoAnalyticsMaxAggregateOutputType | null
  }

  type GetVideoAnalyticsGroupByPayload<T extends VideoAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], VideoAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type VideoAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    totalViews?: boolean
    uniqueViews?: boolean
    investorViews?: boolean
    founderViews?: boolean
    builderViews?: boolean
    averageWatchTime?: boolean
    completionRate?: boolean
    replayRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoAnalytics"]>

  export type VideoAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    totalViews?: boolean
    uniqueViews?: boolean
    investorViews?: boolean
    founderViews?: boolean
    builderViews?: boolean
    averageWatchTime?: boolean
    completionRate?: boolean
    replayRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoAnalytics"]>

  export type VideoAnalyticsSelectScalar = {
    id?: boolean
    videoId?: boolean
    totalViews?: boolean
    uniqueViews?: boolean
    investorViews?: boolean
    founderViews?: boolean
    builderViews?: boolean
    averageWatchTime?: boolean
    completionRate?: boolean
    replayRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }
  export type VideoAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }

  export type $VideoAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoAnalytics"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      totalViews: number
      uniqueViews: number
      investorViews: number
      founderViews: number
      builderViews: number
      averageWatchTime: number
      completionRate: number
      replayRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["videoAnalytics"]>
    composites: {}
  }

  type VideoAnalyticsGetPayload<S extends boolean | null | undefined | VideoAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$VideoAnalyticsPayload, S>

  type VideoAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoAnalyticsCountAggregateInputType | true
    }

  export interface VideoAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoAnalytics'], meta: { name: 'VideoAnalytics' } }
    /**
     * Find zero or one VideoAnalytics that matches the filter.
     * @param {VideoAnalyticsFindUniqueArgs} args - Arguments to find a VideoAnalytics
     * @example
     * // Get one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoAnalyticsFindUniqueArgs>(args: SelectSubset<T, VideoAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a VideoAnalytics
     * @example
     * // Get one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsFindFirstArgs} args - Arguments to find a VideoAnalytics
     * @example
     * // Get one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoAnalyticsFindFirstArgs>(args?: SelectSubset<T, VideoAnalyticsFindFirstArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsFindFirstOrThrowArgs} args - Arguments to find a VideoAnalytics
     * @example
     * // Get one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findMany()
     * 
     * // Get first 10 VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoAnalyticsWithIdOnly = await prisma.videoAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoAnalyticsFindManyArgs>(args?: SelectSubset<T, VideoAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoAnalytics.
     * @param {VideoAnalyticsCreateArgs} args - Arguments to create a VideoAnalytics.
     * @example
     * // Create one VideoAnalytics
     * const VideoAnalytics = await prisma.videoAnalytics.create({
     *   data: {
     *     // ... data to create a VideoAnalytics
     *   }
     * })
     * 
     */
    create<T extends VideoAnalyticsCreateArgs>(args: SelectSubset<T, VideoAnalyticsCreateArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoAnalytics.
     * @param {VideoAnalyticsCreateManyArgs} args - Arguments to create many VideoAnalytics.
     * @example
     * // Create many VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoAnalyticsCreateManyArgs>(args?: SelectSubset<T, VideoAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoAnalytics and returns the data saved in the database.
     * @param {VideoAnalyticsCreateManyAndReturnArgs} args - Arguments to create many VideoAnalytics.
     * @example
     * // Create many VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoAnalytics and only return the `id`
     * const videoAnalyticsWithIdOnly = await prisma.videoAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoAnalytics.
     * @param {VideoAnalyticsDeleteArgs} args - Arguments to delete one VideoAnalytics.
     * @example
     * // Delete one VideoAnalytics
     * const VideoAnalytics = await prisma.videoAnalytics.delete({
     *   where: {
     *     // ... filter to delete one VideoAnalytics
     *   }
     * })
     * 
     */
    delete<T extends VideoAnalyticsDeleteArgs>(args: SelectSubset<T, VideoAnalyticsDeleteArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoAnalytics.
     * @param {VideoAnalyticsUpdateArgs} args - Arguments to update one VideoAnalytics.
     * @example
     * // Update one VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoAnalyticsUpdateArgs>(args: SelectSubset<T, VideoAnalyticsUpdateArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoAnalytics.
     * @param {VideoAnalyticsDeleteManyArgs} args - Arguments to filter VideoAnalytics to delete.
     * @example
     * // Delete a few VideoAnalytics
     * const { count } = await prisma.videoAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoAnalyticsDeleteManyArgs>(args?: SelectSubset<T, VideoAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoAnalyticsUpdateManyArgs>(args: SelectSubset<T, VideoAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoAnalytics.
     * @param {VideoAnalyticsUpsertArgs} args - Arguments to update or create a VideoAnalytics.
     * @example
     * // Update or create a VideoAnalytics
     * const videoAnalytics = await prisma.videoAnalytics.upsert({
     *   create: {
     *     // ... data to create a VideoAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends VideoAnalyticsUpsertArgs>(args: SelectSubset<T, VideoAnalyticsUpsertArgs<ExtArgs>>): Prisma__VideoAnalyticsClient<$Result.GetResult<Prisma.$VideoAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsCountArgs} args - Arguments to filter VideoAnalytics to count.
     * @example
     * // Count the number of VideoAnalytics
     * const count = await prisma.videoAnalytics.count({
     *   where: {
     *     // ... the filter for the VideoAnalytics we want to count
     *   }
     * })
    **/
    count<T extends VideoAnalyticsCountArgs>(
      args?: Subset<T, VideoAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAnalyticsAggregateArgs>(args: Subset<T, VideoAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetVideoAnalyticsAggregateType<T>>

    /**
     * Group by VideoAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: VideoAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoAnalytics model
   */
  readonly fields: VideoAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoAnalytics model
   */ 
  interface VideoAnalyticsFieldRefs {
    readonly id: FieldRef<"VideoAnalytics", 'String'>
    readonly videoId: FieldRef<"VideoAnalytics", 'String'>
    readonly totalViews: FieldRef<"VideoAnalytics", 'Int'>
    readonly uniqueViews: FieldRef<"VideoAnalytics", 'Int'>
    readonly investorViews: FieldRef<"VideoAnalytics", 'Int'>
    readonly founderViews: FieldRef<"VideoAnalytics", 'Int'>
    readonly builderViews: FieldRef<"VideoAnalytics", 'Int'>
    readonly averageWatchTime: FieldRef<"VideoAnalytics", 'Float'>
    readonly completionRate: FieldRef<"VideoAnalytics", 'Float'>
    readonly replayRate: FieldRef<"VideoAnalytics", 'Float'>
    readonly createdAt: FieldRef<"VideoAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoAnalytics findUnique
   */
  export type VideoAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where: VideoAnalyticsWhereUniqueInput
  }

  /**
   * VideoAnalytics findUniqueOrThrow
   */
  export type VideoAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where: VideoAnalyticsWhereUniqueInput
  }

  /**
   * VideoAnalytics findFirst
   */
  export type VideoAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where?: VideoAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoAnalytics to fetch.
     */
    orderBy?: VideoAnalyticsOrderByWithRelationInput | VideoAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoAnalytics.
     */
    cursor?: VideoAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoAnalytics.
     */
    distinct?: VideoAnalyticsScalarFieldEnum | VideoAnalyticsScalarFieldEnum[]
  }

  /**
   * VideoAnalytics findFirstOrThrow
   */
  export type VideoAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where?: VideoAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoAnalytics to fetch.
     */
    orderBy?: VideoAnalyticsOrderByWithRelationInput | VideoAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoAnalytics.
     */
    cursor?: VideoAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoAnalytics.
     */
    distinct?: VideoAnalyticsScalarFieldEnum | VideoAnalyticsScalarFieldEnum[]
  }

  /**
   * VideoAnalytics findMany
   */
  export type VideoAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which VideoAnalytics to fetch.
     */
    where?: VideoAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoAnalytics to fetch.
     */
    orderBy?: VideoAnalyticsOrderByWithRelationInput | VideoAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoAnalytics.
     */
    cursor?: VideoAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoAnalytics.
     */
    skip?: number
    distinct?: VideoAnalyticsScalarFieldEnum | VideoAnalyticsScalarFieldEnum[]
  }

  /**
   * VideoAnalytics create
   */
  export type VideoAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoAnalytics.
     */
    data: XOR<VideoAnalyticsCreateInput, VideoAnalyticsUncheckedCreateInput>
  }

  /**
   * VideoAnalytics createMany
   */
  export type VideoAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoAnalytics.
     */
    data: VideoAnalyticsCreateManyInput | VideoAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoAnalytics createManyAndReturn
   */
  export type VideoAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoAnalytics.
     */
    data: VideoAnalyticsCreateManyInput | VideoAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoAnalytics update
   */
  export type VideoAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoAnalytics.
     */
    data: XOR<VideoAnalyticsUpdateInput, VideoAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which VideoAnalytics to update.
     */
    where: VideoAnalyticsWhereUniqueInput
  }

  /**
   * VideoAnalytics updateMany
   */
  export type VideoAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoAnalytics.
     */
    data: XOR<VideoAnalyticsUpdateManyMutationInput, VideoAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which VideoAnalytics to update
     */
    where?: VideoAnalyticsWhereInput
  }

  /**
   * VideoAnalytics upsert
   */
  export type VideoAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoAnalytics to update in case it exists.
     */
    where: VideoAnalyticsWhereUniqueInput
    /**
     * In case the VideoAnalytics found by the `where` argument doesn't exist, create a new VideoAnalytics with this data.
     */
    create: XOR<VideoAnalyticsCreateInput, VideoAnalyticsUncheckedCreateInput>
    /**
     * In case the VideoAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoAnalyticsUpdateInput, VideoAnalyticsUncheckedUpdateInput>
  }

  /**
   * VideoAnalytics delete
   */
  export type VideoAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which VideoAnalytics to delete.
     */
    where: VideoAnalyticsWhereUniqueInput
  }

  /**
   * VideoAnalytics deleteMany
   */
  export type VideoAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoAnalytics to delete
     */
    where?: VideoAnalyticsWhereInput
  }

  /**
   * VideoAnalytics without action
   */
  export type VideoAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalytics
     */
    select?: VideoAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model VideoView
   */

  export type AggregateVideoView = {
    _count: VideoViewCountAggregateOutputType | null
    _avg: VideoViewAvgAggregateOutputType | null
    _sum: VideoViewSumAggregateOutputType | null
    _min: VideoViewMinAggregateOutputType | null
    _max: VideoViewMaxAggregateOutputType | null
  }

  export type VideoViewAvgAggregateOutputType = {
    watchTime: number | null
    replays: number | null
  }

  export type VideoViewSumAggregateOutputType = {
    watchTime: number | null
    replays: number | null
  }

  export type VideoViewMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    viewerId: string | null
    watchTime: number | null
    completed: boolean | null
    replays: number | null
    createdAt: Date | null
  }

  export type VideoViewMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    viewerId: string | null
    watchTime: number | null
    completed: boolean | null
    replays: number | null
    createdAt: Date | null
  }

  export type VideoViewCountAggregateOutputType = {
    id: number
    videoId: number
    viewerId: number
    watchTime: number
    completed: number
    replays: number
    createdAt: number
    _all: number
  }


  export type VideoViewAvgAggregateInputType = {
    watchTime?: true
    replays?: true
  }

  export type VideoViewSumAggregateInputType = {
    watchTime?: true
    replays?: true
  }

  export type VideoViewMinAggregateInputType = {
    id?: true
    videoId?: true
    viewerId?: true
    watchTime?: true
    completed?: true
    replays?: true
    createdAt?: true
  }

  export type VideoViewMaxAggregateInputType = {
    id?: true
    videoId?: true
    viewerId?: true
    watchTime?: true
    completed?: true
    replays?: true
    createdAt?: true
  }

  export type VideoViewCountAggregateInputType = {
    id?: true
    videoId?: true
    viewerId?: true
    watchTime?: true
    completed?: true
    replays?: true
    createdAt?: true
    _all?: true
  }

  export type VideoViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoView to aggregate.
     */
    where?: VideoViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoViews to fetch.
     */
    orderBy?: VideoViewOrderByWithRelationInput | VideoViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoViews
    **/
    _count?: true | VideoViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoViewMaxAggregateInputType
  }

  export type GetVideoViewAggregateType<T extends VideoViewAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoView[P]>
      : GetScalarType<T[P], AggregateVideoView[P]>
  }




  export type VideoViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoViewWhereInput
    orderBy?: VideoViewOrderByWithAggregationInput | VideoViewOrderByWithAggregationInput[]
    by: VideoViewScalarFieldEnum[] | VideoViewScalarFieldEnum
    having?: VideoViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoViewCountAggregateInputType | true
    _avg?: VideoViewAvgAggregateInputType
    _sum?: VideoViewSumAggregateInputType
    _min?: VideoViewMinAggregateInputType
    _max?: VideoViewMaxAggregateInputType
  }

  export type VideoViewGroupByOutputType = {
    id: string
    videoId: string
    viewerId: string
    watchTime: number
    completed: boolean
    replays: number
    createdAt: Date
    _count: VideoViewCountAggregateOutputType | null
    _avg: VideoViewAvgAggregateOutputType | null
    _sum: VideoViewSumAggregateOutputType | null
    _min: VideoViewMinAggregateOutputType | null
    _max: VideoViewMaxAggregateOutputType | null
  }

  type GetVideoViewGroupByPayload<T extends VideoViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoViewGroupByOutputType[P]>
            : GetScalarType<T[P], VideoViewGroupByOutputType[P]>
        }
      >
    >


  export type VideoViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    viewerId?: boolean
    watchTime?: boolean
    completed?: boolean
    replays?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    viewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoView"]>

  export type VideoViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    viewerId?: boolean
    watchTime?: boolean
    completed?: boolean
    replays?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    viewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoView"]>

  export type VideoViewSelectScalar = {
    id?: boolean
    videoId?: boolean
    viewerId?: boolean
    watchTime?: boolean
    completed?: boolean
    replays?: boolean
    createdAt?: boolean
  }

  export type VideoViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    viewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VideoViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    viewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VideoViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoView"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
      viewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      viewerId: string
      watchTime: number
      completed: boolean
      replays: number
      createdAt: Date
    }, ExtArgs["result"]["videoView"]>
    composites: {}
  }

  type VideoViewGetPayload<S extends boolean | null | undefined | VideoViewDefaultArgs> = $Result.GetResult<Prisma.$VideoViewPayload, S>

  type VideoViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoViewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoViewCountAggregateInputType | true
    }

  export interface VideoViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoView'], meta: { name: 'VideoView' } }
    /**
     * Find zero or one VideoView that matches the filter.
     * @param {VideoViewFindUniqueArgs} args - Arguments to find a VideoView
     * @example
     * // Get one VideoView
     * const videoView = await prisma.videoView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoViewFindUniqueArgs>(args: SelectSubset<T, VideoViewFindUniqueArgs<ExtArgs>>): Prisma__VideoViewClient<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoView that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoViewFindUniqueOrThrowArgs} args - Arguments to find a VideoView
     * @example
     * // Get one VideoView
     * const videoView = await prisma.videoView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoViewFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoViewClient<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoViewFindFirstArgs} args - Arguments to find a VideoView
     * @example
     * // Get one VideoView
     * const videoView = await prisma.videoView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoViewFindFirstArgs>(args?: SelectSubset<T, VideoViewFindFirstArgs<ExtArgs>>): Prisma__VideoViewClient<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoViewFindFirstOrThrowArgs} args - Arguments to find a VideoView
     * @example
     * // Get one VideoView
     * const videoView = await prisma.videoView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoViewFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoViewClient<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoViews
     * const videoViews = await prisma.videoView.findMany()
     * 
     * // Get first 10 VideoViews
     * const videoViews = await prisma.videoView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoViewWithIdOnly = await prisma.videoView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoViewFindManyArgs>(args?: SelectSubset<T, VideoViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoView.
     * @param {VideoViewCreateArgs} args - Arguments to create a VideoView.
     * @example
     * // Create one VideoView
     * const VideoView = await prisma.videoView.create({
     *   data: {
     *     // ... data to create a VideoView
     *   }
     * })
     * 
     */
    create<T extends VideoViewCreateArgs>(args: SelectSubset<T, VideoViewCreateArgs<ExtArgs>>): Prisma__VideoViewClient<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoViews.
     * @param {VideoViewCreateManyArgs} args - Arguments to create many VideoViews.
     * @example
     * // Create many VideoViews
     * const videoView = await prisma.videoView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoViewCreateManyArgs>(args?: SelectSubset<T, VideoViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoViews and returns the data saved in the database.
     * @param {VideoViewCreateManyAndReturnArgs} args - Arguments to create many VideoViews.
     * @example
     * // Create many VideoViews
     * const videoView = await prisma.videoView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoViews and only return the `id`
     * const videoViewWithIdOnly = await prisma.videoView.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoViewCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoView.
     * @param {VideoViewDeleteArgs} args - Arguments to delete one VideoView.
     * @example
     * // Delete one VideoView
     * const VideoView = await prisma.videoView.delete({
     *   where: {
     *     // ... filter to delete one VideoView
     *   }
     * })
     * 
     */
    delete<T extends VideoViewDeleteArgs>(args: SelectSubset<T, VideoViewDeleteArgs<ExtArgs>>): Prisma__VideoViewClient<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoView.
     * @param {VideoViewUpdateArgs} args - Arguments to update one VideoView.
     * @example
     * // Update one VideoView
     * const videoView = await prisma.videoView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoViewUpdateArgs>(args: SelectSubset<T, VideoViewUpdateArgs<ExtArgs>>): Prisma__VideoViewClient<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoViews.
     * @param {VideoViewDeleteManyArgs} args - Arguments to filter VideoViews to delete.
     * @example
     * // Delete a few VideoViews
     * const { count } = await prisma.videoView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoViewDeleteManyArgs>(args?: SelectSubset<T, VideoViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoViews
     * const videoView = await prisma.videoView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoViewUpdateManyArgs>(args: SelectSubset<T, VideoViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoView.
     * @param {VideoViewUpsertArgs} args - Arguments to update or create a VideoView.
     * @example
     * // Update or create a VideoView
     * const videoView = await prisma.videoView.upsert({
     *   create: {
     *     // ... data to create a VideoView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoView we want to update
     *   }
     * })
     */
    upsert<T extends VideoViewUpsertArgs>(args: SelectSubset<T, VideoViewUpsertArgs<ExtArgs>>): Prisma__VideoViewClient<$Result.GetResult<Prisma.$VideoViewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoViewCountArgs} args - Arguments to filter VideoViews to count.
     * @example
     * // Count the number of VideoViews
     * const count = await prisma.videoView.count({
     *   where: {
     *     // ... the filter for the VideoViews we want to count
     *   }
     * })
    **/
    count<T extends VideoViewCountArgs>(
      args?: Subset<T, VideoViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoViewAggregateArgs>(args: Subset<T, VideoViewAggregateArgs>): Prisma.PrismaPromise<GetVideoViewAggregateType<T>>

    /**
     * Group by VideoView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoViewGroupByArgs['orderBy'] }
        : { orderBy?: VideoViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoView model
   */
  readonly fields: VideoViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoView model
   */ 
  interface VideoViewFieldRefs {
    readonly id: FieldRef<"VideoView", 'String'>
    readonly videoId: FieldRef<"VideoView", 'String'>
    readonly viewerId: FieldRef<"VideoView", 'String'>
    readonly watchTime: FieldRef<"VideoView", 'Int'>
    readonly completed: FieldRef<"VideoView", 'Boolean'>
    readonly replays: FieldRef<"VideoView", 'Int'>
    readonly createdAt: FieldRef<"VideoView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoView findUnique
   */
  export type VideoViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    /**
     * Filter, which VideoView to fetch.
     */
    where: VideoViewWhereUniqueInput
  }

  /**
   * VideoView findUniqueOrThrow
   */
  export type VideoViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    /**
     * Filter, which VideoView to fetch.
     */
    where: VideoViewWhereUniqueInput
  }

  /**
   * VideoView findFirst
   */
  export type VideoViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    /**
     * Filter, which VideoView to fetch.
     */
    where?: VideoViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoViews to fetch.
     */
    orderBy?: VideoViewOrderByWithRelationInput | VideoViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoViews.
     */
    cursor?: VideoViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoViews.
     */
    distinct?: VideoViewScalarFieldEnum | VideoViewScalarFieldEnum[]
  }

  /**
   * VideoView findFirstOrThrow
   */
  export type VideoViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    /**
     * Filter, which VideoView to fetch.
     */
    where?: VideoViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoViews to fetch.
     */
    orderBy?: VideoViewOrderByWithRelationInput | VideoViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoViews.
     */
    cursor?: VideoViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoViews.
     */
    distinct?: VideoViewScalarFieldEnum | VideoViewScalarFieldEnum[]
  }

  /**
   * VideoView findMany
   */
  export type VideoViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    /**
     * Filter, which VideoViews to fetch.
     */
    where?: VideoViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoViews to fetch.
     */
    orderBy?: VideoViewOrderByWithRelationInput | VideoViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoViews.
     */
    cursor?: VideoViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoViews.
     */
    skip?: number
    distinct?: VideoViewScalarFieldEnum | VideoViewScalarFieldEnum[]
  }

  /**
   * VideoView create
   */
  export type VideoViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoView.
     */
    data: XOR<VideoViewCreateInput, VideoViewUncheckedCreateInput>
  }

  /**
   * VideoView createMany
   */
  export type VideoViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoViews.
     */
    data: VideoViewCreateManyInput | VideoViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoView createManyAndReturn
   */
  export type VideoViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoViews.
     */
    data: VideoViewCreateManyInput | VideoViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoView update
   */
  export type VideoViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoView.
     */
    data: XOR<VideoViewUpdateInput, VideoViewUncheckedUpdateInput>
    /**
     * Choose, which VideoView to update.
     */
    where: VideoViewWhereUniqueInput
  }

  /**
   * VideoView updateMany
   */
  export type VideoViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoViews.
     */
    data: XOR<VideoViewUpdateManyMutationInput, VideoViewUncheckedUpdateManyInput>
    /**
     * Filter which VideoViews to update
     */
    where?: VideoViewWhereInput
  }

  /**
   * VideoView upsert
   */
  export type VideoViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoView to update in case it exists.
     */
    where: VideoViewWhereUniqueInput
    /**
     * In case the VideoView found by the `where` argument doesn't exist, create a new VideoView with this data.
     */
    create: XOR<VideoViewCreateInput, VideoViewUncheckedCreateInput>
    /**
     * In case the VideoView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoViewUpdateInput, VideoViewUncheckedUpdateInput>
  }

  /**
   * VideoView delete
   */
  export type VideoViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
    /**
     * Filter which VideoView to delete.
     */
    where: VideoViewWhereUniqueInput
  }

  /**
   * VideoView deleteMany
   */
  export type VideoViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoViews to delete
     */
    where?: VideoViewWhereInput
  }

  /**
   * VideoView without action
   */
  export type VideoViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoView
     */
    select?: VideoViewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoViewInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    videoId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    videoId: string
    userId: string
    createdAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    userId?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    userId?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    videoId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */ 
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly videoId: FieldRef<"Like", 'String'>
    readonly userId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    userId: string | null
    content: string | null
    parentId: string | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    userId: string | null
    content: string | null
    parentId: string | null
    isHidden: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    videoId: number
    userId: number
    content: number
    parentId: number
    isHidden: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    content?: true
    parentId?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    content?: true
    parentId?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    content?: true
    parentId?: true
    isHidden?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    videoId: string
    userId: string
    content: string
    parentId: string | null
    isHidden: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    videoId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    isHidden?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      userId: string
      content: string
      parentId: string | null
      isHidden: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly videoId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly isHidden: FieldRef<"Comment", 'Boolean'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Save
   */

  export type AggregateSave = {
    _count: SaveCountAggregateOutputType | null
    _min: SaveMinAggregateOutputType | null
    _max: SaveMaxAggregateOutputType | null
  }

  export type SaveMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    userId: string | null
    listId: string | null
    createdAt: Date | null
  }

  export type SaveMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    userId: string | null
    listId: string | null
    createdAt: Date | null
  }

  export type SaveCountAggregateOutputType = {
    id: number
    videoId: number
    userId: number
    listId: number
    createdAt: number
    _all: number
  }


  export type SaveMinAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    listId?: true
    createdAt?: true
  }

  export type SaveMaxAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    listId?: true
    createdAt?: true
  }

  export type SaveCountAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    listId?: true
    createdAt?: true
    _all?: true
  }

  export type SaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Save to aggregate.
     */
    where?: SaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saves to fetch.
     */
    orderBy?: SaveOrderByWithRelationInput | SaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Saves
    **/
    _count?: true | SaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaveMaxAggregateInputType
  }

  export type GetSaveAggregateType<T extends SaveAggregateArgs> = {
        [P in keyof T & keyof AggregateSave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSave[P]>
      : GetScalarType<T[P], AggregateSave[P]>
  }




  export type SaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaveWhereInput
    orderBy?: SaveOrderByWithAggregationInput | SaveOrderByWithAggregationInput[]
    by: SaveScalarFieldEnum[] | SaveScalarFieldEnum
    having?: SaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaveCountAggregateInputType | true
    _min?: SaveMinAggregateInputType
    _max?: SaveMaxAggregateInputType
  }

  export type SaveGroupByOutputType = {
    id: string
    videoId: string
    userId: string
    listId: string | null
    createdAt: Date
    _count: SaveCountAggregateOutputType | null
    _min: SaveMinAggregateOutputType | null
    _max: SaveMaxAggregateOutputType | null
  }

  type GetSaveGroupByPayload<T extends SaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaveGroupByOutputType[P]>
            : GetScalarType<T[P], SaveGroupByOutputType[P]>
        }
      >
    >


  export type SaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    userId?: boolean
    listId?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    list?: boolean | Save$listArgs<ExtArgs>
  }, ExtArgs["result"]["save"]>

  export type SaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    userId?: boolean
    listId?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    list?: boolean | Save$listArgs<ExtArgs>
  }, ExtArgs["result"]["save"]>

  export type SaveSelectScalar = {
    id?: boolean
    videoId?: boolean
    userId?: boolean
    listId?: boolean
    createdAt?: boolean
  }

  export type SaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    list?: boolean | Save$listArgs<ExtArgs>
  }
  export type SaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    list?: boolean | Save$listArgs<ExtArgs>
  }

  export type $SavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Save"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      list: Prisma.$SaveListPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      userId: string
      listId: string | null
      createdAt: Date
    }, ExtArgs["result"]["save"]>
    composites: {}
  }

  type SaveGetPayload<S extends boolean | null | undefined | SaveDefaultArgs> = $Result.GetResult<Prisma.$SavePayload, S>

  type SaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaveCountAggregateInputType | true
    }

  export interface SaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Save'], meta: { name: 'Save' } }
    /**
     * Find zero or one Save that matches the filter.
     * @param {SaveFindUniqueArgs} args - Arguments to find a Save
     * @example
     * // Get one Save
     * const save = await prisma.save.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaveFindUniqueArgs>(args: SelectSubset<T, SaveFindUniqueArgs<ExtArgs>>): Prisma__SaveClient<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Save that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaveFindUniqueOrThrowArgs} args - Arguments to find a Save
     * @example
     * // Get one Save
     * const save = await prisma.save.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaveFindUniqueOrThrowArgs>(args: SelectSubset<T, SaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaveClient<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Save that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveFindFirstArgs} args - Arguments to find a Save
     * @example
     * // Get one Save
     * const save = await prisma.save.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaveFindFirstArgs>(args?: SelectSubset<T, SaveFindFirstArgs<ExtArgs>>): Prisma__SaveClient<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Save that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveFindFirstOrThrowArgs} args - Arguments to find a Save
     * @example
     * // Get one Save
     * const save = await prisma.save.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaveFindFirstOrThrowArgs>(args?: SelectSubset<T, SaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaveClient<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Saves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saves
     * const saves = await prisma.save.findMany()
     * 
     * // Get first 10 Saves
     * const saves = await prisma.save.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saveWithIdOnly = await prisma.save.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaveFindManyArgs>(args?: SelectSubset<T, SaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Save.
     * @param {SaveCreateArgs} args - Arguments to create a Save.
     * @example
     * // Create one Save
     * const Save = await prisma.save.create({
     *   data: {
     *     // ... data to create a Save
     *   }
     * })
     * 
     */
    create<T extends SaveCreateArgs>(args: SelectSubset<T, SaveCreateArgs<ExtArgs>>): Prisma__SaveClient<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Saves.
     * @param {SaveCreateManyArgs} args - Arguments to create many Saves.
     * @example
     * // Create many Saves
     * const save = await prisma.save.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaveCreateManyArgs>(args?: SelectSubset<T, SaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Saves and returns the data saved in the database.
     * @param {SaveCreateManyAndReturnArgs} args - Arguments to create many Saves.
     * @example
     * // Create many Saves
     * const save = await prisma.save.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Saves and only return the `id`
     * const saveWithIdOnly = await prisma.save.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaveCreateManyAndReturnArgs>(args?: SelectSubset<T, SaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Save.
     * @param {SaveDeleteArgs} args - Arguments to delete one Save.
     * @example
     * // Delete one Save
     * const Save = await prisma.save.delete({
     *   where: {
     *     // ... filter to delete one Save
     *   }
     * })
     * 
     */
    delete<T extends SaveDeleteArgs>(args: SelectSubset<T, SaveDeleteArgs<ExtArgs>>): Prisma__SaveClient<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Save.
     * @param {SaveUpdateArgs} args - Arguments to update one Save.
     * @example
     * // Update one Save
     * const save = await prisma.save.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaveUpdateArgs>(args: SelectSubset<T, SaveUpdateArgs<ExtArgs>>): Prisma__SaveClient<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Saves.
     * @param {SaveDeleteManyArgs} args - Arguments to filter Saves to delete.
     * @example
     * // Delete a few Saves
     * const { count } = await prisma.save.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaveDeleteManyArgs>(args?: SelectSubset<T, SaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saves
     * const save = await prisma.save.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaveUpdateManyArgs>(args: SelectSubset<T, SaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Save.
     * @param {SaveUpsertArgs} args - Arguments to update or create a Save.
     * @example
     * // Update or create a Save
     * const save = await prisma.save.upsert({
     *   create: {
     *     // ... data to create a Save
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Save we want to update
     *   }
     * })
     */
    upsert<T extends SaveUpsertArgs>(args: SelectSubset<T, SaveUpsertArgs<ExtArgs>>): Prisma__SaveClient<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Saves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveCountArgs} args - Arguments to filter Saves to count.
     * @example
     * // Count the number of Saves
     * const count = await prisma.save.count({
     *   where: {
     *     // ... the filter for the Saves we want to count
     *   }
     * })
    **/
    count<T extends SaveCountArgs>(
      args?: Subset<T, SaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Save.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaveAggregateArgs>(args: Subset<T, SaveAggregateArgs>): Prisma.PrismaPromise<GetSaveAggregateType<T>>

    /**
     * Group by Save.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaveGroupByArgs['orderBy'] }
        : { orderBy?: SaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Save model
   */
  readonly fields: SaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Save.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    list<T extends Save$listArgs<ExtArgs> = {}>(args?: Subset<T, Save$listArgs<ExtArgs>>): Prisma__SaveListClient<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Save model
   */ 
  interface SaveFieldRefs {
    readonly id: FieldRef<"Save", 'String'>
    readonly videoId: FieldRef<"Save", 'String'>
    readonly userId: FieldRef<"Save", 'String'>
    readonly listId: FieldRef<"Save", 'String'>
    readonly createdAt: FieldRef<"Save", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Save findUnique
   */
  export type SaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    /**
     * Filter, which Save to fetch.
     */
    where: SaveWhereUniqueInput
  }

  /**
   * Save findUniqueOrThrow
   */
  export type SaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    /**
     * Filter, which Save to fetch.
     */
    where: SaveWhereUniqueInput
  }

  /**
   * Save findFirst
   */
  export type SaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    /**
     * Filter, which Save to fetch.
     */
    where?: SaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saves to fetch.
     */
    orderBy?: SaveOrderByWithRelationInput | SaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Saves.
     */
    cursor?: SaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Saves.
     */
    distinct?: SaveScalarFieldEnum | SaveScalarFieldEnum[]
  }

  /**
   * Save findFirstOrThrow
   */
  export type SaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    /**
     * Filter, which Save to fetch.
     */
    where?: SaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saves to fetch.
     */
    orderBy?: SaveOrderByWithRelationInput | SaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Saves.
     */
    cursor?: SaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Saves.
     */
    distinct?: SaveScalarFieldEnum | SaveScalarFieldEnum[]
  }

  /**
   * Save findMany
   */
  export type SaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    /**
     * Filter, which Saves to fetch.
     */
    where?: SaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Saves to fetch.
     */
    orderBy?: SaveOrderByWithRelationInput | SaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Saves.
     */
    cursor?: SaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Saves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Saves.
     */
    skip?: number
    distinct?: SaveScalarFieldEnum | SaveScalarFieldEnum[]
  }

  /**
   * Save create
   */
  export type SaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Save.
     */
    data: XOR<SaveCreateInput, SaveUncheckedCreateInput>
  }

  /**
   * Save createMany
   */
  export type SaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Saves.
     */
    data: SaveCreateManyInput | SaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Save createManyAndReturn
   */
  export type SaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Saves.
     */
    data: SaveCreateManyInput | SaveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Save update
   */
  export type SaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Save.
     */
    data: XOR<SaveUpdateInput, SaveUncheckedUpdateInput>
    /**
     * Choose, which Save to update.
     */
    where: SaveWhereUniqueInput
  }

  /**
   * Save updateMany
   */
  export type SaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Saves.
     */
    data: XOR<SaveUpdateManyMutationInput, SaveUncheckedUpdateManyInput>
    /**
     * Filter which Saves to update
     */
    where?: SaveWhereInput
  }

  /**
   * Save upsert
   */
  export type SaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Save to update in case it exists.
     */
    where: SaveWhereUniqueInput
    /**
     * In case the Save found by the `where` argument doesn't exist, create a new Save with this data.
     */
    create: XOR<SaveCreateInput, SaveUncheckedCreateInput>
    /**
     * In case the Save was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaveUpdateInput, SaveUncheckedUpdateInput>
  }

  /**
   * Save delete
   */
  export type SaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    /**
     * Filter which Save to delete.
     */
    where: SaveWhereUniqueInput
  }

  /**
   * Save deleteMany
   */
  export type SaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Saves to delete
     */
    where?: SaveWhereInput
  }

  /**
   * Save.list
   */
  export type Save$listArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    where?: SaveListWhereInput
  }

  /**
   * Save without action
   */
  export type SaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
  }


  /**
   * Model SaveList
   */

  export type AggregateSaveList = {
    _count: SaveListCountAggregateOutputType | null
    _min: SaveListMinAggregateOutputType | null
    _max: SaveListMaxAggregateOutputType | null
  }

  export type SaveListMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type SaveListMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type SaveListCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    isDefault: number
    createdAt: number
    _all: number
  }


  export type SaveListMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    isDefault?: true
    createdAt?: true
  }

  export type SaveListMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    isDefault?: true
    createdAt?: true
  }

  export type SaveListCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    isDefault?: true
    createdAt?: true
    _all?: true
  }

  export type SaveListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaveList to aggregate.
     */
    where?: SaveListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaveLists to fetch.
     */
    orderBy?: SaveListOrderByWithRelationInput | SaveListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaveListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaveLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaveLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaveLists
    **/
    _count?: true | SaveListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaveListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaveListMaxAggregateInputType
  }

  export type GetSaveListAggregateType<T extends SaveListAggregateArgs> = {
        [P in keyof T & keyof AggregateSaveList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaveList[P]>
      : GetScalarType<T[P], AggregateSaveList[P]>
  }




  export type SaveListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaveListWhereInput
    orderBy?: SaveListOrderByWithAggregationInput | SaveListOrderByWithAggregationInput[]
    by: SaveListScalarFieldEnum[] | SaveListScalarFieldEnum
    having?: SaveListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaveListCountAggregateInputType | true
    _min?: SaveListMinAggregateInputType
    _max?: SaveListMaxAggregateInputType
  }

  export type SaveListGroupByOutputType = {
    id: string
    userId: string
    name: string
    isDefault: boolean
    createdAt: Date
    _count: SaveListCountAggregateOutputType | null
    _min: SaveListMinAggregateOutputType | null
    _max: SaveListMaxAggregateOutputType | null
  }

  type GetSaveListGroupByPayload<T extends SaveListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaveListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaveListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaveListGroupByOutputType[P]>
            : GetScalarType<T[P], SaveListGroupByOutputType[P]>
        }
      >
    >


  export type SaveListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    isDefault?: boolean
    createdAt?: boolean
    saves?: boolean | SaveList$savesArgs<ExtArgs>
    _count?: boolean | SaveListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saveList"]>

  export type SaveListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    isDefault?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["saveList"]>

  export type SaveListSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    isDefault?: boolean
    createdAt?: boolean
  }

  export type SaveListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saves?: boolean | SaveList$savesArgs<ExtArgs>
    _count?: boolean | SaveListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaveListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SaveListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaveList"
    objects: {
      saves: Prisma.$SavePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      isDefault: boolean
      createdAt: Date
    }, ExtArgs["result"]["saveList"]>
    composites: {}
  }

  type SaveListGetPayload<S extends boolean | null | undefined | SaveListDefaultArgs> = $Result.GetResult<Prisma.$SaveListPayload, S>

  type SaveListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaveListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaveListCountAggregateInputType | true
    }

  export interface SaveListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaveList'], meta: { name: 'SaveList' } }
    /**
     * Find zero or one SaveList that matches the filter.
     * @param {SaveListFindUniqueArgs} args - Arguments to find a SaveList
     * @example
     * // Get one SaveList
     * const saveList = await prisma.saveList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaveListFindUniqueArgs>(args: SelectSubset<T, SaveListFindUniqueArgs<ExtArgs>>): Prisma__SaveListClient<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaveList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaveListFindUniqueOrThrowArgs} args - Arguments to find a SaveList
     * @example
     * // Get one SaveList
     * const saveList = await prisma.saveList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaveListFindUniqueOrThrowArgs>(args: SelectSubset<T, SaveListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaveListClient<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaveList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveListFindFirstArgs} args - Arguments to find a SaveList
     * @example
     * // Get one SaveList
     * const saveList = await prisma.saveList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaveListFindFirstArgs>(args?: SelectSubset<T, SaveListFindFirstArgs<ExtArgs>>): Prisma__SaveListClient<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaveList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveListFindFirstOrThrowArgs} args - Arguments to find a SaveList
     * @example
     * // Get one SaveList
     * const saveList = await prisma.saveList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaveListFindFirstOrThrowArgs>(args?: SelectSubset<T, SaveListFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaveListClient<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaveLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaveLists
     * const saveLists = await prisma.saveList.findMany()
     * 
     * // Get first 10 SaveLists
     * const saveLists = await prisma.saveList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saveListWithIdOnly = await prisma.saveList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaveListFindManyArgs>(args?: SelectSubset<T, SaveListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaveList.
     * @param {SaveListCreateArgs} args - Arguments to create a SaveList.
     * @example
     * // Create one SaveList
     * const SaveList = await prisma.saveList.create({
     *   data: {
     *     // ... data to create a SaveList
     *   }
     * })
     * 
     */
    create<T extends SaveListCreateArgs>(args: SelectSubset<T, SaveListCreateArgs<ExtArgs>>): Prisma__SaveListClient<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaveLists.
     * @param {SaveListCreateManyArgs} args - Arguments to create many SaveLists.
     * @example
     * // Create many SaveLists
     * const saveList = await prisma.saveList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaveListCreateManyArgs>(args?: SelectSubset<T, SaveListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaveLists and returns the data saved in the database.
     * @param {SaveListCreateManyAndReturnArgs} args - Arguments to create many SaveLists.
     * @example
     * // Create many SaveLists
     * const saveList = await prisma.saveList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaveLists and only return the `id`
     * const saveListWithIdOnly = await prisma.saveList.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaveListCreateManyAndReturnArgs>(args?: SelectSubset<T, SaveListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaveList.
     * @param {SaveListDeleteArgs} args - Arguments to delete one SaveList.
     * @example
     * // Delete one SaveList
     * const SaveList = await prisma.saveList.delete({
     *   where: {
     *     // ... filter to delete one SaveList
     *   }
     * })
     * 
     */
    delete<T extends SaveListDeleteArgs>(args: SelectSubset<T, SaveListDeleteArgs<ExtArgs>>): Prisma__SaveListClient<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaveList.
     * @param {SaveListUpdateArgs} args - Arguments to update one SaveList.
     * @example
     * // Update one SaveList
     * const saveList = await prisma.saveList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaveListUpdateArgs>(args: SelectSubset<T, SaveListUpdateArgs<ExtArgs>>): Prisma__SaveListClient<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaveLists.
     * @param {SaveListDeleteManyArgs} args - Arguments to filter SaveLists to delete.
     * @example
     * // Delete a few SaveLists
     * const { count } = await prisma.saveList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaveListDeleteManyArgs>(args?: SelectSubset<T, SaveListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaveLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaveLists
     * const saveList = await prisma.saveList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaveListUpdateManyArgs>(args: SelectSubset<T, SaveListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaveList.
     * @param {SaveListUpsertArgs} args - Arguments to update or create a SaveList.
     * @example
     * // Update or create a SaveList
     * const saveList = await prisma.saveList.upsert({
     *   create: {
     *     // ... data to create a SaveList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaveList we want to update
     *   }
     * })
     */
    upsert<T extends SaveListUpsertArgs>(args: SelectSubset<T, SaveListUpsertArgs<ExtArgs>>): Prisma__SaveListClient<$Result.GetResult<Prisma.$SaveListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaveLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveListCountArgs} args - Arguments to filter SaveLists to count.
     * @example
     * // Count the number of SaveLists
     * const count = await prisma.saveList.count({
     *   where: {
     *     // ... the filter for the SaveLists we want to count
     *   }
     * })
    **/
    count<T extends SaveListCountArgs>(
      args?: Subset<T, SaveListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaveListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaveList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaveListAggregateArgs>(args: Subset<T, SaveListAggregateArgs>): Prisma.PrismaPromise<GetSaveListAggregateType<T>>

    /**
     * Group by SaveList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaveListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaveListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaveListGroupByArgs['orderBy'] }
        : { orderBy?: SaveListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaveListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaveListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaveList model
   */
  readonly fields: SaveListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaveList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaveListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saves<T extends SaveList$savesArgs<ExtArgs> = {}>(args?: Subset<T, SaveList$savesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaveList model
   */ 
  interface SaveListFieldRefs {
    readonly id: FieldRef<"SaveList", 'String'>
    readonly userId: FieldRef<"SaveList", 'String'>
    readonly name: FieldRef<"SaveList", 'String'>
    readonly isDefault: FieldRef<"SaveList", 'Boolean'>
    readonly createdAt: FieldRef<"SaveList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaveList findUnique
   */
  export type SaveListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    /**
     * Filter, which SaveList to fetch.
     */
    where: SaveListWhereUniqueInput
  }

  /**
   * SaveList findUniqueOrThrow
   */
  export type SaveListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    /**
     * Filter, which SaveList to fetch.
     */
    where: SaveListWhereUniqueInput
  }

  /**
   * SaveList findFirst
   */
  export type SaveListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    /**
     * Filter, which SaveList to fetch.
     */
    where?: SaveListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaveLists to fetch.
     */
    orderBy?: SaveListOrderByWithRelationInput | SaveListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaveLists.
     */
    cursor?: SaveListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaveLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaveLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaveLists.
     */
    distinct?: SaveListScalarFieldEnum | SaveListScalarFieldEnum[]
  }

  /**
   * SaveList findFirstOrThrow
   */
  export type SaveListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    /**
     * Filter, which SaveList to fetch.
     */
    where?: SaveListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaveLists to fetch.
     */
    orderBy?: SaveListOrderByWithRelationInput | SaveListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaveLists.
     */
    cursor?: SaveListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaveLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaveLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaveLists.
     */
    distinct?: SaveListScalarFieldEnum | SaveListScalarFieldEnum[]
  }

  /**
   * SaveList findMany
   */
  export type SaveListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    /**
     * Filter, which SaveLists to fetch.
     */
    where?: SaveListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaveLists to fetch.
     */
    orderBy?: SaveListOrderByWithRelationInput | SaveListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaveLists.
     */
    cursor?: SaveListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaveLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaveLists.
     */
    skip?: number
    distinct?: SaveListScalarFieldEnum | SaveListScalarFieldEnum[]
  }

  /**
   * SaveList create
   */
  export type SaveListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    /**
     * The data needed to create a SaveList.
     */
    data: XOR<SaveListCreateInput, SaveListUncheckedCreateInput>
  }

  /**
   * SaveList createMany
   */
  export type SaveListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaveLists.
     */
    data: SaveListCreateManyInput | SaveListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaveList createManyAndReturn
   */
  export type SaveListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaveLists.
     */
    data: SaveListCreateManyInput | SaveListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaveList update
   */
  export type SaveListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    /**
     * The data needed to update a SaveList.
     */
    data: XOR<SaveListUpdateInput, SaveListUncheckedUpdateInput>
    /**
     * Choose, which SaveList to update.
     */
    where: SaveListWhereUniqueInput
  }

  /**
   * SaveList updateMany
   */
  export type SaveListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaveLists.
     */
    data: XOR<SaveListUpdateManyMutationInput, SaveListUncheckedUpdateManyInput>
    /**
     * Filter which SaveLists to update
     */
    where?: SaveListWhereInput
  }

  /**
   * SaveList upsert
   */
  export type SaveListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    /**
     * The filter to search for the SaveList to update in case it exists.
     */
    where: SaveListWhereUniqueInput
    /**
     * In case the SaveList found by the `where` argument doesn't exist, create a new SaveList with this data.
     */
    create: XOR<SaveListCreateInput, SaveListUncheckedCreateInput>
    /**
     * In case the SaveList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaveListUpdateInput, SaveListUncheckedUpdateInput>
  }

  /**
   * SaveList delete
   */
  export type SaveListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
    /**
     * Filter which SaveList to delete.
     */
    where: SaveListWhereUniqueInput
  }

  /**
   * SaveList deleteMany
   */
  export type SaveListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaveLists to delete
     */
    where?: SaveListWhereInput
  }

  /**
   * SaveList.saves
   */
  export type SaveList$savesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Save
     */
    select?: SaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveInclude<ExtArgs> | null
    where?: SaveWhereInput
    orderBy?: SaveOrderByWithRelationInput | SaveOrderByWithRelationInput[]
    cursor?: SaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaveScalarFieldEnum | SaveScalarFieldEnum[]
  }

  /**
   * SaveList without action
   */
  export type SaveListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaveList
     */
    select?: SaveListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaveListInclude<ExtArgs> | null
  }


  /**
   * Model Share
   */

  export type AggregateShare = {
    _count: ShareCountAggregateOutputType | null
    _min: ShareMinAggregateOutputType | null
    _max: ShareMaxAggregateOutputType | null
  }

  export type ShareMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    userId: string | null
    platform: string | null
    createdAt: Date | null
  }

  export type ShareMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    userId: string | null
    platform: string | null
    createdAt: Date | null
  }

  export type ShareCountAggregateOutputType = {
    id: number
    videoId: number
    userId: number
    platform: number
    createdAt: number
    _all: number
  }


  export type ShareMinAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    platform?: true
    createdAt?: true
  }

  export type ShareMaxAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    platform?: true
    createdAt?: true
  }

  export type ShareCountAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    platform?: true
    createdAt?: true
    _all?: true
  }

  export type ShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Share to aggregate.
     */
    where?: ShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shares to fetch.
     */
    orderBy?: ShareOrderByWithRelationInput | ShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shares
    **/
    _count?: true | ShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareMaxAggregateInputType
  }

  export type GetShareAggregateType<T extends ShareAggregateArgs> = {
        [P in keyof T & keyof AggregateShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShare[P]>
      : GetScalarType<T[P], AggregateShare[P]>
  }




  export type ShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareWhereInput
    orderBy?: ShareOrderByWithAggregationInput | ShareOrderByWithAggregationInput[]
    by: ShareScalarFieldEnum[] | ShareScalarFieldEnum
    having?: ShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareCountAggregateInputType | true
    _min?: ShareMinAggregateInputType
    _max?: ShareMaxAggregateInputType
  }

  export type ShareGroupByOutputType = {
    id: string
    videoId: string
    userId: string
    platform: string
    createdAt: Date
    _count: ShareCountAggregateOutputType | null
    _min: ShareMinAggregateOutputType | null
    _max: ShareMaxAggregateOutputType | null
  }

  type GetShareGroupByPayload<T extends ShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareGroupByOutputType[P]>
            : GetScalarType<T[P], ShareGroupByOutputType[P]>
        }
      >
    >


  export type ShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    userId?: boolean
    platform?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["share"]>

  export type ShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    userId?: boolean
    platform?: boolean
    createdAt?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["share"]>

  export type ShareSelectScalar = {
    id?: boolean
    videoId?: boolean
    userId?: boolean
    platform?: boolean
    createdAt?: boolean
  }

  export type ShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Share"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      userId: string
      platform: string
      createdAt: Date
    }, ExtArgs["result"]["share"]>
    composites: {}
  }

  type ShareGetPayload<S extends boolean | null | undefined | ShareDefaultArgs> = $Result.GetResult<Prisma.$SharePayload, S>

  type ShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShareCountAggregateInputType | true
    }

  export interface ShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Share'], meta: { name: 'Share' } }
    /**
     * Find zero or one Share that matches the filter.
     * @param {ShareFindUniqueArgs} args - Arguments to find a Share
     * @example
     * // Get one Share
     * const share = await prisma.share.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareFindUniqueArgs>(args: SelectSubset<T, ShareFindUniqueArgs<ExtArgs>>): Prisma__ShareClient<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Share that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShareFindUniqueOrThrowArgs} args - Arguments to find a Share
     * @example
     * // Get one Share
     * const share = await prisma.share.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareClient<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Share that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareFindFirstArgs} args - Arguments to find a Share
     * @example
     * // Get one Share
     * const share = await prisma.share.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareFindFirstArgs>(args?: SelectSubset<T, ShareFindFirstArgs<ExtArgs>>): Prisma__ShareClient<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Share that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareFindFirstOrThrowArgs} args - Arguments to find a Share
     * @example
     * // Get one Share
     * const share = await prisma.share.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareClient<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shares
     * const shares = await prisma.share.findMany()
     * 
     * // Get first 10 Shares
     * const shares = await prisma.share.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shareWithIdOnly = await prisma.share.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShareFindManyArgs>(args?: SelectSubset<T, ShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Share.
     * @param {ShareCreateArgs} args - Arguments to create a Share.
     * @example
     * // Create one Share
     * const Share = await prisma.share.create({
     *   data: {
     *     // ... data to create a Share
     *   }
     * })
     * 
     */
    create<T extends ShareCreateArgs>(args: SelectSubset<T, ShareCreateArgs<ExtArgs>>): Prisma__ShareClient<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shares.
     * @param {ShareCreateManyArgs} args - Arguments to create many Shares.
     * @example
     * // Create many Shares
     * const share = await prisma.share.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareCreateManyArgs>(args?: SelectSubset<T, ShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shares and returns the data saved in the database.
     * @param {ShareCreateManyAndReturnArgs} args - Arguments to create many Shares.
     * @example
     * // Create many Shares
     * const share = await prisma.share.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shares and only return the `id`
     * const shareWithIdOnly = await prisma.share.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShareCreateManyAndReturnArgs>(args?: SelectSubset<T, ShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Share.
     * @param {ShareDeleteArgs} args - Arguments to delete one Share.
     * @example
     * // Delete one Share
     * const Share = await prisma.share.delete({
     *   where: {
     *     // ... filter to delete one Share
     *   }
     * })
     * 
     */
    delete<T extends ShareDeleteArgs>(args: SelectSubset<T, ShareDeleteArgs<ExtArgs>>): Prisma__ShareClient<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Share.
     * @param {ShareUpdateArgs} args - Arguments to update one Share.
     * @example
     * // Update one Share
     * const share = await prisma.share.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareUpdateArgs>(args: SelectSubset<T, ShareUpdateArgs<ExtArgs>>): Prisma__ShareClient<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shares.
     * @param {ShareDeleteManyArgs} args - Arguments to filter Shares to delete.
     * @example
     * // Delete a few Shares
     * const { count } = await prisma.share.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareDeleteManyArgs>(args?: SelectSubset<T, ShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shares
     * const share = await prisma.share.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareUpdateManyArgs>(args: SelectSubset<T, ShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Share.
     * @param {ShareUpsertArgs} args - Arguments to update or create a Share.
     * @example
     * // Update or create a Share
     * const share = await prisma.share.upsert({
     *   create: {
     *     // ... data to create a Share
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Share we want to update
     *   }
     * })
     */
    upsert<T extends ShareUpsertArgs>(args: SelectSubset<T, ShareUpsertArgs<ExtArgs>>): Prisma__ShareClient<$Result.GetResult<Prisma.$SharePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareCountArgs} args - Arguments to filter Shares to count.
     * @example
     * // Count the number of Shares
     * const count = await prisma.share.count({
     *   where: {
     *     // ... the filter for the Shares we want to count
     *   }
     * })
    **/
    count<T extends ShareCountArgs>(
      args?: Subset<T, ShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Share.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareAggregateArgs>(args: Subset<T, ShareAggregateArgs>): Prisma.PrismaPromise<GetShareAggregateType<T>>

    /**
     * Group by Share.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareGroupByArgs['orderBy'] }
        : { orderBy?: ShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Share model
   */
  readonly fields: ShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Share.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Share model
   */ 
  interface ShareFieldRefs {
    readonly id: FieldRef<"Share", 'String'>
    readonly videoId: FieldRef<"Share", 'String'>
    readonly userId: FieldRef<"Share", 'String'>
    readonly platform: FieldRef<"Share", 'String'>
    readonly createdAt: FieldRef<"Share", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Share findUnique
   */
  export type ShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    /**
     * Filter, which Share to fetch.
     */
    where: ShareWhereUniqueInput
  }

  /**
   * Share findUniqueOrThrow
   */
  export type ShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    /**
     * Filter, which Share to fetch.
     */
    where: ShareWhereUniqueInput
  }

  /**
   * Share findFirst
   */
  export type ShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    /**
     * Filter, which Share to fetch.
     */
    where?: ShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shares to fetch.
     */
    orderBy?: ShareOrderByWithRelationInput | ShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shares.
     */
    cursor?: ShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shares.
     */
    distinct?: ShareScalarFieldEnum | ShareScalarFieldEnum[]
  }

  /**
   * Share findFirstOrThrow
   */
  export type ShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    /**
     * Filter, which Share to fetch.
     */
    where?: ShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shares to fetch.
     */
    orderBy?: ShareOrderByWithRelationInput | ShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shares.
     */
    cursor?: ShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shares.
     */
    distinct?: ShareScalarFieldEnum | ShareScalarFieldEnum[]
  }

  /**
   * Share findMany
   */
  export type ShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    /**
     * Filter, which Shares to fetch.
     */
    where?: ShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shares to fetch.
     */
    orderBy?: ShareOrderByWithRelationInput | ShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shares.
     */
    cursor?: ShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shares.
     */
    skip?: number
    distinct?: ShareScalarFieldEnum | ShareScalarFieldEnum[]
  }

  /**
   * Share create
   */
  export type ShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    /**
     * The data needed to create a Share.
     */
    data: XOR<ShareCreateInput, ShareUncheckedCreateInput>
  }

  /**
   * Share createMany
   */
  export type ShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shares.
     */
    data: ShareCreateManyInput | ShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Share createManyAndReturn
   */
  export type ShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shares.
     */
    data: ShareCreateManyInput | ShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Share update
   */
  export type ShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    /**
     * The data needed to update a Share.
     */
    data: XOR<ShareUpdateInput, ShareUncheckedUpdateInput>
    /**
     * Choose, which Share to update.
     */
    where: ShareWhereUniqueInput
  }

  /**
   * Share updateMany
   */
  export type ShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shares.
     */
    data: XOR<ShareUpdateManyMutationInput, ShareUncheckedUpdateManyInput>
    /**
     * Filter which Shares to update
     */
    where?: ShareWhereInput
  }

  /**
   * Share upsert
   */
  export type ShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    /**
     * The filter to search for the Share to update in case it exists.
     */
    where: ShareWhereUniqueInput
    /**
     * In case the Share found by the `where` argument doesn't exist, create a new Share with this data.
     */
    create: XOR<ShareCreateInput, ShareUncheckedCreateInput>
    /**
     * In case the Share was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareUpdateInput, ShareUncheckedUpdateInput>
  }

  /**
   * Share delete
   */
  export type ShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
    /**
     * Filter which Share to delete.
     */
    where: ShareWhereUniqueInput
  }

  /**
   * Share deleteMany
   */
  export type ShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shares to delete
     */
    where?: ShareWhereInput
  }

  /**
   * Share without action
   */
  export type ShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Share
     */
    select?: ShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */ 
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model ExpressInterest
   */

  export type AggregateExpressInterest = {
    _count: ExpressInterestCountAggregateOutputType | null
    _min: ExpressInterestMinAggregateOutputType | null
    _max: ExpressInterestMaxAggregateOutputType | null
  }

  export type ExpressInterestMinAggregateOutputType = {
    id: string | null
    investorId: string | null
    founderId: string | null
    videoId: string | null
    status: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpressInterestMaxAggregateOutputType = {
    id: string | null
    investorId: string | null
    founderId: string | null
    videoId: string | null
    status: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpressInterestCountAggregateOutputType = {
    id: number
    investorId: number
    founderId: number
    videoId: number
    status: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpressInterestMinAggregateInputType = {
    id?: true
    investorId?: true
    founderId?: true
    videoId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpressInterestMaxAggregateInputType = {
    id?: true
    investorId?: true
    founderId?: true
    videoId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpressInterestCountAggregateInputType = {
    id?: true
    investorId?: true
    founderId?: true
    videoId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpressInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpressInterest to aggregate.
     */
    where?: ExpressInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpressInterests to fetch.
     */
    orderBy?: ExpressInterestOrderByWithRelationInput | ExpressInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpressInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpressInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpressInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpressInterests
    **/
    _count?: true | ExpressInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpressInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpressInterestMaxAggregateInputType
  }

  export type GetExpressInterestAggregateType<T extends ExpressInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateExpressInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpressInterest[P]>
      : GetScalarType<T[P], AggregateExpressInterest[P]>
  }




  export type ExpressInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpressInterestWhereInput
    orderBy?: ExpressInterestOrderByWithAggregationInput | ExpressInterestOrderByWithAggregationInput[]
    by: ExpressInterestScalarFieldEnum[] | ExpressInterestScalarFieldEnum
    having?: ExpressInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpressInterestCountAggregateInputType | true
    _min?: ExpressInterestMinAggregateInputType
    _max?: ExpressInterestMaxAggregateInputType
  }

  export type ExpressInterestGroupByOutputType = {
    id: string
    investorId: string
    founderId: string
    videoId: string
    status: string
    message: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExpressInterestCountAggregateOutputType | null
    _min: ExpressInterestMinAggregateOutputType | null
    _max: ExpressInterestMaxAggregateOutputType | null
  }

  type GetExpressInterestGroupByPayload<T extends ExpressInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpressInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpressInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpressInterestGroupByOutputType[P]>
            : GetScalarType<T[P], ExpressInterestGroupByOutputType[P]>
        }
      >
    >


  export type ExpressInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    founderId?: boolean
    videoId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    investor?: boolean | UserDefaultArgs<ExtArgs>
    founder?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expressInterest"]>

  export type ExpressInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    founderId?: boolean
    videoId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    investor?: boolean | UserDefaultArgs<ExtArgs>
    founder?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expressInterest"]>

  export type ExpressInterestSelectScalar = {
    id?: boolean
    investorId?: boolean
    founderId?: boolean
    videoId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpressInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | UserDefaultArgs<ExtArgs>
    founder?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }
  export type ExpressInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | UserDefaultArgs<ExtArgs>
    founder?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }

  export type $ExpressInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpressInterest"
    objects: {
      investor: Prisma.$UserPayload<ExtArgs>
      founder: Prisma.$UserPayload<ExtArgs>
      video: Prisma.$VideoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      investorId: string
      founderId: string
      videoId: string
      status: string
      message: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expressInterest"]>
    composites: {}
  }

  type ExpressInterestGetPayload<S extends boolean | null | undefined | ExpressInterestDefaultArgs> = $Result.GetResult<Prisma.$ExpressInterestPayload, S>

  type ExpressInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpressInterestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpressInterestCountAggregateInputType | true
    }

  export interface ExpressInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpressInterest'], meta: { name: 'ExpressInterest' } }
    /**
     * Find zero or one ExpressInterest that matches the filter.
     * @param {ExpressInterestFindUniqueArgs} args - Arguments to find a ExpressInterest
     * @example
     * // Get one ExpressInterest
     * const expressInterest = await prisma.expressInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpressInterestFindUniqueArgs>(args: SelectSubset<T, ExpressInterestFindUniqueArgs<ExtArgs>>): Prisma__ExpressInterestClient<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExpressInterest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpressInterestFindUniqueOrThrowArgs} args - Arguments to find a ExpressInterest
     * @example
     * // Get one ExpressInterest
     * const expressInterest = await prisma.expressInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpressInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpressInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpressInterestClient<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExpressInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpressInterestFindFirstArgs} args - Arguments to find a ExpressInterest
     * @example
     * // Get one ExpressInterest
     * const expressInterest = await prisma.expressInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpressInterestFindFirstArgs>(args?: SelectSubset<T, ExpressInterestFindFirstArgs<ExtArgs>>): Prisma__ExpressInterestClient<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExpressInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpressInterestFindFirstOrThrowArgs} args - Arguments to find a ExpressInterest
     * @example
     * // Get one ExpressInterest
     * const expressInterest = await prisma.expressInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpressInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpressInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpressInterestClient<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExpressInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpressInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpressInterests
     * const expressInterests = await prisma.expressInterest.findMany()
     * 
     * // Get first 10 ExpressInterests
     * const expressInterests = await prisma.expressInterest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expressInterestWithIdOnly = await prisma.expressInterest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpressInterestFindManyArgs>(args?: SelectSubset<T, ExpressInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExpressInterest.
     * @param {ExpressInterestCreateArgs} args - Arguments to create a ExpressInterest.
     * @example
     * // Create one ExpressInterest
     * const ExpressInterest = await prisma.expressInterest.create({
     *   data: {
     *     // ... data to create a ExpressInterest
     *   }
     * })
     * 
     */
    create<T extends ExpressInterestCreateArgs>(args: SelectSubset<T, ExpressInterestCreateArgs<ExtArgs>>): Prisma__ExpressInterestClient<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExpressInterests.
     * @param {ExpressInterestCreateManyArgs} args - Arguments to create many ExpressInterests.
     * @example
     * // Create many ExpressInterests
     * const expressInterest = await prisma.expressInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpressInterestCreateManyArgs>(args?: SelectSubset<T, ExpressInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpressInterests and returns the data saved in the database.
     * @param {ExpressInterestCreateManyAndReturnArgs} args - Arguments to create many ExpressInterests.
     * @example
     * // Create many ExpressInterests
     * const expressInterest = await prisma.expressInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpressInterests and only return the `id`
     * const expressInterestWithIdOnly = await prisma.expressInterest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpressInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpressInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExpressInterest.
     * @param {ExpressInterestDeleteArgs} args - Arguments to delete one ExpressInterest.
     * @example
     * // Delete one ExpressInterest
     * const ExpressInterest = await prisma.expressInterest.delete({
     *   where: {
     *     // ... filter to delete one ExpressInterest
     *   }
     * })
     * 
     */
    delete<T extends ExpressInterestDeleteArgs>(args: SelectSubset<T, ExpressInterestDeleteArgs<ExtArgs>>): Prisma__ExpressInterestClient<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExpressInterest.
     * @param {ExpressInterestUpdateArgs} args - Arguments to update one ExpressInterest.
     * @example
     * // Update one ExpressInterest
     * const expressInterest = await prisma.expressInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpressInterestUpdateArgs>(args: SelectSubset<T, ExpressInterestUpdateArgs<ExtArgs>>): Prisma__ExpressInterestClient<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExpressInterests.
     * @param {ExpressInterestDeleteManyArgs} args - Arguments to filter ExpressInterests to delete.
     * @example
     * // Delete a few ExpressInterests
     * const { count } = await prisma.expressInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpressInterestDeleteManyArgs>(args?: SelectSubset<T, ExpressInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpressInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpressInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpressInterests
     * const expressInterest = await prisma.expressInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpressInterestUpdateManyArgs>(args: SelectSubset<T, ExpressInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpressInterest.
     * @param {ExpressInterestUpsertArgs} args - Arguments to update or create a ExpressInterest.
     * @example
     * // Update or create a ExpressInterest
     * const expressInterest = await prisma.expressInterest.upsert({
     *   create: {
     *     // ... data to create a ExpressInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpressInterest we want to update
     *   }
     * })
     */
    upsert<T extends ExpressInterestUpsertArgs>(args: SelectSubset<T, ExpressInterestUpsertArgs<ExtArgs>>): Prisma__ExpressInterestClient<$Result.GetResult<Prisma.$ExpressInterestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExpressInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpressInterestCountArgs} args - Arguments to filter ExpressInterests to count.
     * @example
     * // Count the number of ExpressInterests
     * const count = await prisma.expressInterest.count({
     *   where: {
     *     // ... the filter for the ExpressInterests we want to count
     *   }
     * })
    **/
    count<T extends ExpressInterestCountArgs>(
      args?: Subset<T, ExpressInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpressInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpressInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpressInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpressInterestAggregateArgs>(args: Subset<T, ExpressInterestAggregateArgs>): Prisma.PrismaPromise<GetExpressInterestAggregateType<T>>

    /**
     * Group by ExpressInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpressInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpressInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpressInterestGroupByArgs['orderBy'] }
        : { orderBy?: ExpressInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpressInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpressInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpressInterest model
   */
  readonly fields: ExpressInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpressInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpressInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    founder<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpressInterest model
   */ 
  interface ExpressInterestFieldRefs {
    readonly id: FieldRef<"ExpressInterest", 'String'>
    readonly investorId: FieldRef<"ExpressInterest", 'String'>
    readonly founderId: FieldRef<"ExpressInterest", 'String'>
    readonly videoId: FieldRef<"ExpressInterest", 'String'>
    readonly status: FieldRef<"ExpressInterest", 'String'>
    readonly message: FieldRef<"ExpressInterest", 'String'>
    readonly createdAt: FieldRef<"ExpressInterest", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpressInterest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpressInterest findUnique
   */
  export type ExpressInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    /**
     * Filter, which ExpressInterest to fetch.
     */
    where: ExpressInterestWhereUniqueInput
  }

  /**
   * ExpressInterest findUniqueOrThrow
   */
  export type ExpressInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    /**
     * Filter, which ExpressInterest to fetch.
     */
    where: ExpressInterestWhereUniqueInput
  }

  /**
   * ExpressInterest findFirst
   */
  export type ExpressInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    /**
     * Filter, which ExpressInterest to fetch.
     */
    where?: ExpressInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpressInterests to fetch.
     */
    orderBy?: ExpressInterestOrderByWithRelationInput | ExpressInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpressInterests.
     */
    cursor?: ExpressInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpressInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpressInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpressInterests.
     */
    distinct?: ExpressInterestScalarFieldEnum | ExpressInterestScalarFieldEnum[]
  }

  /**
   * ExpressInterest findFirstOrThrow
   */
  export type ExpressInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    /**
     * Filter, which ExpressInterest to fetch.
     */
    where?: ExpressInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpressInterests to fetch.
     */
    orderBy?: ExpressInterestOrderByWithRelationInput | ExpressInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpressInterests.
     */
    cursor?: ExpressInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpressInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpressInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpressInterests.
     */
    distinct?: ExpressInterestScalarFieldEnum | ExpressInterestScalarFieldEnum[]
  }

  /**
   * ExpressInterest findMany
   */
  export type ExpressInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    /**
     * Filter, which ExpressInterests to fetch.
     */
    where?: ExpressInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpressInterests to fetch.
     */
    orderBy?: ExpressInterestOrderByWithRelationInput | ExpressInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpressInterests.
     */
    cursor?: ExpressInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpressInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpressInterests.
     */
    skip?: number
    distinct?: ExpressInterestScalarFieldEnum | ExpressInterestScalarFieldEnum[]
  }

  /**
   * ExpressInterest create
   */
  export type ExpressInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpressInterest.
     */
    data: XOR<ExpressInterestCreateInput, ExpressInterestUncheckedCreateInput>
  }

  /**
   * ExpressInterest createMany
   */
  export type ExpressInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpressInterests.
     */
    data: ExpressInterestCreateManyInput | ExpressInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpressInterest createManyAndReturn
   */
  export type ExpressInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExpressInterests.
     */
    data: ExpressInterestCreateManyInput | ExpressInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpressInterest update
   */
  export type ExpressInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpressInterest.
     */
    data: XOR<ExpressInterestUpdateInput, ExpressInterestUncheckedUpdateInput>
    /**
     * Choose, which ExpressInterest to update.
     */
    where: ExpressInterestWhereUniqueInput
  }

  /**
   * ExpressInterest updateMany
   */
  export type ExpressInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpressInterests.
     */
    data: XOR<ExpressInterestUpdateManyMutationInput, ExpressInterestUncheckedUpdateManyInput>
    /**
     * Filter which ExpressInterests to update
     */
    where?: ExpressInterestWhereInput
  }

  /**
   * ExpressInterest upsert
   */
  export type ExpressInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpressInterest to update in case it exists.
     */
    where: ExpressInterestWhereUniqueInput
    /**
     * In case the ExpressInterest found by the `where` argument doesn't exist, create a new ExpressInterest with this data.
     */
    create: XOR<ExpressInterestCreateInput, ExpressInterestUncheckedCreateInput>
    /**
     * In case the ExpressInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpressInterestUpdateInput, ExpressInterestUncheckedUpdateInput>
  }

  /**
   * ExpressInterest delete
   */
  export type ExpressInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
    /**
     * Filter which ExpressInterest to delete.
     */
    where: ExpressInterestWhereUniqueInput
  }

  /**
   * ExpressInterest deleteMany
   */
  export type ExpressInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpressInterests to delete
     */
    where?: ExpressInterestWhereInput
  }

  /**
   * ExpressInterest without action
   */
  export type ExpressInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpressInterest
     */
    select?: ExpressInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpressInterestInclude<ExtArgs> | null
  }


  /**
   * Model ProfileReveal
   */

  export type AggregateProfileReveal = {
    _count: ProfileRevealCountAggregateOutputType | null
    _min: ProfileRevealMinAggregateOutputType | null
    _max: ProfileRevealMaxAggregateOutputType | null
  }

  export type ProfileRevealMinAggregateOutputType = {
    id: string | null
    investorId: string | null
    founderId: string | null
    revealedAt: Date | null
  }

  export type ProfileRevealMaxAggregateOutputType = {
    id: string | null
    investorId: string | null
    founderId: string | null
    revealedAt: Date | null
  }

  export type ProfileRevealCountAggregateOutputType = {
    id: number
    investorId: number
    founderId: number
    revealedAt: number
    _all: number
  }


  export type ProfileRevealMinAggregateInputType = {
    id?: true
    investorId?: true
    founderId?: true
    revealedAt?: true
  }

  export type ProfileRevealMaxAggregateInputType = {
    id?: true
    investorId?: true
    founderId?: true
    revealedAt?: true
  }

  export type ProfileRevealCountAggregateInputType = {
    id?: true
    investorId?: true
    founderId?: true
    revealedAt?: true
    _all?: true
  }

  export type ProfileRevealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileReveal to aggregate.
     */
    where?: ProfileRevealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileReveals to fetch.
     */
    orderBy?: ProfileRevealOrderByWithRelationInput | ProfileRevealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileRevealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileReveals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileReveals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileReveals
    **/
    _count?: true | ProfileRevealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileRevealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileRevealMaxAggregateInputType
  }

  export type GetProfileRevealAggregateType<T extends ProfileRevealAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileReveal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileReveal[P]>
      : GetScalarType<T[P], AggregateProfileReveal[P]>
  }




  export type ProfileRevealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileRevealWhereInput
    orderBy?: ProfileRevealOrderByWithAggregationInput | ProfileRevealOrderByWithAggregationInput[]
    by: ProfileRevealScalarFieldEnum[] | ProfileRevealScalarFieldEnum
    having?: ProfileRevealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileRevealCountAggregateInputType | true
    _min?: ProfileRevealMinAggregateInputType
    _max?: ProfileRevealMaxAggregateInputType
  }

  export type ProfileRevealGroupByOutputType = {
    id: string
    investorId: string
    founderId: string
    revealedAt: Date
    _count: ProfileRevealCountAggregateOutputType | null
    _min: ProfileRevealMinAggregateOutputType | null
    _max: ProfileRevealMaxAggregateOutputType | null
  }

  type GetProfileRevealGroupByPayload<T extends ProfileRevealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileRevealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileRevealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileRevealGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileRevealGroupByOutputType[P]>
        }
      >
    >


  export type ProfileRevealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    founderId?: boolean
    revealedAt?: boolean
    investor?: boolean | UserDefaultArgs<ExtArgs>
    founder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileReveal"]>

  export type ProfileRevealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    founderId?: boolean
    revealedAt?: boolean
    investor?: boolean | UserDefaultArgs<ExtArgs>
    founder?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileReveal"]>

  export type ProfileRevealSelectScalar = {
    id?: boolean
    investorId?: boolean
    founderId?: boolean
    revealedAt?: boolean
  }

  export type ProfileRevealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | UserDefaultArgs<ExtArgs>
    founder?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileRevealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | UserDefaultArgs<ExtArgs>
    founder?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfileRevealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileReveal"
    objects: {
      investor: Prisma.$UserPayload<ExtArgs>
      founder: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      investorId: string
      founderId: string
      revealedAt: Date
    }, ExtArgs["result"]["profileReveal"]>
    composites: {}
  }

  type ProfileRevealGetPayload<S extends boolean | null | undefined | ProfileRevealDefaultArgs> = $Result.GetResult<Prisma.$ProfileRevealPayload, S>

  type ProfileRevealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileRevealFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileRevealCountAggregateInputType | true
    }

  export interface ProfileRevealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileReveal'], meta: { name: 'ProfileReveal' } }
    /**
     * Find zero or one ProfileReveal that matches the filter.
     * @param {ProfileRevealFindUniqueArgs} args - Arguments to find a ProfileReveal
     * @example
     * // Get one ProfileReveal
     * const profileReveal = await prisma.profileReveal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileRevealFindUniqueArgs>(args: SelectSubset<T, ProfileRevealFindUniqueArgs<ExtArgs>>): Prisma__ProfileRevealClient<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileReveal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileRevealFindUniqueOrThrowArgs} args - Arguments to find a ProfileReveal
     * @example
     * // Get one ProfileReveal
     * const profileReveal = await prisma.profileReveal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileRevealFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileRevealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileRevealClient<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileReveal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileRevealFindFirstArgs} args - Arguments to find a ProfileReveal
     * @example
     * // Get one ProfileReveal
     * const profileReveal = await prisma.profileReveal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileRevealFindFirstArgs>(args?: SelectSubset<T, ProfileRevealFindFirstArgs<ExtArgs>>): Prisma__ProfileRevealClient<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileReveal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileRevealFindFirstOrThrowArgs} args - Arguments to find a ProfileReveal
     * @example
     * // Get one ProfileReveal
     * const profileReveal = await prisma.profileReveal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileRevealFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileRevealFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileRevealClient<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileReveals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileRevealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileReveals
     * const profileReveals = await prisma.profileReveal.findMany()
     * 
     * // Get first 10 ProfileReveals
     * const profileReveals = await prisma.profileReveal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileRevealWithIdOnly = await prisma.profileReveal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileRevealFindManyArgs>(args?: SelectSubset<T, ProfileRevealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileReveal.
     * @param {ProfileRevealCreateArgs} args - Arguments to create a ProfileReveal.
     * @example
     * // Create one ProfileReveal
     * const ProfileReveal = await prisma.profileReveal.create({
     *   data: {
     *     // ... data to create a ProfileReveal
     *   }
     * })
     * 
     */
    create<T extends ProfileRevealCreateArgs>(args: SelectSubset<T, ProfileRevealCreateArgs<ExtArgs>>): Prisma__ProfileRevealClient<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileReveals.
     * @param {ProfileRevealCreateManyArgs} args - Arguments to create many ProfileReveals.
     * @example
     * // Create many ProfileReveals
     * const profileReveal = await prisma.profileReveal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileRevealCreateManyArgs>(args?: SelectSubset<T, ProfileRevealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileReveals and returns the data saved in the database.
     * @param {ProfileRevealCreateManyAndReturnArgs} args - Arguments to create many ProfileReveals.
     * @example
     * // Create many ProfileReveals
     * const profileReveal = await prisma.profileReveal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileReveals and only return the `id`
     * const profileRevealWithIdOnly = await prisma.profileReveal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileRevealCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileRevealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileReveal.
     * @param {ProfileRevealDeleteArgs} args - Arguments to delete one ProfileReveal.
     * @example
     * // Delete one ProfileReveal
     * const ProfileReveal = await prisma.profileReveal.delete({
     *   where: {
     *     // ... filter to delete one ProfileReveal
     *   }
     * })
     * 
     */
    delete<T extends ProfileRevealDeleteArgs>(args: SelectSubset<T, ProfileRevealDeleteArgs<ExtArgs>>): Prisma__ProfileRevealClient<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileReveal.
     * @param {ProfileRevealUpdateArgs} args - Arguments to update one ProfileReveal.
     * @example
     * // Update one ProfileReveal
     * const profileReveal = await prisma.profileReveal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileRevealUpdateArgs>(args: SelectSubset<T, ProfileRevealUpdateArgs<ExtArgs>>): Prisma__ProfileRevealClient<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileReveals.
     * @param {ProfileRevealDeleteManyArgs} args - Arguments to filter ProfileReveals to delete.
     * @example
     * // Delete a few ProfileReveals
     * const { count } = await prisma.profileReveal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileRevealDeleteManyArgs>(args?: SelectSubset<T, ProfileRevealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileReveals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileRevealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileReveals
     * const profileReveal = await prisma.profileReveal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileRevealUpdateManyArgs>(args: SelectSubset<T, ProfileRevealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileReveal.
     * @param {ProfileRevealUpsertArgs} args - Arguments to update or create a ProfileReveal.
     * @example
     * // Update or create a ProfileReveal
     * const profileReveal = await prisma.profileReveal.upsert({
     *   create: {
     *     // ... data to create a ProfileReveal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileReveal we want to update
     *   }
     * })
     */
    upsert<T extends ProfileRevealUpsertArgs>(args: SelectSubset<T, ProfileRevealUpsertArgs<ExtArgs>>): Prisma__ProfileRevealClient<$Result.GetResult<Prisma.$ProfileRevealPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileReveals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileRevealCountArgs} args - Arguments to filter ProfileReveals to count.
     * @example
     * // Count the number of ProfileReveals
     * const count = await prisma.profileReveal.count({
     *   where: {
     *     // ... the filter for the ProfileReveals we want to count
     *   }
     * })
    **/
    count<T extends ProfileRevealCountArgs>(
      args?: Subset<T, ProfileRevealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileRevealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileReveal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileRevealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileRevealAggregateArgs>(args: Subset<T, ProfileRevealAggregateArgs>): Prisma.PrismaPromise<GetProfileRevealAggregateType<T>>

    /**
     * Group by ProfileReveal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileRevealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileRevealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileRevealGroupByArgs['orderBy'] }
        : { orderBy?: ProfileRevealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileRevealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileRevealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileReveal model
   */
  readonly fields: ProfileRevealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileReveal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileRevealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    founder<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileReveal model
   */ 
  interface ProfileRevealFieldRefs {
    readonly id: FieldRef<"ProfileReveal", 'String'>
    readonly investorId: FieldRef<"ProfileReveal", 'String'>
    readonly founderId: FieldRef<"ProfileReveal", 'String'>
    readonly revealedAt: FieldRef<"ProfileReveal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileReveal findUnique
   */
  export type ProfileRevealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    /**
     * Filter, which ProfileReveal to fetch.
     */
    where: ProfileRevealWhereUniqueInput
  }

  /**
   * ProfileReveal findUniqueOrThrow
   */
  export type ProfileRevealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    /**
     * Filter, which ProfileReveal to fetch.
     */
    where: ProfileRevealWhereUniqueInput
  }

  /**
   * ProfileReveal findFirst
   */
  export type ProfileRevealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    /**
     * Filter, which ProfileReveal to fetch.
     */
    where?: ProfileRevealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileReveals to fetch.
     */
    orderBy?: ProfileRevealOrderByWithRelationInput | ProfileRevealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileReveals.
     */
    cursor?: ProfileRevealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileReveals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileReveals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileReveals.
     */
    distinct?: ProfileRevealScalarFieldEnum | ProfileRevealScalarFieldEnum[]
  }

  /**
   * ProfileReveal findFirstOrThrow
   */
  export type ProfileRevealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    /**
     * Filter, which ProfileReveal to fetch.
     */
    where?: ProfileRevealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileReveals to fetch.
     */
    orderBy?: ProfileRevealOrderByWithRelationInput | ProfileRevealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileReveals.
     */
    cursor?: ProfileRevealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileReveals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileReveals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileReveals.
     */
    distinct?: ProfileRevealScalarFieldEnum | ProfileRevealScalarFieldEnum[]
  }

  /**
   * ProfileReveal findMany
   */
  export type ProfileRevealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    /**
     * Filter, which ProfileReveals to fetch.
     */
    where?: ProfileRevealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileReveals to fetch.
     */
    orderBy?: ProfileRevealOrderByWithRelationInput | ProfileRevealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileReveals.
     */
    cursor?: ProfileRevealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileReveals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileReveals.
     */
    skip?: number
    distinct?: ProfileRevealScalarFieldEnum | ProfileRevealScalarFieldEnum[]
  }

  /**
   * ProfileReveal create
   */
  export type ProfileRevealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileReveal.
     */
    data: XOR<ProfileRevealCreateInput, ProfileRevealUncheckedCreateInput>
  }

  /**
   * ProfileReveal createMany
   */
  export type ProfileRevealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileReveals.
     */
    data: ProfileRevealCreateManyInput | ProfileRevealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileReveal createManyAndReturn
   */
  export type ProfileRevealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileReveals.
     */
    data: ProfileRevealCreateManyInput | ProfileRevealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileReveal update
   */
  export type ProfileRevealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileReveal.
     */
    data: XOR<ProfileRevealUpdateInput, ProfileRevealUncheckedUpdateInput>
    /**
     * Choose, which ProfileReveal to update.
     */
    where: ProfileRevealWhereUniqueInput
  }

  /**
   * ProfileReveal updateMany
   */
  export type ProfileRevealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileReveals.
     */
    data: XOR<ProfileRevealUpdateManyMutationInput, ProfileRevealUncheckedUpdateManyInput>
    /**
     * Filter which ProfileReveals to update
     */
    where?: ProfileRevealWhereInput
  }

  /**
   * ProfileReveal upsert
   */
  export type ProfileRevealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileReveal to update in case it exists.
     */
    where: ProfileRevealWhereUniqueInput
    /**
     * In case the ProfileReveal found by the `where` argument doesn't exist, create a new ProfileReveal with this data.
     */
    create: XOR<ProfileRevealCreateInput, ProfileRevealUncheckedCreateInput>
    /**
     * In case the ProfileReveal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileRevealUpdateInput, ProfileRevealUncheckedUpdateInput>
  }

  /**
   * ProfileReveal delete
   */
  export type ProfileRevealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
    /**
     * Filter which ProfileReveal to delete.
     */
    where: ProfileRevealWhereUniqueInput
  }

  /**
   * ProfileReveal deleteMany
   */
  export type ProfileRevealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileReveals to delete
     */
    where?: ProfileRevealWhereInput
  }

  /**
   * ProfileReveal without action
   */
  export type ProfileRevealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileReveal
     */
    select?: ProfileRevealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileRevealInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    participant1Id: string | null
    participant2Id: string | null
    status: $Enums.ConversationStatus | null
    isRevealed: boolean | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    participant1Id: string | null
    participant2Id: string | null
    status: $Enums.ConversationStatus | null
    isRevealed: boolean | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    participant1Id: number
    participant2Id: number
    status: number
    isRevealed: number
    lastMessageAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    participant1Id?: true
    participant2Id?: true
    status?: true
    isRevealed?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    participant1Id?: true
    participant2Id?: true
    status?: true
    isRevealed?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    participant1Id?: true
    participant2Id?: true
    status?: true
    isRevealed?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    participant1Id: string
    participant2Id: string
    status: $Enums.ConversationStatus
    isRevealed: boolean
    lastMessageAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Id?: boolean
    participant2Id?: boolean
    status?: boolean
    isRevealed?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participant1?: boolean | UserDefaultArgs<ExtArgs>
    participant2?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participant1Id?: boolean
    participant2Id?: boolean
    status?: boolean
    isRevealed?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participant1?: boolean | UserDefaultArgs<ExtArgs>
    participant2?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    participant1Id?: boolean
    participant2Id?: boolean
    status?: boolean
    isRevealed?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant1?: boolean | UserDefaultArgs<ExtArgs>
    participant2?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant1?: boolean | UserDefaultArgs<ExtArgs>
    participant2?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      participant1: Prisma.$UserPayload<ExtArgs>
      participant2: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      participant1Id: string
      participant2Id: string
      status: $Enums.ConversationStatus
      isRevealed: boolean
      lastMessageAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participant1<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participant2<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly participant1Id: FieldRef<"Conversation", 'String'>
    readonly participant2Id: FieldRef<"Conversation", 'String'>
    readonly status: FieldRef<"Conversation", 'ConversationStatus'>
    readonly isRevealed: FieldRef<"Conversation", 'Boolean'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    type: string | null
    attachmentUrl: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    type: string | null
    attachmentUrl: string | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    type: number
    attachmentUrl: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    type?: true
    attachmentUrl?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    type?: true
    attachmentUrl?: true
    readAt?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    type?: true
    attachmentUrl?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    content: string
    type: string
    attachmentUrl: string | null
    readAt: Date | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    attachmentUrl?: boolean
    readAt?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    attachmentUrl?: boolean
    readAt?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    attachmentUrl?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      content: string
      type: string
      attachmentUrl: string | null
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'String'>
    readonly attachmentUrl: FieldRef<"Message", 'String'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageLimit
   */

  export type AggregateMessageLimit = {
    _count: MessageLimitCountAggregateOutputType | null
    _avg: MessageLimitAvgAggregateOutputType | null
    _sum: MessageLimitSumAggregateOutputType | null
    _min: MessageLimitMinAggregateOutputType | null
    _max: MessageLimitMaxAggregateOutputType | null
  }

  export type MessageLimitAvgAggregateOutputType = {
    count: number | null
  }

  export type MessageLimitSumAggregateOutputType = {
    count: number | null
  }

  export type MessageLimitMinAggregateOutputType = {
    id: string | null
    userId: string | null
    period: string | null
    count: number | null
    resetsAt: Date | null
    createdAt: Date | null
  }

  export type MessageLimitMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    period: string | null
    count: number | null
    resetsAt: Date | null
    createdAt: Date | null
  }

  export type MessageLimitCountAggregateOutputType = {
    id: number
    userId: number
    period: number
    count: number
    resetsAt: number
    createdAt: number
    _all: number
  }


  export type MessageLimitAvgAggregateInputType = {
    count?: true
  }

  export type MessageLimitSumAggregateInputType = {
    count?: true
  }

  export type MessageLimitMinAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    count?: true
    resetsAt?: true
    createdAt?: true
  }

  export type MessageLimitMaxAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    count?: true
    resetsAt?: true
    createdAt?: true
  }

  export type MessageLimitCountAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    count?: true
    resetsAt?: true
    createdAt?: true
    _all?: true
  }

  export type MessageLimitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageLimit to aggregate.
     */
    where?: MessageLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLimits to fetch.
     */
    orderBy?: MessageLimitOrderByWithRelationInput | MessageLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageLimits
    **/
    _count?: true | MessageLimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageLimitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageLimitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageLimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageLimitMaxAggregateInputType
  }

  export type GetMessageLimitAggregateType<T extends MessageLimitAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageLimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageLimit[P]>
      : GetScalarType<T[P], AggregateMessageLimit[P]>
  }




  export type MessageLimitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLimitWhereInput
    orderBy?: MessageLimitOrderByWithAggregationInput | MessageLimitOrderByWithAggregationInput[]
    by: MessageLimitScalarFieldEnum[] | MessageLimitScalarFieldEnum
    having?: MessageLimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageLimitCountAggregateInputType | true
    _avg?: MessageLimitAvgAggregateInputType
    _sum?: MessageLimitSumAggregateInputType
    _min?: MessageLimitMinAggregateInputType
    _max?: MessageLimitMaxAggregateInputType
  }

  export type MessageLimitGroupByOutputType = {
    id: string
    userId: string
    period: string
    count: number
    resetsAt: Date
    createdAt: Date
    _count: MessageLimitCountAggregateOutputType | null
    _avg: MessageLimitAvgAggregateOutputType | null
    _sum: MessageLimitSumAggregateOutputType | null
    _min: MessageLimitMinAggregateOutputType | null
    _max: MessageLimitMaxAggregateOutputType | null
  }

  type GetMessageLimitGroupByPayload<T extends MessageLimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageLimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageLimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageLimitGroupByOutputType[P]>
            : GetScalarType<T[P], MessageLimitGroupByOutputType[P]>
        }
      >
    >


  export type MessageLimitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    period?: boolean
    count?: boolean
    resetsAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageLimit"]>

  export type MessageLimitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    period?: boolean
    count?: boolean
    resetsAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageLimit"]>

  export type MessageLimitSelectScalar = {
    id?: boolean
    userId?: boolean
    period?: boolean
    count?: boolean
    resetsAt?: boolean
    createdAt?: boolean
  }

  export type MessageLimitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageLimitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageLimitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageLimit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      period: string
      count: number
      resetsAt: Date
      createdAt: Date
    }, ExtArgs["result"]["messageLimit"]>
    composites: {}
  }

  type MessageLimitGetPayload<S extends boolean | null | undefined | MessageLimitDefaultArgs> = $Result.GetResult<Prisma.$MessageLimitPayload, S>

  type MessageLimitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageLimitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageLimitCountAggregateInputType | true
    }

  export interface MessageLimitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageLimit'], meta: { name: 'MessageLimit' } }
    /**
     * Find zero or one MessageLimit that matches the filter.
     * @param {MessageLimitFindUniqueArgs} args - Arguments to find a MessageLimit
     * @example
     * // Get one MessageLimit
     * const messageLimit = await prisma.messageLimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageLimitFindUniqueArgs>(args: SelectSubset<T, MessageLimitFindUniqueArgs<ExtArgs>>): Prisma__MessageLimitClient<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageLimit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageLimitFindUniqueOrThrowArgs} args - Arguments to find a MessageLimit
     * @example
     * // Get one MessageLimit
     * const messageLimit = await prisma.messageLimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageLimitFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageLimitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageLimitClient<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageLimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLimitFindFirstArgs} args - Arguments to find a MessageLimit
     * @example
     * // Get one MessageLimit
     * const messageLimit = await prisma.messageLimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageLimitFindFirstArgs>(args?: SelectSubset<T, MessageLimitFindFirstArgs<ExtArgs>>): Prisma__MessageLimitClient<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageLimit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLimitFindFirstOrThrowArgs} args - Arguments to find a MessageLimit
     * @example
     * // Get one MessageLimit
     * const messageLimit = await prisma.messageLimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageLimitFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageLimitFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageLimitClient<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLimitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageLimits
     * const messageLimits = await prisma.messageLimit.findMany()
     * 
     * // Get first 10 MessageLimits
     * const messageLimits = await prisma.messageLimit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageLimitWithIdOnly = await prisma.messageLimit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageLimitFindManyArgs>(args?: SelectSubset<T, MessageLimitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageLimit.
     * @param {MessageLimitCreateArgs} args - Arguments to create a MessageLimit.
     * @example
     * // Create one MessageLimit
     * const MessageLimit = await prisma.messageLimit.create({
     *   data: {
     *     // ... data to create a MessageLimit
     *   }
     * })
     * 
     */
    create<T extends MessageLimitCreateArgs>(args: SelectSubset<T, MessageLimitCreateArgs<ExtArgs>>): Prisma__MessageLimitClient<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageLimits.
     * @param {MessageLimitCreateManyArgs} args - Arguments to create many MessageLimits.
     * @example
     * // Create many MessageLimits
     * const messageLimit = await prisma.messageLimit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageLimitCreateManyArgs>(args?: SelectSubset<T, MessageLimitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageLimits and returns the data saved in the database.
     * @param {MessageLimitCreateManyAndReturnArgs} args - Arguments to create many MessageLimits.
     * @example
     * // Create many MessageLimits
     * const messageLimit = await prisma.messageLimit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageLimits and only return the `id`
     * const messageLimitWithIdOnly = await prisma.messageLimit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageLimitCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageLimitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageLimit.
     * @param {MessageLimitDeleteArgs} args - Arguments to delete one MessageLimit.
     * @example
     * // Delete one MessageLimit
     * const MessageLimit = await prisma.messageLimit.delete({
     *   where: {
     *     // ... filter to delete one MessageLimit
     *   }
     * })
     * 
     */
    delete<T extends MessageLimitDeleteArgs>(args: SelectSubset<T, MessageLimitDeleteArgs<ExtArgs>>): Prisma__MessageLimitClient<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageLimit.
     * @param {MessageLimitUpdateArgs} args - Arguments to update one MessageLimit.
     * @example
     * // Update one MessageLimit
     * const messageLimit = await prisma.messageLimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageLimitUpdateArgs>(args: SelectSubset<T, MessageLimitUpdateArgs<ExtArgs>>): Prisma__MessageLimitClient<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageLimits.
     * @param {MessageLimitDeleteManyArgs} args - Arguments to filter MessageLimits to delete.
     * @example
     * // Delete a few MessageLimits
     * const { count } = await prisma.messageLimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageLimitDeleteManyArgs>(args?: SelectSubset<T, MessageLimitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageLimits
     * const messageLimit = await prisma.messageLimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageLimitUpdateManyArgs>(args: SelectSubset<T, MessageLimitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageLimit.
     * @param {MessageLimitUpsertArgs} args - Arguments to update or create a MessageLimit.
     * @example
     * // Update or create a MessageLimit
     * const messageLimit = await prisma.messageLimit.upsert({
     *   create: {
     *     // ... data to create a MessageLimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageLimit we want to update
     *   }
     * })
     */
    upsert<T extends MessageLimitUpsertArgs>(args: SelectSubset<T, MessageLimitUpsertArgs<ExtArgs>>): Prisma__MessageLimitClient<$Result.GetResult<Prisma.$MessageLimitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLimitCountArgs} args - Arguments to filter MessageLimits to count.
     * @example
     * // Count the number of MessageLimits
     * const count = await prisma.messageLimit.count({
     *   where: {
     *     // ... the filter for the MessageLimits we want to count
     *   }
     * })
    **/
    count<T extends MessageLimitCountArgs>(
      args?: Subset<T, MessageLimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageLimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageLimitAggregateArgs>(args: Subset<T, MessageLimitAggregateArgs>): Prisma.PrismaPromise<GetMessageLimitAggregateType<T>>

    /**
     * Group by MessageLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageLimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageLimitGroupByArgs['orderBy'] }
        : { orderBy?: MessageLimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageLimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageLimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageLimit model
   */
  readonly fields: MessageLimitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageLimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageLimitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageLimit model
   */ 
  interface MessageLimitFieldRefs {
    readonly id: FieldRef<"MessageLimit", 'String'>
    readonly userId: FieldRef<"MessageLimit", 'String'>
    readonly period: FieldRef<"MessageLimit", 'String'>
    readonly count: FieldRef<"MessageLimit", 'Int'>
    readonly resetsAt: FieldRef<"MessageLimit", 'DateTime'>
    readonly createdAt: FieldRef<"MessageLimit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageLimit findUnique
   */
  export type MessageLimitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    /**
     * Filter, which MessageLimit to fetch.
     */
    where: MessageLimitWhereUniqueInput
  }

  /**
   * MessageLimit findUniqueOrThrow
   */
  export type MessageLimitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    /**
     * Filter, which MessageLimit to fetch.
     */
    where: MessageLimitWhereUniqueInput
  }

  /**
   * MessageLimit findFirst
   */
  export type MessageLimitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    /**
     * Filter, which MessageLimit to fetch.
     */
    where?: MessageLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLimits to fetch.
     */
    orderBy?: MessageLimitOrderByWithRelationInput | MessageLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageLimits.
     */
    cursor?: MessageLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageLimits.
     */
    distinct?: MessageLimitScalarFieldEnum | MessageLimitScalarFieldEnum[]
  }

  /**
   * MessageLimit findFirstOrThrow
   */
  export type MessageLimitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    /**
     * Filter, which MessageLimit to fetch.
     */
    where?: MessageLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLimits to fetch.
     */
    orderBy?: MessageLimitOrderByWithRelationInput | MessageLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageLimits.
     */
    cursor?: MessageLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageLimits.
     */
    distinct?: MessageLimitScalarFieldEnum | MessageLimitScalarFieldEnum[]
  }

  /**
   * MessageLimit findMany
   */
  export type MessageLimitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    /**
     * Filter, which MessageLimits to fetch.
     */
    where?: MessageLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLimits to fetch.
     */
    orderBy?: MessageLimitOrderByWithRelationInput | MessageLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageLimits.
     */
    cursor?: MessageLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLimits.
     */
    skip?: number
    distinct?: MessageLimitScalarFieldEnum | MessageLimitScalarFieldEnum[]
  }

  /**
   * MessageLimit create
   */
  export type MessageLimitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageLimit.
     */
    data: XOR<MessageLimitCreateInput, MessageLimitUncheckedCreateInput>
  }

  /**
   * MessageLimit createMany
   */
  export type MessageLimitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageLimits.
     */
    data: MessageLimitCreateManyInput | MessageLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageLimit createManyAndReturn
   */
  export type MessageLimitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageLimits.
     */
    data: MessageLimitCreateManyInput | MessageLimitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageLimit update
   */
  export type MessageLimitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageLimit.
     */
    data: XOR<MessageLimitUpdateInput, MessageLimitUncheckedUpdateInput>
    /**
     * Choose, which MessageLimit to update.
     */
    where: MessageLimitWhereUniqueInput
  }

  /**
   * MessageLimit updateMany
   */
  export type MessageLimitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageLimits.
     */
    data: XOR<MessageLimitUpdateManyMutationInput, MessageLimitUncheckedUpdateManyInput>
    /**
     * Filter which MessageLimits to update
     */
    where?: MessageLimitWhereInput
  }

  /**
   * MessageLimit upsert
   */
  export type MessageLimitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageLimit to update in case it exists.
     */
    where: MessageLimitWhereUniqueInput
    /**
     * In case the MessageLimit found by the `where` argument doesn't exist, create a new MessageLimit with this data.
     */
    create: XOR<MessageLimitCreateInput, MessageLimitUncheckedCreateInput>
    /**
     * In case the MessageLimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageLimitUpdateInput, MessageLimitUncheckedUpdateInput>
  }

  /**
   * MessageLimit delete
   */
  export type MessageLimitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
    /**
     * Filter which MessageLimit to delete.
     */
    where: MessageLimitWhereUniqueInput
  }

  /**
   * MessageLimit deleteMany
   */
  export type MessageLimitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageLimits to delete
     */
    where?: MessageLimitWhereInput
  }

  /**
   * MessageLimit without action
   */
  export type MessageLimitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLimit
     */
    select?: MessageLimitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLimitInclude<ExtArgs> | null
  }


  /**
   * Model ContentReport
   */

  export type AggregateContentReport = {
    _count: ContentReportCountAggregateOutputType | null
    _min: ContentReportMinAggregateOutputType | null
    _max: ContentReportMaxAggregateOutputType | null
  }

  export type ContentReportMinAggregateOutputType = {
    id: string | null
    reporterId: string | null
    videoId: string | null
    category: $Enums.ReportCategory | null
    details: string | null
    status: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ContentReportMaxAggregateOutputType = {
    id: string | null
    reporterId: string | null
    videoId: string | null
    category: $Enums.ReportCategory | null
    details: string | null
    status: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ContentReportCountAggregateOutputType = {
    id: number
    reporterId: number
    videoId: number
    category: number
    details: number
    status: number
    reviewedAt: number
    createdAt: number
    _all: number
  }


  export type ContentReportMinAggregateInputType = {
    id?: true
    reporterId?: true
    videoId?: true
    category?: true
    details?: true
    status?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ContentReportMaxAggregateInputType = {
    id?: true
    reporterId?: true
    videoId?: true
    category?: true
    details?: true
    status?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ContentReportCountAggregateInputType = {
    id?: true
    reporterId?: true
    videoId?: true
    category?: true
    details?: true
    status?: true
    reviewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ContentReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentReport to aggregate.
     */
    where?: ContentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentReports to fetch.
     */
    orderBy?: ContentReportOrderByWithRelationInput | ContentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentReports
    **/
    _count?: true | ContentReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentReportMaxAggregateInputType
  }

  export type GetContentReportAggregateType<T extends ContentReportAggregateArgs> = {
        [P in keyof T & keyof AggregateContentReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentReport[P]>
      : GetScalarType<T[P], AggregateContentReport[P]>
  }




  export type ContentReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentReportWhereInput
    orderBy?: ContentReportOrderByWithAggregationInput | ContentReportOrderByWithAggregationInput[]
    by: ContentReportScalarFieldEnum[] | ContentReportScalarFieldEnum
    having?: ContentReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentReportCountAggregateInputType | true
    _min?: ContentReportMinAggregateInputType
    _max?: ContentReportMaxAggregateInputType
  }

  export type ContentReportGroupByOutputType = {
    id: string
    reporterId: string
    videoId: string
    category: $Enums.ReportCategory
    details: string | null
    status: string
    reviewedAt: Date | null
    createdAt: Date
    _count: ContentReportCountAggregateOutputType | null
    _min: ContentReportMinAggregateOutputType | null
    _max: ContentReportMaxAggregateOutputType | null
  }

  type GetContentReportGroupByPayload<T extends ContentReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentReportGroupByOutputType[P]>
            : GetScalarType<T[P], ContentReportGroupByOutputType[P]>
        }
      >
    >


  export type ContentReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    videoId?: boolean
    category?: boolean
    details?: boolean
    status?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentReport"]>

  export type ContentReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    videoId?: boolean
    category?: boolean
    details?: boolean
    status?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentReport"]>

  export type ContentReportSelectScalar = {
    id?: boolean
    reporterId?: boolean
    videoId?: boolean
    category?: boolean
    details?: boolean
    status?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }

  export type ContentReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }
  export type ContentReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }

  export type $ContentReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentReport"
    objects: {
      reporter: Prisma.$UserPayload<ExtArgs>
      video: Prisma.$VideoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reporterId: string
      videoId: string
      category: $Enums.ReportCategory
      details: string | null
      status: string
      reviewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["contentReport"]>
    composites: {}
  }

  type ContentReportGetPayload<S extends boolean | null | undefined | ContentReportDefaultArgs> = $Result.GetResult<Prisma.$ContentReportPayload, S>

  type ContentReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentReportCountAggregateInputType | true
    }

  export interface ContentReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentReport'], meta: { name: 'ContentReport' } }
    /**
     * Find zero or one ContentReport that matches the filter.
     * @param {ContentReportFindUniqueArgs} args - Arguments to find a ContentReport
     * @example
     * // Get one ContentReport
     * const contentReport = await prisma.contentReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentReportFindUniqueArgs>(args: SelectSubset<T, ContentReportFindUniqueArgs<ExtArgs>>): Prisma__ContentReportClient<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentReportFindUniqueOrThrowArgs} args - Arguments to find a ContentReport
     * @example
     * // Get one ContentReport
     * const contentReport = await prisma.contentReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentReportClient<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReportFindFirstArgs} args - Arguments to find a ContentReport
     * @example
     * // Get one ContentReport
     * const contentReport = await prisma.contentReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentReportFindFirstArgs>(args?: SelectSubset<T, ContentReportFindFirstArgs<ExtArgs>>): Prisma__ContentReportClient<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReportFindFirstOrThrowArgs} args - Arguments to find a ContentReport
     * @example
     * // Get one ContentReport
     * const contentReport = await prisma.contentReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentReportClient<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentReports
     * const contentReports = await prisma.contentReport.findMany()
     * 
     * // Get first 10 ContentReports
     * const contentReports = await prisma.contentReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentReportWithIdOnly = await prisma.contentReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentReportFindManyArgs>(args?: SelectSubset<T, ContentReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentReport.
     * @param {ContentReportCreateArgs} args - Arguments to create a ContentReport.
     * @example
     * // Create one ContentReport
     * const ContentReport = await prisma.contentReport.create({
     *   data: {
     *     // ... data to create a ContentReport
     *   }
     * })
     * 
     */
    create<T extends ContentReportCreateArgs>(args: SelectSubset<T, ContentReportCreateArgs<ExtArgs>>): Prisma__ContentReportClient<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentReports.
     * @param {ContentReportCreateManyArgs} args - Arguments to create many ContentReports.
     * @example
     * // Create many ContentReports
     * const contentReport = await prisma.contentReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentReportCreateManyArgs>(args?: SelectSubset<T, ContentReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentReports and returns the data saved in the database.
     * @param {ContentReportCreateManyAndReturnArgs} args - Arguments to create many ContentReports.
     * @example
     * // Create many ContentReports
     * const contentReport = await prisma.contentReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentReports and only return the `id`
     * const contentReportWithIdOnly = await prisma.contentReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentReport.
     * @param {ContentReportDeleteArgs} args - Arguments to delete one ContentReport.
     * @example
     * // Delete one ContentReport
     * const ContentReport = await prisma.contentReport.delete({
     *   where: {
     *     // ... filter to delete one ContentReport
     *   }
     * })
     * 
     */
    delete<T extends ContentReportDeleteArgs>(args: SelectSubset<T, ContentReportDeleteArgs<ExtArgs>>): Prisma__ContentReportClient<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentReport.
     * @param {ContentReportUpdateArgs} args - Arguments to update one ContentReport.
     * @example
     * // Update one ContentReport
     * const contentReport = await prisma.contentReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentReportUpdateArgs>(args: SelectSubset<T, ContentReportUpdateArgs<ExtArgs>>): Prisma__ContentReportClient<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentReports.
     * @param {ContentReportDeleteManyArgs} args - Arguments to filter ContentReports to delete.
     * @example
     * // Delete a few ContentReports
     * const { count } = await prisma.contentReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentReportDeleteManyArgs>(args?: SelectSubset<T, ContentReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentReports
     * const contentReport = await prisma.contentReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentReportUpdateManyArgs>(args: SelectSubset<T, ContentReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentReport.
     * @param {ContentReportUpsertArgs} args - Arguments to update or create a ContentReport.
     * @example
     * // Update or create a ContentReport
     * const contentReport = await prisma.contentReport.upsert({
     *   create: {
     *     // ... data to create a ContentReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentReport we want to update
     *   }
     * })
     */
    upsert<T extends ContentReportUpsertArgs>(args: SelectSubset<T, ContentReportUpsertArgs<ExtArgs>>): Prisma__ContentReportClient<$Result.GetResult<Prisma.$ContentReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReportCountArgs} args - Arguments to filter ContentReports to count.
     * @example
     * // Count the number of ContentReports
     * const count = await prisma.contentReport.count({
     *   where: {
     *     // ... the filter for the ContentReports we want to count
     *   }
     * })
    **/
    count<T extends ContentReportCountArgs>(
      args?: Subset<T, ContentReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentReportAggregateArgs>(args: Subset<T, ContentReportAggregateArgs>): Prisma.PrismaPromise<GetContentReportAggregateType<T>>

    /**
     * Group by ContentReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentReportGroupByArgs['orderBy'] }
        : { orderBy?: ContentReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentReport model
   */
  readonly fields: ContentReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentReport model
   */ 
  interface ContentReportFieldRefs {
    readonly id: FieldRef<"ContentReport", 'String'>
    readonly reporterId: FieldRef<"ContentReport", 'String'>
    readonly videoId: FieldRef<"ContentReport", 'String'>
    readonly category: FieldRef<"ContentReport", 'ReportCategory'>
    readonly details: FieldRef<"ContentReport", 'String'>
    readonly status: FieldRef<"ContentReport", 'String'>
    readonly reviewedAt: FieldRef<"ContentReport", 'DateTime'>
    readonly createdAt: FieldRef<"ContentReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentReport findUnique
   */
  export type ContentReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    /**
     * Filter, which ContentReport to fetch.
     */
    where: ContentReportWhereUniqueInput
  }

  /**
   * ContentReport findUniqueOrThrow
   */
  export type ContentReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    /**
     * Filter, which ContentReport to fetch.
     */
    where: ContentReportWhereUniqueInput
  }

  /**
   * ContentReport findFirst
   */
  export type ContentReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    /**
     * Filter, which ContentReport to fetch.
     */
    where?: ContentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentReports to fetch.
     */
    orderBy?: ContentReportOrderByWithRelationInput | ContentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentReports.
     */
    cursor?: ContentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentReports.
     */
    distinct?: ContentReportScalarFieldEnum | ContentReportScalarFieldEnum[]
  }

  /**
   * ContentReport findFirstOrThrow
   */
  export type ContentReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    /**
     * Filter, which ContentReport to fetch.
     */
    where?: ContentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentReports to fetch.
     */
    orderBy?: ContentReportOrderByWithRelationInput | ContentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentReports.
     */
    cursor?: ContentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentReports.
     */
    distinct?: ContentReportScalarFieldEnum | ContentReportScalarFieldEnum[]
  }

  /**
   * ContentReport findMany
   */
  export type ContentReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    /**
     * Filter, which ContentReports to fetch.
     */
    where?: ContentReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentReports to fetch.
     */
    orderBy?: ContentReportOrderByWithRelationInput | ContentReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentReports.
     */
    cursor?: ContentReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentReports.
     */
    skip?: number
    distinct?: ContentReportScalarFieldEnum | ContentReportScalarFieldEnum[]
  }

  /**
   * ContentReport create
   */
  export type ContentReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentReport.
     */
    data: XOR<ContentReportCreateInput, ContentReportUncheckedCreateInput>
  }

  /**
   * ContentReport createMany
   */
  export type ContentReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentReports.
     */
    data: ContentReportCreateManyInput | ContentReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentReport createManyAndReturn
   */
  export type ContentReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentReports.
     */
    data: ContentReportCreateManyInput | ContentReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentReport update
   */
  export type ContentReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentReport.
     */
    data: XOR<ContentReportUpdateInput, ContentReportUncheckedUpdateInput>
    /**
     * Choose, which ContentReport to update.
     */
    where: ContentReportWhereUniqueInput
  }

  /**
   * ContentReport updateMany
   */
  export type ContentReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentReports.
     */
    data: XOR<ContentReportUpdateManyMutationInput, ContentReportUncheckedUpdateManyInput>
    /**
     * Filter which ContentReports to update
     */
    where?: ContentReportWhereInput
  }

  /**
   * ContentReport upsert
   */
  export type ContentReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentReport to update in case it exists.
     */
    where: ContentReportWhereUniqueInput
    /**
     * In case the ContentReport found by the `where` argument doesn't exist, create a new ContentReport with this data.
     */
    create: XOR<ContentReportCreateInput, ContentReportUncheckedCreateInput>
    /**
     * In case the ContentReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentReportUpdateInput, ContentReportUncheckedUpdateInput>
  }

  /**
   * ContentReport delete
   */
  export type ContentReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
    /**
     * Filter which ContentReport to delete.
     */
    where: ContentReportWhereUniqueInput
  }

  /**
   * ContentReport deleteMany
   */
  export type ContentReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentReports to delete
     */
    where?: ContentReportWhereInput
  }

  /**
   * ContentReport without action
   */
  export type ContentReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentReport
     */
    select?: ContentReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentReportInclude<ExtArgs> | null
  }


  /**
   * Model ContentFlag
   */

  export type AggregateContentFlag = {
    _count: ContentFlagCountAggregateOutputType | null
    _min: ContentFlagMinAggregateOutputType | null
    _max: ContentFlagMaxAggregateOutputType | null
  }

  export type ContentFlagMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    flagType: string | null
    severity: string | null
    details: string | null
    createdAt: Date | null
  }

  export type ContentFlagMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    flagType: string | null
    severity: string | null
    details: string | null
    createdAt: Date | null
  }

  export type ContentFlagCountAggregateOutputType = {
    id: number
    videoId: number
    flagType: number
    severity: number
    details: number
    createdAt: number
    _all: number
  }


  export type ContentFlagMinAggregateInputType = {
    id?: true
    videoId?: true
    flagType?: true
    severity?: true
    details?: true
    createdAt?: true
  }

  export type ContentFlagMaxAggregateInputType = {
    id?: true
    videoId?: true
    flagType?: true
    severity?: true
    details?: true
    createdAt?: true
  }

  export type ContentFlagCountAggregateInputType = {
    id?: true
    videoId?: true
    flagType?: true
    severity?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type ContentFlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentFlag to aggregate.
     */
    where?: ContentFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentFlags to fetch.
     */
    orderBy?: ContentFlagOrderByWithRelationInput | ContentFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentFlags
    **/
    _count?: true | ContentFlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentFlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentFlagMaxAggregateInputType
  }

  export type GetContentFlagAggregateType<T extends ContentFlagAggregateArgs> = {
        [P in keyof T & keyof AggregateContentFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentFlag[P]>
      : GetScalarType<T[P], AggregateContentFlag[P]>
  }




  export type ContentFlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentFlagWhereInput
    orderBy?: ContentFlagOrderByWithAggregationInput | ContentFlagOrderByWithAggregationInput[]
    by: ContentFlagScalarFieldEnum[] | ContentFlagScalarFieldEnum
    having?: ContentFlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentFlagCountAggregateInputType | true
    _min?: ContentFlagMinAggregateInputType
    _max?: ContentFlagMaxAggregateInputType
  }

  export type ContentFlagGroupByOutputType = {
    id: string
    videoId: string
    flagType: string
    severity: string
    details: string | null
    createdAt: Date
    _count: ContentFlagCountAggregateOutputType | null
    _min: ContentFlagMinAggregateOutputType | null
    _max: ContentFlagMaxAggregateOutputType | null
  }

  type GetContentFlagGroupByPayload<T extends ContentFlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentFlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentFlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentFlagGroupByOutputType[P]>
            : GetScalarType<T[P], ContentFlagGroupByOutputType[P]>
        }
      >
    >


  export type ContentFlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    flagType?: boolean
    severity?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contentFlag"]>

  export type ContentFlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    flagType?: boolean
    severity?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contentFlag"]>

  export type ContentFlagSelectScalar = {
    id?: boolean
    videoId?: boolean
    flagType?: boolean
    severity?: boolean
    details?: boolean
    createdAt?: boolean
  }


  export type $ContentFlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentFlag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      flagType: string
      severity: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["contentFlag"]>
    composites: {}
  }

  type ContentFlagGetPayload<S extends boolean | null | undefined | ContentFlagDefaultArgs> = $Result.GetResult<Prisma.$ContentFlagPayload, S>

  type ContentFlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentFlagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentFlagCountAggregateInputType | true
    }

  export interface ContentFlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentFlag'], meta: { name: 'ContentFlag' } }
    /**
     * Find zero or one ContentFlag that matches the filter.
     * @param {ContentFlagFindUniqueArgs} args - Arguments to find a ContentFlag
     * @example
     * // Get one ContentFlag
     * const contentFlag = await prisma.contentFlag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentFlagFindUniqueArgs>(args: SelectSubset<T, ContentFlagFindUniqueArgs<ExtArgs>>): Prisma__ContentFlagClient<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentFlag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentFlagFindUniqueOrThrowArgs} args - Arguments to find a ContentFlag
     * @example
     * // Get one ContentFlag
     * const contentFlag = await prisma.contentFlag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentFlagFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentFlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentFlagClient<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentFlag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFlagFindFirstArgs} args - Arguments to find a ContentFlag
     * @example
     * // Get one ContentFlag
     * const contentFlag = await prisma.contentFlag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentFlagFindFirstArgs>(args?: SelectSubset<T, ContentFlagFindFirstArgs<ExtArgs>>): Prisma__ContentFlagClient<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentFlag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFlagFindFirstOrThrowArgs} args - Arguments to find a ContentFlag
     * @example
     * // Get one ContentFlag
     * const contentFlag = await prisma.contentFlag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentFlagFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentFlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentFlagClient<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentFlags
     * const contentFlags = await prisma.contentFlag.findMany()
     * 
     * // Get first 10 ContentFlags
     * const contentFlags = await prisma.contentFlag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentFlagWithIdOnly = await prisma.contentFlag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentFlagFindManyArgs>(args?: SelectSubset<T, ContentFlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentFlag.
     * @param {ContentFlagCreateArgs} args - Arguments to create a ContentFlag.
     * @example
     * // Create one ContentFlag
     * const ContentFlag = await prisma.contentFlag.create({
     *   data: {
     *     // ... data to create a ContentFlag
     *   }
     * })
     * 
     */
    create<T extends ContentFlagCreateArgs>(args: SelectSubset<T, ContentFlagCreateArgs<ExtArgs>>): Prisma__ContentFlagClient<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentFlags.
     * @param {ContentFlagCreateManyArgs} args - Arguments to create many ContentFlags.
     * @example
     * // Create many ContentFlags
     * const contentFlag = await prisma.contentFlag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentFlagCreateManyArgs>(args?: SelectSubset<T, ContentFlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentFlags and returns the data saved in the database.
     * @param {ContentFlagCreateManyAndReturnArgs} args - Arguments to create many ContentFlags.
     * @example
     * // Create many ContentFlags
     * const contentFlag = await prisma.contentFlag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentFlags and only return the `id`
     * const contentFlagWithIdOnly = await prisma.contentFlag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentFlagCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentFlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentFlag.
     * @param {ContentFlagDeleteArgs} args - Arguments to delete one ContentFlag.
     * @example
     * // Delete one ContentFlag
     * const ContentFlag = await prisma.contentFlag.delete({
     *   where: {
     *     // ... filter to delete one ContentFlag
     *   }
     * })
     * 
     */
    delete<T extends ContentFlagDeleteArgs>(args: SelectSubset<T, ContentFlagDeleteArgs<ExtArgs>>): Prisma__ContentFlagClient<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentFlag.
     * @param {ContentFlagUpdateArgs} args - Arguments to update one ContentFlag.
     * @example
     * // Update one ContentFlag
     * const contentFlag = await prisma.contentFlag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentFlagUpdateArgs>(args: SelectSubset<T, ContentFlagUpdateArgs<ExtArgs>>): Prisma__ContentFlagClient<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentFlags.
     * @param {ContentFlagDeleteManyArgs} args - Arguments to filter ContentFlags to delete.
     * @example
     * // Delete a few ContentFlags
     * const { count } = await prisma.contentFlag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentFlagDeleteManyArgs>(args?: SelectSubset<T, ContentFlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentFlags
     * const contentFlag = await prisma.contentFlag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentFlagUpdateManyArgs>(args: SelectSubset<T, ContentFlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentFlag.
     * @param {ContentFlagUpsertArgs} args - Arguments to update or create a ContentFlag.
     * @example
     * // Update or create a ContentFlag
     * const contentFlag = await prisma.contentFlag.upsert({
     *   create: {
     *     // ... data to create a ContentFlag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentFlag we want to update
     *   }
     * })
     */
    upsert<T extends ContentFlagUpsertArgs>(args: SelectSubset<T, ContentFlagUpsertArgs<ExtArgs>>): Prisma__ContentFlagClient<$Result.GetResult<Prisma.$ContentFlagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFlagCountArgs} args - Arguments to filter ContentFlags to count.
     * @example
     * // Count the number of ContentFlags
     * const count = await prisma.contentFlag.count({
     *   where: {
     *     // ... the filter for the ContentFlags we want to count
     *   }
     * })
    **/
    count<T extends ContentFlagCountArgs>(
      args?: Subset<T, ContentFlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentFlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentFlagAggregateArgs>(args: Subset<T, ContentFlagAggregateArgs>): Prisma.PrismaPromise<GetContentFlagAggregateType<T>>

    /**
     * Group by ContentFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentFlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentFlagGroupByArgs['orderBy'] }
        : { orderBy?: ContentFlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentFlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentFlag model
   */
  readonly fields: ContentFlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentFlag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentFlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentFlag model
   */ 
  interface ContentFlagFieldRefs {
    readonly id: FieldRef<"ContentFlag", 'String'>
    readonly videoId: FieldRef<"ContentFlag", 'String'>
    readonly flagType: FieldRef<"ContentFlag", 'String'>
    readonly severity: FieldRef<"ContentFlag", 'String'>
    readonly details: FieldRef<"ContentFlag", 'String'>
    readonly createdAt: FieldRef<"ContentFlag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentFlag findUnique
   */
  export type ContentFlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
    /**
     * Filter, which ContentFlag to fetch.
     */
    where: ContentFlagWhereUniqueInput
  }

  /**
   * ContentFlag findUniqueOrThrow
   */
  export type ContentFlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
    /**
     * Filter, which ContentFlag to fetch.
     */
    where: ContentFlagWhereUniqueInput
  }

  /**
   * ContentFlag findFirst
   */
  export type ContentFlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
    /**
     * Filter, which ContentFlag to fetch.
     */
    where?: ContentFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentFlags to fetch.
     */
    orderBy?: ContentFlagOrderByWithRelationInput | ContentFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentFlags.
     */
    cursor?: ContentFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentFlags.
     */
    distinct?: ContentFlagScalarFieldEnum | ContentFlagScalarFieldEnum[]
  }

  /**
   * ContentFlag findFirstOrThrow
   */
  export type ContentFlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
    /**
     * Filter, which ContentFlag to fetch.
     */
    where?: ContentFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentFlags to fetch.
     */
    orderBy?: ContentFlagOrderByWithRelationInput | ContentFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentFlags.
     */
    cursor?: ContentFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentFlags.
     */
    distinct?: ContentFlagScalarFieldEnum | ContentFlagScalarFieldEnum[]
  }

  /**
   * ContentFlag findMany
   */
  export type ContentFlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
    /**
     * Filter, which ContentFlags to fetch.
     */
    where?: ContentFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentFlags to fetch.
     */
    orderBy?: ContentFlagOrderByWithRelationInput | ContentFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentFlags.
     */
    cursor?: ContentFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentFlags.
     */
    skip?: number
    distinct?: ContentFlagScalarFieldEnum | ContentFlagScalarFieldEnum[]
  }

  /**
   * ContentFlag create
   */
  export type ContentFlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
    /**
     * The data needed to create a ContentFlag.
     */
    data: XOR<ContentFlagCreateInput, ContentFlagUncheckedCreateInput>
  }

  /**
   * ContentFlag createMany
   */
  export type ContentFlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentFlags.
     */
    data: ContentFlagCreateManyInput | ContentFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentFlag createManyAndReturn
   */
  export type ContentFlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentFlags.
     */
    data: ContentFlagCreateManyInput | ContentFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentFlag update
   */
  export type ContentFlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
    /**
     * The data needed to update a ContentFlag.
     */
    data: XOR<ContentFlagUpdateInput, ContentFlagUncheckedUpdateInput>
    /**
     * Choose, which ContentFlag to update.
     */
    where: ContentFlagWhereUniqueInput
  }

  /**
   * ContentFlag updateMany
   */
  export type ContentFlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentFlags.
     */
    data: XOR<ContentFlagUpdateManyMutationInput, ContentFlagUncheckedUpdateManyInput>
    /**
     * Filter which ContentFlags to update
     */
    where?: ContentFlagWhereInput
  }

  /**
   * ContentFlag upsert
   */
  export type ContentFlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
    /**
     * The filter to search for the ContentFlag to update in case it exists.
     */
    where: ContentFlagWhereUniqueInput
    /**
     * In case the ContentFlag found by the `where` argument doesn't exist, create a new ContentFlag with this data.
     */
    create: XOR<ContentFlagCreateInput, ContentFlagUncheckedCreateInput>
    /**
     * In case the ContentFlag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentFlagUpdateInput, ContentFlagUncheckedUpdateInput>
  }

  /**
   * ContentFlag delete
   */
  export type ContentFlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
    /**
     * Filter which ContentFlag to delete.
     */
    where: ContentFlagWhereUniqueInput
  }

  /**
   * ContentFlag deleteMany
   */
  export type ContentFlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentFlags to delete
     */
    where?: ContentFlagWhereInput
  }

  /**
   * ContentFlag without action
   */
  export type ContentFlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentFlag
     */
    select?: ContentFlagSelect<ExtArgs> | null
  }


  /**
   * Model ModerationActionRecord
   */

  export type AggregateModerationActionRecord = {
    _count: ModerationActionRecordCountAggregateOutputType | null
    _min: ModerationActionRecordMinAggregateOutputType | null
    _max: ModerationActionRecordMaxAggregateOutputType | null
  }

  export type ModerationActionRecordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: $Enums.ModerationAction | null
    reason: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type ModerationActionRecordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: $Enums.ModerationAction | null
    reason: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type ModerationActionRecordCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    reason: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type ModerationActionRecordMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    reason?: true
    expiresAt?: true
    createdAt?: true
  }

  export type ModerationActionRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    reason?: true
    expiresAt?: true
    createdAt?: true
  }

  export type ModerationActionRecordCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    reason?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type ModerationActionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationActionRecord to aggregate.
     */
    where?: ModerationActionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationActionRecords to fetch.
     */
    orderBy?: ModerationActionRecordOrderByWithRelationInput | ModerationActionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModerationActionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationActionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationActionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModerationActionRecords
    **/
    _count?: true | ModerationActionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModerationActionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModerationActionRecordMaxAggregateInputType
  }

  export type GetModerationActionRecordAggregateType<T extends ModerationActionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateModerationActionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModerationActionRecord[P]>
      : GetScalarType<T[P], AggregateModerationActionRecord[P]>
  }




  export type ModerationActionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModerationActionRecordWhereInput
    orderBy?: ModerationActionRecordOrderByWithAggregationInput | ModerationActionRecordOrderByWithAggregationInput[]
    by: ModerationActionRecordScalarFieldEnum[] | ModerationActionRecordScalarFieldEnum
    having?: ModerationActionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModerationActionRecordCountAggregateInputType | true
    _min?: ModerationActionRecordMinAggregateInputType
    _max?: ModerationActionRecordMaxAggregateInputType
  }

  export type ModerationActionRecordGroupByOutputType = {
    id: string
    userId: string
    action: $Enums.ModerationAction
    reason: string
    expiresAt: Date | null
    createdAt: Date
    _count: ModerationActionRecordCountAggregateOutputType | null
    _min: ModerationActionRecordMinAggregateOutputType | null
    _max: ModerationActionRecordMaxAggregateOutputType | null
  }

  type GetModerationActionRecordGroupByPayload<T extends ModerationActionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModerationActionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModerationActionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModerationActionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ModerationActionRecordGroupByOutputType[P]>
        }
      >
    >


  export type ModerationActionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    reason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moderationActionRecord"]>

  export type ModerationActionRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    reason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moderationActionRecord"]>

  export type ModerationActionRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    reason?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type ModerationActionRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ModerationActionRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ModerationActionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModerationActionRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: $Enums.ModerationAction
      reason: string
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["moderationActionRecord"]>
    composites: {}
  }

  type ModerationActionRecordGetPayload<S extends boolean | null | undefined | ModerationActionRecordDefaultArgs> = $Result.GetResult<Prisma.$ModerationActionRecordPayload, S>

  type ModerationActionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModerationActionRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModerationActionRecordCountAggregateInputType | true
    }

  export interface ModerationActionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModerationActionRecord'], meta: { name: 'ModerationActionRecord' } }
    /**
     * Find zero or one ModerationActionRecord that matches the filter.
     * @param {ModerationActionRecordFindUniqueArgs} args - Arguments to find a ModerationActionRecord
     * @example
     * // Get one ModerationActionRecord
     * const moderationActionRecord = await prisma.moderationActionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModerationActionRecordFindUniqueArgs>(args: SelectSubset<T, ModerationActionRecordFindUniqueArgs<ExtArgs>>): Prisma__ModerationActionRecordClient<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModerationActionRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModerationActionRecordFindUniqueOrThrowArgs} args - Arguments to find a ModerationActionRecord
     * @example
     * // Get one ModerationActionRecord
     * const moderationActionRecord = await prisma.moderationActionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModerationActionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ModerationActionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModerationActionRecordClient<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModerationActionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationActionRecordFindFirstArgs} args - Arguments to find a ModerationActionRecord
     * @example
     * // Get one ModerationActionRecord
     * const moderationActionRecord = await prisma.moderationActionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModerationActionRecordFindFirstArgs>(args?: SelectSubset<T, ModerationActionRecordFindFirstArgs<ExtArgs>>): Prisma__ModerationActionRecordClient<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModerationActionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationActionRecordFindFirstOrThrowArgs} args - Arguments to find a ModerationActionRecord
     * @example
     * // Get one ModerationActionRecord
     * const moderationActionRecord = await prisma.moderationActionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModerationActionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ModerationActionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModerationActionRecordClient<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModerationActionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationActionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModerationActionRecords
     * const moderationActionRecords = await prisma.moderationActionRecord.findMany()
     * 
     * // Get first 10 ModerationActionRecords
     * const moderationActionRecords = await prisma.moderationActionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderationActionRecordWithIdOnly = await prisma.moderationActionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModerationActionRecordFindManyArgs>(args?: SelectSubset<T, ModerationActionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModerationActionRecord.
     * @param {ModerationActionRecordCreateArgs} args - Arguments to create a ModerationActionRecord.
     * @example
     * // Create one ModerationActionRecord
     * const ModerationActionRecord = await prisma.moderationActionRecord.create({
     *   data: {
     *     // ... data to create a ModerationActionRecord
     *   }
     * })
     * 
     */
    create<T extends ModerationActionRecordCreateArgs>(args: SelectSubset<T, ModerationActionRecordCreateArgs<ExtArgs>>): Prisma__ModerationActionRecordClient<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModerationActionRecords.
     * @param {ModerationActionRecordCreateManyArgs} args - Arguments to create many ModerationActionRecords.
     * @example
     * // Create many ModerationActionRecords
     * const moderationActionRecord = await prisma.moderationActionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModerationActionRecordCreateManyArgs>(args?: SelectSubset<T, ModerationActionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModerationActionRecords and returns the data saved in the database.
     * @param {ModerationActionRecordCreateManyAndReturnArgs} args - Arguments to create many ModerationActionRecords.
     * @example
     * // Create many ModerationActionRecords
     * const moderationActionRecord = await prisma.moderationActionRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModerationActionRecords and only return the `id`
     * const moderationActionRecordWithIdOnly = await prisma.moderationActionRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModerationActionRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ModerationActionRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModerationActionRecord.
     * @param {ModerationActionRecordDeleteArgs} args - Arguments to delete one ModerationActionRecord.
     * @example
     * // Delete one ModerationActionRecord
     * const ModerationActionRecord = await prisma.moderationActionRecord.delete({
     *   where: {
     *     // ... filter to delete one ModerationActionRecord
     *   }
     * })
     * 
     */
    delete<T extends ModerationActionRecordDeleteArgs>(args: SelectSubset<T, ModerationActionRecordDeleteArgs<ExtArgs>>): Prisma__ModerationActionRecordClient<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModerationActionRecord.
     * @param {ModerationActionRecordUpdateArgs} args - Arguments to update one ModerationActionRecord.
     * @example
     * // Update one ModerationActionRecord
     * const moderationActionRecord = await prisma.moderationActionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModerationActionRecordUpdateArgs>(args: SelectSubset<T, ModerationActionRecordUpdateArgs<ExtArgs>>): Prisma__ModerationActionRecordClient<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModerationActionRecords.
     * @param {ModerationActionRecordDeleteManyArgs} args - Arguments to filter ModerationActionRecords to delete.
     * @example
     * // Delete a few ModerationActionRecords
     * const { count } = await prisma.moderationActionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModerationActionRecordDeleteManyArgs>(args?: SelectSubset<T, ModerationActionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModerationActionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationActionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModerationActionRecords
     * const moderationActionRecord = await prisma.moderationActionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModerationActionRecordUpdateManyArgs>(args: SelectSubset<T, ModerationActionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModerationActionRecord.
     * @param {ModerationActionRecordUpsertArgs} args - Arguments to update or create a ModerationActionRecord.
     * @example
     * // Update or create a ModerationActionRecord
     * const moderationActionRecord = await prisma.moderationActionRecord.upsert({
     *   create: {
     *     // ... data to create a ModerationActionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModerationActionRecord we want to update
     *   }
     * })
     */
    upsert<T extends ModerationActionRecordUpsertArgs>(args: SelectSubset<T, ModerationActionRecordUpsertArgs<ExtArgs>>): Prisma__ModerationActionRecordClient<$Result.GetResult<Prisma.$ModerationActionRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModerationActionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationActionRecordCountArgs} args - Arguments to filter ModerationActionRecords to count.
     * @example
     * // Count the number of ModerationActionRecords
     * const count = await prisma.moderationActionRecord.count({
     *   where: {
     *     // ... the filter for the ModerationActionRecords we want to count
     *   }
     * })
    **/
    count<T extends ModerationActionRecordCountArgs>(
      args?: Subset<T, ModerationActionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModerationActionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModerationActionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationActionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModerationActionRecordAggregateArgs>(args: Subset<T, ModerationActionRecordAggregateArgs>): Prisma.PrismaPromise<GetModerationActionRecordAggregateType<T>>

    /**
     * Group by ModerationActionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModerationActionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModerationActionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModerationActionRecordGroupByArgs['orderBy'] }
        : { orderBy?: ModerationActionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModerationActionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModerationActionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModerationActionRecord model
   */
  readonly fields: ModerationActionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModerationActionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModerationActionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModerationActionRecord model
   */ 
  interface ModerationActionRecordFieldRefs {
    readonly id: FieldRef<"ModerationActionRecord", 'String'>
    readonly userId: FieldRef<"ModerationActionRecord", 'String'>
    readonly action: FieldRef<"ModerationActionRecord", 'ModerationAction'>
    readonly reason: FieldRef<"ModerationActionRecord", 'String'>
    readonly expiresAt: FieldRef<"ModerationActionRecord", 'DateTime'>
    readonly createdAt: FieldRef<"ModerationActionRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModerationActionRecord findUnique
   */
  export type ModerationActionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ModerationActionRecord to fetch.
     */
    where: ModerationActionRecordWhereUniqueInput
  }

  /**
   * ModerationActionRecord findUniqueOrThrow
   */
  export type ModerationActionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ModerationActionRecord to fetch.
     */
    where: ModerationActionRecordWhereUniqueInput
  }

  /**
   * ModerationActionRecord findFirst
   */
  export type ModerationActionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ModerationActionRecord to fetch.
     */
    where?: ModerationActionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationActionRecords to fetch.
     */
    orderBy?: ModerationActionRecordOrderByWithRelationInput | ModerationActionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationActionRecords.
     */
    cursor?: ModerationActionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationActionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationActionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationActionRecords.
     */
    distinct?: ModerationActionRecordScalarFieldEnum | ModerationActionRecordScalarFieldEnum[]
  }

  /**
   * ModerationActionRecord findFirstOrThrow
   */
  export type ModerationActionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ModerationActionRecord to fetch.
     */
    where?: ModerationActionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationActionRecords to fetch.
     */
    orderBy?: ModerationActionRecordOrderByWithRelationInput | ModerationActionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModerationActionRecords.
     */
    cursor?: ModerationActionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationActionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationActionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModerationActionRecords.
     */
    distinct?: ModerationActionRecordScalarFieldEnum | ModerationActionRecordScalarFieldEnum[]
  }

  /**
   * ModerationActionRecord findMany
   */
  export type ModerationActionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ModerationActionRecords to fetch.
     */
    where?: ModerationActionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModerationActionRecords to fetch.
     */
    orderBy?: ModerationActionRecordOrderByWithRelationInput | ModerationActionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModerationActionRecords.
     */
    cursor?: ModerationActionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModerationActionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModerationActionRecords.
     */
    skip?: number
    distinct?: ModerationActionRecordScalarFieldEnum | ModerationActionRecordScalarFieldEnum[]
  }

  /**
   * ModerationActionRecord create
   */
  export type ModerationActionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ModerationActionRecord.
     */
    data: XOR<ModerationActionRecordCreateInput, ModerationActionRecordUncheckedCreateInput>
  }

  /**
   * ModerationActionRecord createMany
   */
  export type ModerationActionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModerationActionRecords.
     */
    data: ModerationActionRecordCreateManyInput | ModerationActionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModerationActionRecord createManyAndReturn
   */
  export type ModerationActionRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModerationActionRecords.
     */
    data: ModerationActionRecordCreateManyInput | ModerationActionRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModerationActionRecord update
   */
  export type ModerationActionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ModerationActionRecord.
     */
    data: XOR<ModerationActionRecordUpdateInput, ModerationActionRecordUncheckedUpdateInput>
    /**
     * Choose, which ModerationActionRecord to update.
     */
    where: ModerationActionRecordWhereUniqueInput
  }

  /**
   * ModerationActionRecord updateMany
   */
  export type ModerationActionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModerationActionRecords.
     */
    data: XOR<ModerationActionRecordUpdateManyMutationInput, ModerationActionRecordUncheckedUpdateManyInput>
    /**
     * Filter which ModerationActionRecords to update
     */
    where?: ModerationActionRecordWhereInput
  }

  /**
   * ModerationActionRecord upsert
   */
  export type ModerationActionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ModerationActionRecord to update in case it exists.
     */
    where: ModerationActionRecordWhereUniqueInput
    /**
     * In case the ModerationActionRecord found by the `where` argument doesn't exist, create a new ModerationActionRecord with this data.
     */
    create: XOR<ModerationActionRecordCreateInput, ModerationActionRecordUncheckedCreateInput>
    /**
     * In case the ModerationActionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModerationActionRecordUpdateInput, ModerationActionRecordUncheckedUpdateInput>
  }

  /**
   * ModerationActionRecord delete
   */
  export type ModerationActionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
    /**
     * Filter which ModerationActionRecord to delete.
     */
    where: ModerationActionRecordWhereUniqueInput
  }

  /**
   * ModerationActionRecord deleteMany
   */
  export type ModerationActionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModerationActionRecords to delete
     */
    where?: ModerationActionRecordWhereInput
  }

  /**
   * ModerationActionRecord without action
   */
  export type ModerationActionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationActionRecord
     */
    select?: ModerationActionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModerationActionRecordInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: $Enums.SubscriptionTier | null
    stripeCustomerId: string | null
    stripeSubId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: $Enums.SubscriptionTier | null
    stripeCustomerId: string | null
    stripeSubId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    tier: number
    stripeCustomerId: number
    stripeSubId: number
    currentPeriodStart: number
    currentPeriodEnd: number
    canceledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    stripeCustomerId?: true
    stripeSubId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    stripeCustomerId?: true
    stripeSubId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    stripeCustomerId?: true
    stripeSubId?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    tier: $Enums.SubscriptionTier
    stripeCustomerId: string | null
    stripeSubId: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    canceledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    stripeCustomerId?: boolean
    stripeSubId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    stripeCustomerId?: boolean
    stripeSubId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    tier?: boolean
    stripeCustomerId?: boolean
    stripeSubId?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tier: $Enums.SubscriptionTier
      stripeCustomerId: string | null
      stripeSubId: string | null
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      canceledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly tier: FieldRef<"Subscription", 'SubscriptionTier'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubId: FieldRef<"Subscription", 'String'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model FeaturedContent
   */

  export type AggregateFeaturedContent = {
    _count: FeaturedContentCountAggregateOutputType | null
    _min: FeaturedContentMinAggregateOutputType | null
    _max: FeaturedContentMaxAggregateOutputType | null
  }

  export type FeaturedContentMinAggregateOutputType = {
    id: string | null
    videoId: string | null
    startsAt: Date | null
    expiresAt: Date | null
    tier: string | null
    createdAt: Date | null
  }

  export type FeaturedContentMaxAggregateOutputType = {
    id: string | null
    videoId: string | null
    startsAt: Date | null
    expiresAt: Date | null
    tier: string | null
    createdAt: Date | null
  }

  export type FeaturedContentCountAggregateOutputType = {
    id: number
    videoId: number
    startsAt: number
    expiresAt: number
    tier: number
    createdAt: number
    _all: number
  }


  export type FeaturedContentMinAggregateInputType = {
    id?: true
    videoId?: true
    startsAt?: true
    expiresAt?: true
    tier?: true
    createdAt?: true
  }

  export type FeaturedContentMaxAggregateInputType = {
    id?: true
    videoId?: true
    startsAt?: true
    expiresAt?: true
    tier?: true
    createdAt?: true
  }

  export type FeaturedContentCountAggregateInputType = {
    id?: true
    videoId?: true
    startsAt?: true
    expiresAt?: true
    tier?: true
    createdAt?: true
    _all?: true
  }

  export type FeaturedContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedContent to aggregate.
     */
    where?: FeaturedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedContents to fetch.
     */
    orderBy?: FeaturedContentOrderByWithRelationInput | FeaturedContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedContents
    **/
    _count?: true | FeaturedContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedContentMaxAggregateInputType
  }

  export type GetFeaturedContentAggregateType<T extends FeaturedContentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedContent[P]>
      : GetScalarType<T[P], AggregateFeaturedContent[P]>
  }




  export type FeaturedContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedContentWhereInput
    orderBy?: FeaturedContentOrderByWithAggregationInput | FeaturedContentOrderByWithAggregationInput[]
    by: FeaturedContentScalarFieldEnum[] | FeaturedContentScalarFieldEnum
    having?: FeaturedContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedContentCountAggregateInputType | true
    _min?: FeaturedContentMinAggregateInputType
    _max?: FeaturedContentMaxAggregateInputType
  }

  export type FeaturedContentGroupByOutputType = {
    id: string
    videoId: string
    startsAt: Date
    expiresAt: Date
    tier: string
    createdAt: Date
    _count: FeaturedContentCountAggregateOutputType | null
    _min: FeaturedContentMinAggregateOutputType | null
    _max: FeaturedContentMaxAggregateOutputType | null
  }

  type GetFeaturedContentGroupByPayload<T extends FeaturedContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedContentGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedContentGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    tier?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["featuredContent"]>

  export type FeaturedContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoId?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    tier?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["featuredContent"]>

  export type FeaturedContentSelectScalar = {
    id?: boolean
    videoId?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    tier?: boolean
    createdAt?: boolean
  }


  export type $FeaturedContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedContent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoId: string
      startsAt: Date
      expiresAt: Date
      tier: string
      createdAt: Date
    }, ExtArgs["result"]["featuredContent"]>
    composites: {}
  }

  type FeaturedContentGetPayload<S extends boolean | null | undefined | FeaturedContentDefaultArgs> = $Result.GetResult<Prisma.$FeaturedContentPayload, S>

  type FeaturedContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeaturedContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeaturedContentCountAggregateInputType | true
    }

  export interface FeaturedContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedContent'], meta: { name: 'FeaturedContent' } }
    /**
     * Find zero or one FeaturedContent that matches the filter.
     * @param {FeaturedContentFindUniqueArgs} args - Arguments to find a FeaturedContent
     * @example
     * // Get one FeaturedContent
     * const featuredContent = await prisma.featuredContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedContentFindUniqueArgs>(args: SelectSubset<T, FeaturedContentFindUniqueArgs<ExtArgs>>): Prisma__FeaturedContentClient<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeaturedContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeaturedContentFindUniqueOrThrowArgs} args - Arguments to find a FeaturedContent
     * @example
     * // Get one FeaturedContent
     * const featuredContent = await prisma.featuredContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedContentFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedContentClient<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeaturedContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedContentFindFirstArgs} args - Arguments to find a FeaturedContent
     * @example
     * // Get one FeaturedContent
     * const featuredContent = await prisma.featuredContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedContentFindFirstArgs>(args?: SelectSubset<T, FeaturedContentFindFirstArgs<ExtArgs>>): Prisma__FeaturedContentClient<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeaturedContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedContentFindFirstOrThrowArgs} args - Arguments to find a FeaturedContent
     * @example
     * // Get one FeaturedContent
     * const featuredContent = await prisma.featuredContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedContentFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedContentClient<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeaturedContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedContents
     * const featuredContents = await prisma.featuredContent.findMany()
     * 
     * // Get first 10 FeaturedContents
     * const featuredContents = await prisma.featuredContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredContentWithIdOnly = await prisma.featuredContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedContentFindManyArgs>(args?: SelectSubset<T, FeaturedContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeaturedContent.
     * @param {FeaturedContentCreateArgs} args - Arguments to create a FeaturedContent.
     * @example
     * // Create one FeaturedContent
     * const FeaturedContent = await prisma.featuredContent.create({
     *   data: {
     *     // ... data to create a FeaturedContent
     *   }
     * })
     * 
     */
    create<T extends FeaturedContentCreateArgs>(args: SelectSubset<T, FeaturedContentCreateArgs<ExtArgs>>): Prisma__FeaturedContentClient<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeaturedContents.
     * @param {FeaturedContentCreateManyArgs} args - Arguments to create many FeaturedContents.
     * @example
     * // Create many FeaturedContents
     * const featuredContent = await prisma.featuredContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedContentCreateManyArgs>(args?: SelectSubset<T, FeaturedContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedContents and returns the data saved in the database.
     * @param {FeaturedContentCreateManyAndReturnArgs} args - Arguments to create many FeaturedContents.
     * @example
     * // Create many FeaturedContents
     * const featuredContent = await prisma.featuredContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedContents and only return the `id`
     * const featuredContentWithIdOnly = await prisma.featuredContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedContentCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeaturedContent.
     * @param {FeaturedContentDeleteArgs} args - Arguments to delete one FeaturedContent.
     * @example
     * // Delete one FeaturedContent
     * const FeaturedContent = await prisma.featuredContent.delete({
     *   where: {
     *     // ... filter to delete one FeaturedContent
     *   }
     * })
     * 
     */
    delete<T extends FeaturedContentDeleteArgs>(args: SelectSubset<T, FeaturedContentDeleteArgs<ExtArgs>>): Prisma__FeaturedContentClient<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeaturedContent.
     * @param {FeaturedContentUpdateArgs} args - Arguments to update one FeaturedContent.
     * @example
     * // Update one FeaturedContent
     * const featuredContent = await prisma.featuredContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedContentUpdateArgs>(args: SelectSubset<T, FeaturedContentUpdateArgs<ExtArgs>>): Prisma__FeaturedContentClient<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeaturedContents.
     * @param {FeaturedContentDeleteManyArgs} args - Arguments to filter FeaturedContents to delete.
     * @example
     * // Delete a few FeaturedContents
     * const { count } = await prisma.featuredContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedContentDeleteManyArgs>(args?: SelectSubset<T, FeaturedContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedContents
     * const featuredContent = await prisma.featuredContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedContentUpdateManyArgs>(args: SelectSubset<T, FeaturedContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeaturedContent.
     * @param {FeaturedContentUpsertArgs} args - Arguments to update or create a FeaturedContent.
     * @example
     * // Update or create a FeaturedContent
     * const featuredContent = await prisma.featuredContent.upsert({
     *   create: {
     *     // ... data to create a FeaturedContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedContent we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedContentUpsertArgs>(args: SelectSubset<T, FeaturedContentUpsertArgs<ExtArgs>>): Prisma__FeaturedContentClient<$Result.GetResult<Prisma.$FeaturedContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeaturedContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedContentCountArgs} args - Arguments to filter FeaturedContents to count.
     * @example
     * // Count the number of FeaturedContents
     * const count = await prisma.featuredContent.count({
     *   where: {
     *     // ... the filter for the FeaturedContents we want to count
     *   }
     * })
    **/
    count<T extends FeaturedContentCountArgs>(
      args?: Subset<T, FeaturedContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedContentAggregateArgs>(args: Subset<T, FeaturedContentAggregateArgs>): Prisma.PrismaPromise<GetFeaturedContentAggregateType<T>>

    /**
     * Group by FeaturedContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedContentGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedContent model
   */
  readonly fields: FeaturedContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedContent model
   */ 
  interface FeaturedContentFieldRefs {
    readonly id: FieldRef<"FeaturedContent", 'String'>
    readonly videoId: FieldRef<"FeaturedContent", 'String'>
    readonly startsAt: FieldRef<"FeaturedContent", 'DateTime'>
    readonly expiresAt: FieldRef<"FeaturedContent", 'DateTime'>
    readonly tier: FieldRef<"FeaturedContent", 'String'>
    readonly createdAt: FieldRef<"FeaturedContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedContent findUnique
   */
  export type FeaturedContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
    /**
     * Filter, which FeaturedContent to fetch.
     */
    where: FeaturedContentWhereUniqueInput
  }

  /**
   * FeaturedContent findUniqueOrThrow
   */
  export type FeaturedContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
    /**
     * Filter, which FeaturedContent to fetch.
     */
    where: FeaturedContentWhereUniqueInput
  }

  /**
   * FeaturedContent findFirst
   */
  export type FeaturedContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
    /**
     * Filter, which FeaturedContent to fetch.
     */
    where?: FeaturedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedContents to fetch.
     */
    orderBy?: FeaturedContentOrderByWithRelationInput | FeaturedContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedContents.
     */
    cursor?: FeaturedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedContents.
     */
    distinct?: FeaturedContentScalarFieldEnum | FeaturedContentScalarFieldEnum[]
  }

  /**
   * FeaturedContent findFirstOrThrow
   */
  export type FeaturedContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
    /**
     * Filter, which FeaturedContent to fetch.
     */
    where?: FeaturedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedContents to fetch.
     */
    orderBy?: FeaturedContentOrderByWithRelationInput | FeaturedContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedContents.
     */
    cursor?: FeaturedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedContents.
     */
    distinct?: FeaturedContentScalarFieldEnum | FeaturedContentScalarFieldEnum[]
  }

  /**
   * FeaturedContent findMany
   */
  export type FeaturedContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
    /**
     * Filter, which FeaturedContents to fetch.
     */
    where?: FeaturedContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedContents to fetch.
     */
    orderBy?: FeaturedContentOrderByWithRelationInput | FeaturedContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedContents.
     */
    cursor?: FeaturedContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedContents.
     */
    skip?: number
    distinct?: FeaturedContentScalarFieldEnum | FeaturedContentScalarFieldEnum[]
  }

  /**
   * FeaturedContent create
   */
  export type FeaturedContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
    /**
     * The data needed to create a FeaturedContent.
     */
    data: XOR<FeaturedContentCreateInput, FeaturedContentUncheckedCreateInput>
  }

  /**
   * FeaturedContent createMany
   */
  export type FeaturedContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedContents.
     */
    data: FeaturedContentCreateManyInput | FeaturedContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedContent createManyAndReturn
   */
  export type FeaturedContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeaturedContents.
     */
    data: FeaturedContentCreateManyInput | FeaturedContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedContent update
   */
  export type FeaturedContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
    /**
     * The data needed to update a FeaturedContent.
     */
    data: XOR<FeaturedContentUpdateInput, FeaturedContentUncheckedUpdateInput>
    /**
     * Choose, which FeaturedContent to update.
     */
    where: FeaturedContentWhereUniqueInput
  }

  /**
   * FeaturedContent updateMany
   */
  export type FeaturedContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedContents.
     */
    data: XOR<FeaturedContentUpdateManyMutationInput, FeaturedContentUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedContents to update
     */
    where?: FeaturedContentWhereInput
  }

  /**
   * FeaturedContent upsert
   */
  export type FeaturedContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
    /**
     * The filter to search for the FeaturedContent to update in case it exists.
     */
    where: FeaturedContentWhereUniqueInput
    /**
     * In case the FeaturedContent found by the `where` argument doesn't exist, create a new FeaturedContent with this data.
     */
    create: XOR<FeaturedContentCreateInput, FeaturedContentUncheckedCreateInput>
    /**
     * In case the FeaturedContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedContentUpdateInput, FeaturedContentUncheckedUpdateInput>
  }

  /**
   * FeaturedContent delete
   */
  export type FeaturedContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
    /**
     * Filter which FeaturedContent to delete.
     */
    where: FeaturedContentWhereUniqueInput
  }

  /**
   * FeaturedContent deleteMany
   */
  export type FeaturedContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedContents to delete
     */
    where?: FeaturedContentWhereInput
  }

  /**
   * FeaturedContent without action
   */
  export type FeaturedContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedContent
     */
    select?: FeaturedContentSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    priority: $Enums.NotificationPriority | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    priority: $Enums.NotificationPriority | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    priority: number
    title: number
    body: number
    data: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    priority?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    priority?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    priority?: true
    title?: true
    body?: true
    data?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    priority: $Enums.NotificationPriority
    title: string
    body: string
    data: JsonValue | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    priority?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      priority: $Enums.NotificationPriority
      title: string
      body: string
      data: Prisma.JsonValue | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly priority: FieldRef<"Notification", 'NotificationPriority'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    pushEnabled: boolean | null
    emailEnabled: boolean | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    pushEnabled: boolean | null
    emailEnabled: boolean | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    pushEnabled: number
    emailEnabled: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    pushEnabled?: true
    emailEnabled?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    pushEnabled?: true
    emailEnabled?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    pushEnabled?: true
    emailEnabled?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    type: string
    pushEnabled: boolean
    emailEnabled: boolean
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    pushEnabled?: boolean
    emailEnabled?: boolean
  }

  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      pushEnabled: boolean
      emailEnabled: boolean
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */ 
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly type: FieldRef<"NotificationPreference", 'String'>
    readonly pushEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly emailEnabled: FieldRef<"NotificationPreference", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model FeedPreference
   */

  export type AggregateFeedPreference = {
    _count: FeedPreferenceCountAggregateOutputType | null
    _min: FeedPreferenceMinAggregateOutputType | null
    _max: FeedPreferenceMaxAggregateOutputType | null
  }

  export type FeedPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    notifyOnMatches: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    notifyOnMatches: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    industries: number
    stages: number
    notifyOnMatches: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    notifyOnMatches?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    notifyOnMatches?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    industries?: true
    stages?: true
    notifyOnMatches?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedPreference to aggregate.
     */
    where?: FeedPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedPreferences to fetch.
     */
    orderBy?: FeedPreferenceOrderByWithRelationInput | FeedPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedPreferences
    **/
    _count?: true | FeedPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedPreferenceMaxAggregateInputType
  }

  export type GetFeedPreferenceAggregateType<T extends FeedPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedPreference[P]>
      : GetScalarType<T[P], AggregateFeedPreference[P]>
  }




  export type FeedPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedPreferenceWhereInput
    orderBy?: FeedPreferenceOrderByWithAggregationInput | FeedPreferenceOrderByWithAggregationInput[]
    by: FeedPreferenceScalarFieldEnum[] | FeedPreferenceScalarFieldEnum
    having?: FeedPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedPreferenceCountAggregateInputType | true
    _min?: FeedPreferenceMinAggregateInputType
    _max?: FeedPreferenceMaxAggregateInputType
  }

  export type FeedPreferenceGroupByOutputType = {
    id: string
    userId: string
    industries: string[]
    stages: string[]
    notifyOnMatches: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeedPreferenceCountAggregateOutputType | null
    _min: FeedPreferenceMinAggregateOutputType | null
    _max: FeedPreferenceMaxAggregateOutputType | null
  }

  type GetFeedPreferenceGroupByPayload<T extends FeedPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], FeedPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type FeedPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    industries?: boolean
    stages?: boolean
    notifyOnMatches?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedPreference"]>

  export type FeedPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    industries?: boolean
    stages?: boolean
    notifyOnMatches?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedPreference"]>

  export type FeedPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    industries?: boolean
    stages?: boolean
    notifyOnMatches?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeedPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      industries: string[]
      stages: string[]
      notifyOnMatches: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedPreference"]>
    composites: {}
  }

  type FeedPreferenceGetPayload<S extends boolean | null | undefined | FeedPreferenceDefaultArgs> = $Result.GetResult<Prisma.$FeedPreferencePayload, S>

  type FeedPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedPreferenceCountAggregateInputType | true
    }

  export interface FeedPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedPreference'], meta: { name: 'FeedPreference' } }
    /**
     * Find zero or one FeedPreference that matches the filter.
     * @param {FeedPreferenceFindUniqueArgs} args - Arguments to find a FeedPreference
     * @example
     * // Get one FeedPreference
     * const feedPreference = await prisma.feedPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedPreferenceFindUniqueArgs>(args: SelectSubset<T, FeedPreferenceFindUniqueArgs<ExtArgs>>): Prisma__FeedPreferenceClient<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeedPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedPreferenceFindUniqueOrThrowArgs} args - Arguments to find a FeedPreference
     * @example
     * // Get one FeedPreference
     * const feedPreference = await prisma.feedPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedPreferenceClient<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeedPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPreferenceFindFirstArgs} args - Arguments to find a FeedPreference
     * @example
     * // Get one FeedPreference
     * const feedPreference = await prisma.feedPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedPreferenceFindFirstArgs>(args?: SelectSubset<T, FeedPreferenceFindFirstArgs<ExtArgs>>): Prisma__FeedPreferenceClient<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeedPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPreferenceFindFirstOrThrowArgs} args - Arguments to find a FeedPreference
     * @example
     * // Get one FeedPreference
     * const feedPreference = await prisma.feedPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedPreferenceClient<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeedPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedPreferences
     * const feedPreferences = await prisma.feedPreference.findMany()
     * 
     * // Get first 10 FeedPreferences
     * const feedPreferences = await prisma.feedPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedPreferenceWithIdOnly = await prisma.feedPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedPreferenceFindManyArgs>(args?: SelectSubset<T, FeedPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeedPreference.
     * @param {FeedPreferenceCreateArgs} args - Arguments to create a FeedPreference.
     * @example
     * // Create one FeedPreference
     * const FeedPreference = await prisma.feedPreference.create({
     *   data: {
     *     // ... data to create a FeedPreference
     *   }
     * })
     * 
     */
    create<T extends FeedPreferenceCreateArgs>(args: SelectSubset<T, FeedPreferenceCreateArgs<ExtArgs>>): Prisma__FeedPreferenceClient<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeedPreferences.
     * @param {FeedPreferenceCreateManyArgs} args - Arguments to create many FeedPreferences.
     * @example
     * // Create many FeedPreferences
     * const feedPreference = await prisma.feedPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedPreferenceCreateManyArgs>(args?: SelectSubset<T, FeedPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedPreferences and returns the data saved in the database.
     * @param {FeedPreferenceCreateManyAndReturnArgs} args - Arguments to create many FeedPreferences.
     * @example
     * // Create many FeedPreferences
     * const feedPreference = await prisma.feedPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedPreferences and only return the `id`
     * const feedPreferenceWithIdOnly = await prisma.feedPreference.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeedPreference.
     * @param {FeedPreferenceDeleteArgs} args - Arguments to delete one FeedPreference.
     * @example
     * // Delete one FeedPreference
     * const FeedPreference = await prisma.feedPreference.delete({
     *   where: {
     *     // ... filter to delete one FeedPreference
     *   }
     * })
     * 
     */
    delete<T extends FeedPreferenceDeleteArgs>(args: SelectSubset<T, FeedPreferenceDeleteArgs<ExtArgs>>): Prisma__FeedPreferenceClient<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeedPreference.
     * @param {FeedPreferenceUpdateArgs} args - Arguments to update one FeedPreference.
     * @example
     * // Update one FeedPreference
     * const feedPreference = await prisma.feedPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedPreferenceUpdateArgs>(args: SelectSubset<T, FeedPreferenceUpdateArgs<ExtArgs>>): Prisma__FeedPreferenceClient<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeedPreferences.
     * @param {FeedPreferenceDeleteManyArgs} args - Arguments to filter FeedPreferences to delete.
     * @example
     * // Delete a few FeedPreferences
     * const { count } = await prisma.feedPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedPreferenceDeleteManyArgs>(args?: SelectSubset<T, FeedPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedPreferences
     * const feedPreference = await prisma.feedPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedPreferenceUpdateManyArgs>(args: SelectSubset<T, FeedPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedPreference.
     * @param {FeedPreferenceUpsertArgs} args - Arguments to update or create a FeedPreference.
     * @example
     * // Update or create a FeedPreference
     * const feedPreference = await prisma.feedPreference.upsert({
     *   create: {
     *     // ... data to create a FeedPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedPreference we want to update
     *   }
     * })
     */
    upsert<T extends FeedPreferenceUpsertArgs>(args: SelectSubset<T, FeedPreferenceUpsertArgs<ExtArgs>>): Prisma__FeedPreferenceClient<$Result.GetResult<Prisma.$FeedPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeedPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPreferenceCountArgs} args - Arguments to filter FeedPreferences to count.
     * @example
     * // Count the number of FeedPreferences
     * const count = await prisma.feedPreference.count({
     *   where: {
     *     // ... the filter for the FeedPreferences we want to count
     *   }
     * })
    **/
    count<T extends FeedPreferenceCountArgs>(
      args?: Subset<T, FeedPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedPreferenceAggregateArgs>(args: Subset<T, FeedPreferenceAggregateArgs>): Prisma.PrismaPromise<GetFeedPreferenceAggregateType<T>>

    /**
     * Group by FeedPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: FeedPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedPreference model
   */
  readonly fields: FeedPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedPreference model
   */ 
  interface FeedPreferenceFieldRefs {
    readonly id: FieldRef<"FeedPreference", 'String'>
    readonly userId: FieldRef<"FeedPreference", 'String'>
    readonly industries: FieldRef<"FeedPreference", 'String[]'>
    readonly stages: FieldRef<"FeedPreference", 'String[]'>
    readonly notifyOnMatches: FieldRef<"FeedPreference", 'Boolean'>
    readonly createdAt: FieldRef<"FeedPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"FeedPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedPreference findUnique
   */
  export type FeedPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which FeedPreference to fetch.
     */
    where: FeedPreferenceWhereUniqueInput
  }

  /**
   * FeedPreference findUniqueOrThrow
   */
  export type FeedPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which FeedPreference to fetch.
     */
    where: FeedPreferenceWhereUniqueInput
  }

  /**
   * FeedPreference findFirst
   */
  export type FeedPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which FeedPreference to fetch.
     */
    where?: FeedPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedPreferences to fetch.
     */
    orderBy?: FeedPreferenceOrderByWithRelationInput | FeedPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedPreferences.
     */
    cursor?: FeedPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedPreferences.
     */
    distinct?: FeedPreferenceScalarFieldEnum | FeedPreferenceScalarFieldEnum[]
  }

  /**
   * FeedPreference findFirstOrThrow
   */
  export type FeedPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which FeedPreference to fetch.
     */
    where?: FeedPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedPreferences to fetch.
     */
    orderBy?: FeedPreferenceOrderByWithRelationInput | FeedPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedPreferences.
     */
    cursor?: FeedPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedPreferences.
     */
    distinct?: FeedPreferenceScalarFieldEnum | FeedPreferenceScalarFieldEnum[]
  }

  /**
   * FeedPreference findMany
   */
  export type FeedPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which FeedPreferences to fetch.
     */
    where?: FeedPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedPreferences to fetch.
     */
    orderBy?: FeedPreferenceOrderByWithRelationInput | FeedPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedPreferences.
     */
    cursor?: FeedPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedPreferences.
     */
    skip?: number
    distinct?: FeedPreferenceScalarFieldEnum | FeedPreferenceScalarFieldEnum[]
  }

  /**
   * FeedPreference create
   */
  export type FeedPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedPreference.
     */
    data: XOR<FeedPreferenceCreateInput, FeedPreferenceUncheckedCreateInput>
  }

  /**
   * FeedPreference createMany
   */
  export type FeedPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedPreferences.
     */
    data: FeedPreferenceCreateManyInput | FeedPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedPreference createManyAndReturn
   */
  export type FeedPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeedPreferences.
     */
    data: FeedPreferenceCreateManyInput | FeedPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedPreference update
   */
  export type FeedPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedPreference.
     */
    data: XOR<FeedPreferenceUpdateInput, FeedPreferenceUncheckedUpdateInput>
    /**
     * Choose, which FeedPreference to update.
     */
    where: FeedPreferenceWhereUniqueInput
  }

  /**
   * FeedPreference updateMany
   */
  export type FeedPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedPreferences.
     */
    data: XOR<FeedPreferenceUpdateManyMutationInput, FeedPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which FeedPreferences to update
     */
    where?: FeedPreferenceWhereInput
  }

  /**
   * FeedPreference upsert
   */
  export type FeedPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedPreference to update in case it exists.
     */
    where: FeedPreferenceWhereUniqueInput
    /**
     * In case the FeedPreference found by the `where` argument doesn't exist, create a new FeedPreference with this data.
     */
    create: XOR<FeedPreferenceCreateInput, FeedPreferenceUncheckedCreateInput>
    /**
     * In case the FeedPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedPreferenceUpdateInput, FeedPreferenceUncheckedUpdateInput>
  }

  /**
   * FeedPreference delete
   */
  export type FeedPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
    /**
     * Filter which FeedPreference to delete.
     */
    where: FeedPreferenceWhereUniqueInput
  }

  /**
   * FeedPreference deleteMany
   */
  export type FeedPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedPreferences to delete
     */
    where?: FeedPreferenceWhereInput
  }

  /**
   * FeedPreference without action
   */
  export type FeedPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPreference
     */
    select?: FeedPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model SearchHistory
   */

  export type AggregateSearchHistory = {
    _count: SearchHistoryCountAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  export type SearchHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    query: string | null
    createdAt: Date | null
  }

  export type SearchHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    query: string | null
    createdAt: Date | null
  }

  export type SearchHistoryCountAggregateOutputType = {
    id: number
    userId: number
    query: number
    filters: number
    createdAt: number
    _all: number
  }


  export type SearchHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    query?: true
    createdAt?: true
  }

  export type SearchHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    query?: true
    createdAt?: true
  }

  export type SearchHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    query?: true
    filters?: true
    createdAt?: true
    _all?: true
  }

  export type SearchHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistory to aggregate.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchHistories
    **/
    _count?: true | SearchHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type GetSearchHistoryAggregateType<T extends SearchHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchHistory[P]>
      : GetScalarType<T[P], AggregateSearchHistory[P]>
  }




  export type SearchHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithAggregationInput | SearchHistoryOrderByWithAggregationInput[]
    by: SearchHistoryScalarFieldEnum[] | SearchHistoryScalarFieldEnum
    having?: SearchHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchHistoryCountAggregateInputType | true
    _min?: SearchHistoryMinAggregateInputType
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type SearchHistoryGroupByOutputType = {
    id: string
    userId: string
    query: string
    filters: JsonValue | null
    createdAt: Date
    _count: SearchHistoryCountAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  type GetSearchHistoryGroupByPayload<T extends SearchHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SearchHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    query?: boolean
    filters?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    query?: boolean
    filters?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    query?: boolean
    filters?: boolean
    createdAt?: boolean
  }

  export type SearchHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SearchHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      query: string
      filters: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["searchHistory"]>
    composites: {}
  }

  type SearchHistoryGetPayload<S extends boolean | null | undefined | SearchHistoryDefaultArgs> = $Result.GetResult<Prisma.$SearchHistoryPayload, S>

  type SearchHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SearchHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SearchHistoryCountAggregateInputType | true
    }

  export interface SearchHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchHistory'], meta: { name: 'SearchHistory' } }
    /**
     * Find zero or one SearchHistory that matches the filter.
     * @param {SearchHistoryFindUniqueArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchHistoryFindUniqueArgs>(args: SelectSubset<T, SearchHistoryFindUniqueArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SearchHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SearchHistoryFindUniqueOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SearchHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchHistoryFindFirstArgs>(args?: SelectSubset<T, SearchHistoryFindFirstArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SearchHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SearchHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany()
     * 
     * // Get first 10 SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchHistoryFindManyArgs>(args?: SelectSubset<T, SearchHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SearchHistory.
     * @param {SearchHistoryCreateArgs} args - Arguments to create a SearchHistory.
     * @example
     * // Create one SearchHistory
     * const SearchHistory = await prisma.searchHistory.create({
     *   data: {
     *     // ... data to create a SearchHistory
     *   }
     * })
     * 
     */
    create<T extends SearchHistoryCreateArgs>(args: SelectSubset<T, SearchHistoryCreateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SearchHistories.
     * @param {SearchHistoryCreateManyArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchHistoryCreateManyArgs>(args?: SelectSubset<T, SearchHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchHistories and returns the data saved in the database.
     * @param {SearchHistoryCreateManyAndReturnArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchHistories and only return the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SearchHistory.
     * @param {SearchHistoryDeleteArgs} args - Arguments to delete one SearchHistory.
     * @example
     * // Delete one SearchHistory
     * const SearchHistory = await prisma.searchHistory.delete({
     *   where: {
     *     // ... filter to delete one SearchHistory
     *   }
     * })
     * 
     */
    delete<T extends SearchHistoryDeleteArgs>(args: SelectSubset<T, SearchHistoryDeleteArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SearchHistory.
     * @param {SearchHistoryUpdateArgs} args - Arguments to update one SearchHistory.
     * @example
     * // Update one SearchHistory
     * const searchHistory = await prisma.searchHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchHistoryUpdateArgs>(args: SelectSubset<T, SearchHistoryUpdateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SearchHistories.
     * @param {SearchHistoryDeleteManyArgs} args - Arguments to filter SearchHistories to delete.
     * @example
     * // Delete a few SearchHistories
     * const { count } = await prisma.searchHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchHistoryDeleteManyArgs>(args?: SelectSubset<T, SearchHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchHistoryUpdateManyArgs>(args: SelectSubset<T, SearchHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchHistory.
     * @param {SearchHistoryUpsertArgs} args - Arguments to update or create a SearchHistory.
     * @example
     * // Update or create a SearchHistory
     * const searchHistory = await prisma.searchHistory.upsert({
     *   create: {
     *     // ... data to create a SearchHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchHistory we want to update
     *   }
     * })
     */
    upsert<T extends SearchHistoryUpsertArgs>(args: SelectSubset<T, SearchHistoryUpsertArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryCountArgs} args - Arguments to filter SearchHistories to count.
     * @example
     * // Count the number of SearchHistories
     * const count = await prisma.searchHistory.count({
     *   where: {
     *     // ... the filter for the SearchHistories we want to count
     *   }
     * })
    **/
    count<T extends SearchHistoryCountArgs>(
      args?: Subset<T, SearchHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchHistoryAggregateArgs>(args: Subset<T, SearchHistoryAggregateArgs>): Prisma.PrismaPromise<GetSearchHistoryAggregateType<T>>

    /**
     * Group by SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SearchHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchHistory model
   */
  readonly fields: SearchHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchHistory model
   */ 
  interface SearchHistoryFieldRefs {
    readonly id: FieldRef<"SearchHistory", 'String'>
    readonly userId: FieldRef<"SearchHistory", 'String'>
    readonly query: FieldRef<"SearchHistory", 'String'>
    readonly filters: FieldRef<"SearchHistory", 'Json'>
    readonly createdAt: FieldRef<"SearchHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchHistory findUnique
   */
  export type SearchHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findUniqueOrThrow
   */
  export type SearchHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findFirst
   */
  export type SearchHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findFirstOrThrow
   */
  export type SearchHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findMany
   */
  export type SearchHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistories to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory create
   */
  export type SearchHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchHistory.
     */
    data: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
  }

  /**
   * SearchHistory createMany
   */
  export type SearchHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchHistory createManyAndReturn
   */
  export type SearchHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchHistory update
   */
  export type SearchHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchHistory.
     */
    data: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
    /**
     * Choose, which SearchHistory to update.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory updateMany
   */
  export type SearchHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
  }

  /**
   * SearchHistory upsert
   */
  export type SearchHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchHistory to update in case it exists.
     */
    where: SearchHistoryWhereUniqueInput
    /**
     * In case the SearchHistory found by the `where` argument doesn't exist, create a new SearchHistory with this data.
     */
    create: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
    /**
     * In case the SearchHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
  }

  /**
   * SearchHistory delete
   */
  export type SearchHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter which SearchHistory to delete.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory deleteMany
   */
  export type SearchHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistories to delete
     */
    where?: SearchHistoryWhereInput
  }

  /**
   * SearchHistory without action
   */
  export type SearchHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
  }


  /**
   * Model OnboardingProgress
   */

  export type AggregateOnboardingProgress = {
    _count: OnboardingProgressCountAggregateOutputType | null
    _avg: OnboardingProgressAvgAggregateOutputType | null
    _sum: OnboardingProgressSumAggregateOutputType | null
    _min: OnboardingProgressMinAggregateOutputType | null
    _max: OnboardingProgressMaxAggregateOutputType | null
  }

  export type OnboardingProgressAvgAggregateOutputType = {
    step: number | null
  }

  export type OnboardingProgressSumAggregateOutputType = {
    step: number | null
  }

  export type OnboardingProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    step: number | null
    completed: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OnboardingProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    step: number | null
    completed: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OnboardingProgressCountAggregateOutputType = {
    id: number
    userId: number
    step: number
    completed: number
    data: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OnboardingProgressAvgAggregateInputType = {
    step?: true
  }

  export type OnboardingProgressSumAggregateInputType = {
    step?: true
  }

  export type OnboardingProgressMinAggregateInputType = {
    id?: true
    userId?: true
    step?: true
    completed?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OnboardingProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    step?: true
    completed?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OnboardingProgressCountAggregateInputType = {
    id?: true
    userId?: true
    step?: true
    completed?: true
    data?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OnboardingProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingProgress to aggregate.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnboardingProgresses
    **/
    _count?: true | OnboardingProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OnboardingProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OnboardingProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnboardingProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnboardingProgressMaxAggregateInputType
  }

  export type GetOnboardingProgressAggregateType<T extends OnboardingProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateOnboardingProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnboardingProgress[P]>
      : GetScalarType<T[P], AggregateOnboardingProgress[P]>
  }




  export type OnboardingProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingProgressWhereInput
    orderBy?: OnboardingProgressOrderByWithAggregationInput | OnboardingProgressOrderByWithAggregationInput[]
    by: OnboardingProgressScalarFieldEnum[] | OnboardingProgressScalarFieldEnum
    having?: OnboardingProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnboardingProgressCountAggregateInputType | true
    _avg?: OnboardingProgressAvgAggregateInputType
    _sum?: OnboardingProgressSumAggregateInputType
    _min?: OnboardingProgressMinAggregateInputType
    _max?: OnboardingProgressMaxAggregateInputType
  }

  export type OnboardingProgressGroupByOutputType = {
    id: string
    userId: string
    step: number
    completed: boolean
    data: JsonValue | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OnboardingProgressCountAggregateOutputType | null
    _avg: OnboardingProgressAvgAggregateOutputType | null
    _sum: OnboardingProgressSumAggregateOutputType | null
    _min: OnboardingProgressMinAggregateOutputType | null
    _max: OnboardingProgressMaxAggregateOutputType | null
  }

  type GetOnboardingProgressGroupByPayload<T extends OnboardingProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnboardingProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnboardingProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnboardingProgressGroupByOutputType[P]>
            : GetScalarType<T[P], OnboardingProgressGroupByOutputType[P]>
        }
      >
    >


  export type OnboardingProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    step?: boolean
    completed?: boolean
    data?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingProgress"]>

  export type OnboardingProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    step?: boolean
    completed?: boolean
    data?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingProgress"]>

  export type OnboardingProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    step?: boolean
    completed?: boolean
    data?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OnboardingProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OnboardingProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OnboardingProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnboardingProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      step: number
      completed: boolean
      data: Prisma.JsonValue | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["onboardingProgress"]>
    composites: {}
  }

  type OnboardingProgressGetPayload<S extends boolean | null | undefined | OnboardingProgressDefaultArgs> = $Result.GetResult<Prisma.$OnboardingProgressPayload, S>

  type OnboardingProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OnboardingProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OnboardingProgressCountAggregateInputType | true
    }

  export interface OnboardingProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnboardingProgress'], meta: { name: 'OnboardingProgress' } }
    /**
     * Find zero or one OnboardingProgress that matches the filter.
     * @param {OnboardingProgressFindUniqueArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnboardingProgressFindUniqueArgs>(args: SelectSubset<T, OnboardingProgressFindUniqueArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OnboardingProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OnboardingProgressFindUniqueOrThrowArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnboardingProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, OnboardingProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OnboardingProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressFindFirstArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnboardingProgressFindFirstArgs>(args?: SelectSubset<T, OnboardingProgressFindFirstArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OnboardingProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressFindFirstOrThrowArgs} args - Arguments to find a OnboardingProgress
     * @example
     * // Get one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnboardingProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, OnboardingProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OnboardingProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnboardingProgresses
     * const onboardingProgresses = await prisma.onboardingProgress.findMany()
     * 
     * // Get first 10 OnboardingProgresses
     * const onboardingProgresses = await prisma.onboardingProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onboardingProgressWithIdOnly = await prisma.onboardingProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnboardingProgressFindManyArgs>(args?: SelectSubset<T, OnboardingProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OnboardingProgress.
     * @param {OnboardingProgressCreateArgs} args - Arguments to create a OnboardingProgress.
     * @example
     * // Create one OnboardingProgress
     * const OnboardingProgress = await prisma.onboardingProgress.create({
     *   data: {
     *     // ... data to create a OnboardingProgress
     *   }
     * })
     * 
     */
    create<T extends OnboardingProgressCreateArgs>(args: SelectSubset<T, OnboardingProgressCreateArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OnboardingProgresses.
     * @param {OnboardingProgressCreateManyArgs} args - Arguments to create many OnboardingProgresses.
     * @example
     * // Create many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnboardingProgressCreateManyArgs>(args?: SelectSubset<T, OnboardingProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnboardingProgresses and returns the data saved in the database.
     * @param {OnboardingProgressCreateManyAndReturnArgs} args - Arguments to create many OnboardingProgresses.
     * @example
     * // Create many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnboardingProgresses and only return the `id`
     * const onboardingProgressWithIdOnly = await prisma.onboardingProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnboardingProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, OnboardingProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OnboardingProgress.
     * @param {OnboardingProgressDeleteArgs} args - Arguments to delete one OnboardingProgress.
     * @example
     * // Delete one OnboardingProgress
     * const OnboardingProgress = await prisma.onboardingProgress.delete({
     *   where: {
     *     // ... filter to delete one OnboardingProgress
     *   }
     * })
     * 
     */
    delete<T extends OnboardingProgressDeleteArgs>(args: SelectSubset<T, OnboardingProgressDeleteArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OnboardingProgress.
     * @param {OnboardingProgressUpdateArgs} args - Arguments to update one OnboardingProgress.
     * @example
     * // Update one OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnboardingProgressUpdateArgs>(args: SelectSubset<T, OnboardingProgressUpdateArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OnboardingProgresses.
     * @param {OnboardingProgressDeleteManyArgs} args - Arguments to filter OnboardingProgresses to delete.
     * @example
     * // Delete a few OnboardingProgresses
     * const { count } = await prisma.onboardingProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnboardingProgressDeleteManyArgs>(args?: SelectSubset<T, OnboardingProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnboardingProgresses
     * const onboardingProgress = await prisma.onboardingProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnboardingProgressUpdateManyArgs>(args: SelectSubset<T, OnboardingProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OnboardingProgress.
     * @param {OnboardingProgressUpsertArgs} args - Arguments to update or create a OnboardingProgress.
     * @example
     * // Update or create a OnboardingProgress
     * const onboardingProgress = await prisma.onboardingProgress.upsert({
     *   create: {
     *     // ... data to create a OnboardingProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnboardingProgress we want to update
     *   }
     * })
     */
    upsert<T extends OnboardingProgressUpsertArgs>(args: SelectSubset<T, OnboardingProgressUpsertArgs<ExtArgs>>): Prisma__OnboardingProgressClient<$Result.GetResult<Prisma.$OnboardingProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OnboardingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressCountArgs} args - Arguments to filter OnboardingProgresses to count.
     * @example
     * // Count the number of OnboardingProgresses
     * const count = await prisma.onboardingProgress.count({
     *   where: {
     *     // ... the filter for the OnboardingProgresses we want to count
     *   }
     * })
    **/
    count<T extends OnboardingProgressCountArgs>(
      args?: Subset<T, OnboardingProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnboardingProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnboardingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnboardingProgressAggregateArgs>(args: Subset<T, OnboardingProgressAggregateArgs>): Prisma.PrismaPromise<GetOnboardingProgressAggregateType<T>>

    /**
     * Group by OnboardingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnboardingProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnboardingProgressGroupByArgs['orderBy'] }
        : { orderBy?: OnboardingProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnboardingProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnboardingProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnboardingProgress model
   */
  readonly fields: OnboardingProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnboardingProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnboardingProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnboardingProgress model
   */ 
  interface OnboardingProgressFieldRefs {
    readonly id: FieldRef<"OnboardingProgress", 'String'>
    readonly userId: FieldRef<"OnboardingProgress", 'String'>
    readonly step: FieldRef<"OnboardingProgress", 'Int'>
    readonly completed: FieldRef<"OnboardingProgress", 'Boolean'>
    readonly data: FieldRef<"OnboardingProgress", 'Json'>
    readonly completedAt: FieldRef<"OnboardingProgress", 'DateTime'>
    readonly createdAt: FieldRef<"OnboardingProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"OnboardingProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnboardingProgress findUnique
   */
  export type OnboardingProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress findUniqueOrThrow
   */
  export type OnboardingProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress findFirst
   */
  export type OnboardingProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingProgresses.
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingProgresses.
     */
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * OnboardingProgress findFirstOrThrow
   */
  export type OnboardingProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgress to fetch.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingProgresses.
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingProgresses.
     */
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * OnboardingProgress findMany
   */
  export type OnboardingProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingProgresses to fetch.
     */
    where?: OnboardingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingProgresses to fetch.
     */
    orderBy?: OnboardingProgressOrderByWithRelationInput | OnboardingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnboardingProgresses.
     */
    cursor?: OnboardingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingProgresses.
     */
    skip?: number
    distinct?: OnboardingProgressScalarFieldEnum | OnboardingProgressScalarFieldEnum[]
  }

  /**
   * OnboardingProgress create
   */
  export type OnboardingProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a OnboardingProgress.
     */
    data: XOR<OnboardingProgressCreateInput, OnboardingProgressUncheckedCreateInput>
  }

  /**
   * OnboardingProgress createMany
   */
  export type OnboardingProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnboardingProgresses.
     */
    data: OnboardingProgressCreateManyInput | OnboardingProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnboardingProgress createManyAndReturn
   */
  export type OnboardingProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OnboardingProgresses.
     */
    data: OnboardingProgressCreateManyInput | OnboardingProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingProgress update
   */
  export type OnboardingProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a OnboardingProgress.
     */
    data: XOR<OnboardingProgressUpdateInput, OnboardingProgressUncheckedUpdateInput>
    /**
     * Choose, which OnboardingProgress to update.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress updateMany
   */
  export type OnboardingProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnboardingProgresses.
     */
    data: XOR<OnboardingProgressUpdateManyMutationInput, OnboardingProgressUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingProgresses to update
     */
    where?: OnboardingProgressWhereInput
  }

  /**
   * OnboardingProgress upsert
   */
  export type OnboardingProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the OnboardingProgress to update in case it exists.
     */
    where: OnboardingProgressWhereUniqueInput
    /**
     * In case the OnboardingProgress found by the `where` argument doesn't exist, create a new OnboardingProgress with this data.
     */
    create: XOR<OnboardingProgressCreateInput, OnboardingProgressUncheckedCreateInput>
    /**
     * In case the OnboardingProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnboardingProgressUpdateInput, OnboardingProgressUncheckedUpdateInput>
  }

  /**
   * OnboardingProgress delete
   */
  export type OnboardingProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
    /**
     * Filter which OnboardingProgress to delete.
     */
    where: OnboardingProgressWhereUniqueInput
  }

  /**
   * OnboardingProgress deleteMany
   */
  export type OnboardingProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingProgresses to delete
     */
    where?: OnboardingProgressWhereInput
  }

  /**
   * OnboardingProgress without action
   */
  export type OnboardingProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingProgress
     */
    select?: OnboardingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingProgressInclude<ExtArgs> | null
  }


  /**
   * Model AccountTypeChange
   */

  export type AggregateAccountTypeChange = {
    _count: AccountTypeChangeCountAggregateOutputType | null
    _min: AccountTypeChangeMinAggregateOutputType | null
    _max: AccountTypeChangeMaxAggregateOutputType | null
  }

  export type AccountTypeChangeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fromType: $Enums.AccountType | null
    toType: $Enums.AccountType | null
    changedAt: Date | null
  }

  export type AccountTypeChangeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fromType: $Enums.AccountType | null
    toType: $Enums.AccountType | null
    changedAt: Date | null
  }

  export type AccountTypeChangeCountAggregateOutputType = {
    id: number
    userId: number
    fromType: number
    toType: number
    changedAt: number
    _all: number
  }


  export type AccountTypeChangeMinAggregateInputType = {
    id?: true
    userId?: true
    fromType?: true
    toType?: true
    changedAt?: true
  }

  export type AccountTypeChangeMaxAggregateInputType = {
    id?: true
    userId?: true
    fromType?: true
    toType?: true
    changedAt?: true
  }

  export type AccountTypeChangeCountAggregateInputType = {
    id?: true
    userId?: true
    fromType?: true
    toType?: true
    changedAt?: true
    _all?: true
  }

  export type AccountTypeChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountTypeChange to aggregate.
     */
    where?: AccountTypeChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountTypeChanges to fetch.
     */
    orderBy?: AccountTypeChangeOrderByWithRelationInput | AccountTypeChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountTypeChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountTypeChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountTypeChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountTypeChanges
    **/
    _count?: true | AccountTypeChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountTypeChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountTypeChangeMaxAggregateInputType
  }

  export type GetAccountTypeChangeAggregateType<T extends AccountTypeChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountTypeChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountTypeChange[P]>
      : GetScalarType<T[P], AggregateAccountTypeChange[P]>
  }




  export type AccountTypeChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountTypeChangeWhereInput
    orderBy?: AccountTypeChangeOrderByWithAggregationInput | AccountTypeChangeOrderByWithAggregationInput[]
    by: AccountTypeChangeScalarFieldEnum[] | AccountTypeChangeScalarFieldEnum
    having?: AccountTypeChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountTypeChangeCountAggregateInputType | true
    _min?: AccountTypeChangeMinAggregateInputType
    _max?: AccountTypeChangeMaxAggregateInputType
  }

  export type AccountTypeChangeGroupByOutputType = {
    id: string
    userId: string
    fromType: $Enums.AccountType
    toType: $Enums.AccountType
    changedAt: Date
    _count: AccountTypeChangeCountAggregateOutputType | null
    _min: AccountTypeChangeMinAggregateOutputType | null
    _max: AccountTypeChangeMaxAggregateOutputType | null
  }

  type GetAccountTypeChangeGroupByPayload<T extends AccountTypeChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountTypeChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountTypeChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountTypeChangeGroupByOutputType[P]>
            : GetScalarType<T[P], AccountTypeChangeGroupByOutputType[P]>
        }
      >
    >


  export type AccountTypeChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fromType?: boolean
    toType?: boolean
    changedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountTypeChange"]>

  export type AccountTypeChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fromType?: boolean
    toType?: boolean
    changedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountTypeChange"]>

  export type AccountTypeChangeSelectScalar = {
    id?: boolean
    userId?: boolean
    fromType?: boolean
    toType?: boolean
    changedAt?: boolean
  }

  export type AccountTypeChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountTypeChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountTypeChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountTypeChange"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      fromType: $Enums.AccountType
      toType: $Enums.AccountType
      changedAt: Date
    }, ExtArgs["result"]["accountTypeChange"]>
    composites: {}
  }

  type AccountTypeChangeGetPayload<S extends boolean | null | undefined | AccountTypeChangeDefaultArgs> = $Result.GetResult<Prisma.$AccountTypeChangePayload, S>

  type AccountTypeChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountTypeChangeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountTypeChangeCountAggregateInputType | true
    }

  export interface AccountTypeChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountTypeChange'], meta: { name: 'AccountTypeChange' } }
    /**
     * Find zero or one AccountTypeChange that matches the filter.
     * @param {AccountTypeChangeFindUniqueArgs} args - Arguments to find a AccountTypeChange
     * @example
     * // Get one AccountTypeChange
     * const accountTypeChange = await prisma.accountTypeChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountTypeChangeFindUniqueArgs>(args: SelectSubset<T, AccountTypeChangeFindUniqueArgs<ExtArgs>>): Prisma__AccountTypeChangeClient<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccountTypeChange that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountTypeChangeFindUniqueOrThrowArgs} args - Arguments to find a AccountTypeChange
     * @example
     * // Get one AccountTypeChange
     * const accountTypeChange = await prisma.accountTypeChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountTypeChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountTypeChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountTypeChangeClient<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccountTypeChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountTypeChangeFindFirstArgs} args - Arguments to find a AccountTypeChange
     * @example
     * // Get one AccountTypeChange
     * const accountTypeChange = await prisma.accountTypeChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountTypeChangeFindFirstArgs>(args?: SelectSubset<T, AccountTypeChangeFindFirstArgs<ExtArgs>>): Prisma__AccountTypeChangeClient<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccountTypeChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountTypeChangeFindFirstOrThrowArgs} args - Arguments to find a AccountTypeChange
     * @example
     * // Get one AccountTypeChange
     * const accountTypeChange = await prisma.accountTypeChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountTypeChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountTypeChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountTypeChangeClient<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccountTypeChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountTypeChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountTypeChanges
     * const accountTypeChanges = await prisma.accountTypeChange.findMany()
     * 
     * // Get first 10 AccountTypeChanges
     * const accountTypeChanges = await prisma.accountTypeChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountTypeChangeWithIdOnly = await prisma.accountTypeChange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountTypeChangeFindManyArgs>(args?: SelectSubset<T, AccountTypeChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccountTypeChange.
     * @param {AccountTypeChangeCreateArgs} args - Arguments to create a AccountTypeChange.
     * @example
     * // Create one AccountTypeChange
     * const AccountTypeChange = await prisma.accountTypeChange.create({
     *   data: {
     *     // ... data to create a AccountTypeChange
     *   }
     * })
     * 
     */
    create<T extends AccountTypeChangeCreateArgs>(args: SelectSubset<T, AccountTypeChangeCreateArgs<ExtArgs>>): Prisma__AccountTypeChangeClient<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccountTypeChanges.
     * @param {AccountTypeChangeCreateManyArgs} args - Arguments to create many AccountTypeChanges.
     * @example
     * // Create many AccountTypeChanges
     * const accountTypeChange = await prisma.accountTypeChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountTypeChangeCreateManyArgs>(args?: SelectSubset<T, AccountTypeChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountTypeChanges and returns the data saved in the database.
     * @param {AccountTypeChangeCreateManyAndReturnArgs} args - Arguments to create many AccountTypeChanges.
     * @example
     * // Create many AccountTypeChanges
     * const accountTypeChange = await prisma.accountTypeChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountTypeChanges and only return the `id`
     * const accountTypeChangeWithIdOnly = await prisma.accountTypeChange.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountTypeChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountTypeChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccountTypeChange.
     * @param {AccountTypeChangeDeleteArgs} args - Arguments to delete one AccountTypeChange.
     * @example
     * // Delete one AccountTypeChange
     * const AccountTypeChange = await prisma.accountTypeChange.delete({
     *   where: {
     *     // ... filter to delete one AccountTypeChange
     *   }
     * })
     * 
     */
    delete<T extends AccountTypeChangeDeleteArgs>(args: SelectSubset<T, AccountTypeChangeDeleteArgs<ExtArgs>>): Prisma__AccountTypeChangeClient<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccountTypeChange.
     * @param {AccountTypeChangeUpdateArgs} args - Arguments to update one AccountTypeChange.
     * @example
     * // Update one AccountTypeChange
     * const accountTypeChange = await prisma.accountTypeChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountTypeChangeUpdateArgs>(args: SelectSubset<T, AccountTypeChangeUpdateArgs<ExtArgs>>): Prisma__AccountTypeChangeClient<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccountTypeChanges.
     * @param {AccountTypeChangeDeleteManyArgs} args - Arguments to filter AccountTypeChanges to delete.
     * @example
     * // Delete a few AccountTypeChanges
     * const { count } = await prisma.accountTypeChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountTypeChangeDeleteManyArgs>(args?: SelectSubset<T, AccountTypeChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountTypeChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountTypeChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountTypeChanges
     * const accountTypeChange = await prisma.accountTypeChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountTypeChangeUpdateManyArgs>(args: SelectSubset<T, AccountTypeChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountTypeChange.
     * @param {AccountTypeChangeUpsertArgs} args - Arguments to update or create a AccountTypeChange.
     * @example
     * // Update or create a AccountTypeChange
     * const accountTypeChange = await prisma.accountTypeChange.upsert({
     *   create: {
     *     // ... data to create a AccountTypeChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountTypeChange we want to update
     *   }
     * })
     */
    upsert<T extends AccountTypeChangeUpsertArgs>(args: SelectSubset<T, AccountTypeChangeUpsertArgs<ExtArgs>>): Prisma__AccountTypeChangeClient<$Result.GetResult<Prisma.$AccountTypeChangePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccountTypeChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountTypeChangeCountArgs} args - Arguments to filter AccountTypeChanges to count.
     * @example
     * // Count the number of AccountTypeChanges
     * const count = await prisma.accountTypeChange.count({
     *   where: {
     *     // ... the filter for the AccountTypeChanges we want to count
     *   }
     * })
    **/
    count<T extends AccountTypeChangeCountArgs>(
      args?: Subset<T, AccountTypeChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountTypeChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountTypeChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountTypeChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountTypeChangeAggregateArgs>(args: Subset<T, AccountTypeChangeAggregateArgs>): Prisma.PrismaPromise<GetAccountTypeChangeAggregateType<T>>

    /**
     * Group by AccountTypeChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountTypeChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountTypeChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountTypeChangeGroupByArgs['orderBy'] }
        : { orderBy?: AccountTypeChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountTypeChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountTypeChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountTypeChange model
   */
  readonly fields: AccountTypeChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountTypeChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountTypeChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountTypeChange model
   */ 
  interface AccountTypeChangeFieldRefs {
    readonly id: FieldRef<"AccountTypeChange", 'String'>
    readonly userId: FieldRef<"AccountTypeChange", 'String'>
    readonly fromType: FieldRef<"AccountTypeChange", 'AccountType'>
    readonly toType: FieldRef<"AccountTypeChange", 'AccountType'>
    readonly changedAt: FieldRef<"AccountTypeChange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountTypeChange findUnique
   */
  export type AccountTypeChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AccountTypeChange to fetch.
     */
    where: AccountTypeChangeWhereUniqueInput
  }

  /**
   * AccountTypeChange findUniqueOrThrow
   */
  export type AccountTypeChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AccountTypeChange to fetch.
     */
    where: AccountTypeChangeWhereUniqueInput
  }

  /**
   * AccountTypeChange findFirst
   */
  export type AccountTypeChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AccountTypeChange to fetch.
     */
    where?: AccountTypeChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountTypeChanges to fetch.
     */
    orderBy?: AccountTypeChangeOrderByWithRelationInput | AccountTypeChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountTypeChanges.
     */
    cursor?: AccountTypeChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountTypeChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountTypeChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountTypeChanges.
     */
    distinct?: AccountTypeChangeScalarFieldEnum | AccountTypeChangeScalarFieldEnum[]
  }

  /**
   * AccountTypeChange findFirstOrThrow
   */
  export type AccountTypeChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AccountTypeChange to fetch.
     */
    where?: AccountTypeChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountTypeChanges to fetch.
     */
    orderBy?: AccountTypeChangeOrderByWithRelationInput | AccountTypeChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountTypeChanges.
     */
    cursor?: AccountTypeChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountTypeChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountTypeChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountTypeChanges.
     */
    distinct?: AccountTypeChangeScalarFieldEnum | AccountTypeChangeScalarFieldEnum[]
  }

  /**
   * AccountTypeChange findMany
   */
  export type AccountTypeChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AccountTypeChanges to fetch.
     */
    where?: AccountTypeChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountTypeChanges to fetch.
     */
    orderBy?: AccountTypeChangeOrderByWithRelationInput | AccountTypeChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountTypeChanges.
     */
    cursor?: AccountTypeChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountTypeChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountTypeChanges.
     */
    skip?: number
    distinct?: AccountTypeChangeScalarFieldEnum | AccountTypeChangeScalarFieldEnum[]
  }

  /**
   * AccountTypeChange create
   */
  export type AccountTypeChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountTypeChange.
     */
    data: XOR<AccountTypeChangeCreateInput, AccountTypeChangeUncheckedCreateInput>
  }

  /**
   * AccountTypeChange createMany
   */
  export type AccountTypeChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountTypeChanges.
     */
    data: AccountTypeChangeCreateManyInput | AccountTypeChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountTypeChange createManyAndReturn
   */
  export type AccountTypeChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccountTypeChanges.
     */
    data: AccountTypeChangeCreateManyInput | AccountTypeChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountTypeChange update
   */
  export type AccountTypeChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountTypeChange.
     */
    data: XOR<AccountTypeChangeUpdateInput, AccountTypeChangeUncheckedUpdateInput>
    /**
     * Choose, which AccountTypeChange to update.
     */
    where: AccountTypeChangeWhereUniqueInput
  }

  /**
   * AccountTypeChange updateMany
   */
  export type AccountTypeChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountTypeChanges.
     */
    data: XOR<AccountTypeChangeUpdateManyMutationInput, AccountTypeChangeUncheckedUpdateManyInput>
    /**
     * Filter which AccountTypeChanges to update
     */
    where?: AccountTypeChangeWhereInput
  }

  /**
   * AccountTypeChange upsert
   */
  export type AccountTypeChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountTypeChange to update in case it exists.
     */
    where: AccountTypeChangeWhereUniqueInput
    /**
     * In case the AccountTypeChange found by the `where` argument doesn't exist, create a new AccountTypeChange with this data.
     */
    create: XOR<AccountTypeChangeCreateInput, AccountTypeChangeUncheckedCreateInput>
    /**
     * In case the AccountTypeChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountTypeChangeUpdateInput, AccountTypeChangeUncheckedUpdateInput>
  }

  /**
   * AccountTypeChange delete
   */
  export type AccountTypeChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
    /**
     * Filter which AccountTypeChange to delete.
     */
    where: AccountTypeChangeWhereUniqueInput
  }

  /**
   * AccountTypeChange deleteMany
   */
  export type AccountTypeChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountTypeChanges to delete
     */
    where?: AccountTypeChangeWhereInput
  }

  /**
   * AccountTypeChange without action
   */
  export type AccountTypeChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountTypeChange
     */
    select?: AccountTypeChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountTypeChangeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    accountType: 'accountType',
    isVerified: 'isVerified',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resetPasswordToken: 'resetPasswordToken',
    resetPasswordExpires: 'resetPasswordExpires'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    blockerId: 'blockerId',
    blockedId: 'blockedId',
    createdAt: 'createdAt'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    device: 'device',
    ip: 'ip',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    avatar: 'avatar',
    bio: 'bio',
    location: 'location',
    website: 'website',
    isPublic: 'isPublic',
    showInSearch: 'showInSearch',
    showActivityStatus: 'showActivityStatus',
    allowMessagesFromEveryone: 'allowMessagesFromEveryone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const SocialLinkScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    platform: 'platform',
    url: 'url'
  };

  export type SocialLinkScalarFieldEnum = (typeof SocialLinkScalarFieldEnum)[keyof typeof SocialLinkScalarFieldEnum]


  export const FounderProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tagline: 'tagline',
    companyName: 'companyName',
    industry: 'industry',
    lookingForFunding: 'lookingForFunding',
    lookingForCofounder: 'lookingForCofounder',
    lookingForFeedback: 'lookingForFeedback',
    previousVentures: 'previousVentures',
    education: 'education',
    skills: 'skills',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FounderProfileScalarFieldEnum = (typeof FounderProfileScalarFieldEnum)[keyof typeof FounderProfileScalarFieldEnum]


  export const FundraisingDetailsScalarFieldEnum: {
    id: 'id',
    founderId: 'founderId',
    stage: 'stage',
    amount: 'amount',
    industry: 'industry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FundraisingDetailsScalarFieldEnum = (typeof FundraisingDetailsScalarFieldEnum)[keyof typeof FundraisingDetailsScalarFieldEnum]


  export const InvestorProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firm: 'firm',
    title: 'title',
    thesis: 'thesis',
    thesisVideo: 'thesisVideo',
    checkSizeMin: 'checkSizeMin',
    checkSizeMax: 'checkSizeMax',
    stages: 'stages',
    industries: 'industries',
    geographies: 'geographies',
    isPublicMode: 'isPublicMode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorProfileScalarFieldEnum = (typeof InvestorProfileScalarFieldEnum)[keyof typeof InvestorProfileScalarFieldEnum]


  export const PortfolioScalarFieldEnum: {
    id: 'id',
    investorProfileId: 'investorProfileId',
    companyName: 'companyName',
    companyUrl: 'companyUrl',
    investmentYear: 'investmentYear'
  };

  export type PortfolioScalarFieldEnum = (typeof PortfolioScalarFieldEnum)[keyof typeof PortfolioScalarFieldEnum]


  export const BuilderProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    skills: 'skills',
    portfolioUrls: 'portfolioUrls',
    availability: 'availability',
    lookingForProject: 'lookingForProject',
    industryInterests: 'industryInterests',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuilderProfileScalarFieldEnum = (typeof BuilderProfileScalarFieldEnum)[keyof typeof BuilderProfileScalarFieldEnum]


  export const InvestorVerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    linkedinUrl: 'linkedinUrl',
    proofUrl: 'proofUrl',
    proofDocument: 'proofDocument',
    status: 'status',
    reviewerNotes: 'reviewerNotes',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorVerificationScalarFieldEnum = (typeof InvestorVerificationScalarFieldEnum)[keyof typeof InvestorVerificationScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    videoUrl: 'videoUrl',
    thumbnailUrl: 'thumbnailUrl',
    type: 'type',
    visibility: 'visibility',
    isPinned: 'isPinned',
    caption: 'caption',
    duration: 'duration',
    tags: 'tags',
    qualityScore: 'qualityScore',
    viewCount: 'viewCount',
    likeCount: 'likeCount',
    commentCount: 'commentCount',
    shareCount: 'shareCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const VideoTranscriptScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    text: 'text',
    createdAt: 'createdAt'
  };

  export type VideoTranscriptScalarFieldEnum = (typeof VideoTranscriptScalarFieldEnum)[keyof typeof VideoTranscriptScalarFieldEnum]


  export const VideoAnalyticsScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    totalViews: 'totalViews',
    uniqueViews: 'uniqueViews',
    investorViews: 'investorViews',
    founderViews: 'founderViews',
    builderViews: 'builderViews',
    averageWatchTime: 'averageWatchTime',
    completionRate: 'completionRate',
    replayRate: 'replayRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoAnalyticsScalarFieldEnum = (typeof VideoAnalyticsScalarFieldEnum)[keyof typeof VideoAnalyticsScalarFieldEnum]


  export const VideoViewScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    viewerId: 'viewerId',
    watchTime: 'watchTime',
    completed: 'completed',
    replays: 'replays',
    createdAt: 'createdAt'
  };

  export type VideoViewScalarFieldEnum = (typeof VideoViewScalarFieldEnum)[keyof typeof VideoViewScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    userId: 'userId',
    content: 'content',
    parentId: 'parentId',
    isHidden: 'isHidden',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const SaveScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    userId: 'userId',
    listId: 'listId',
    createdAt: 'createdAt'
  };

  export type SaveScalarFieldEnum = (typeof SaveScalarFieldEnum)[keyof typeof SaveScalarFieldEnum]


  export const SaveListScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    isDefault: 'isDefault',
    createdAt: 'createdAt'
  };

  export type SaveListScalarFieldEnum = (typeof SaveListScalarFieldEnum)[keyof typeof SaveListScalarFieldEnum]


  export const ShareScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    userId: 'userId',
    platform: 'platform',
    createdAt: 'createdAt'
  };

  export type ShareScalarFieldEnum = (typeof ShareScalarFieldEnum)[keyof typeof ShareScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const ExpressInterestScalarFieldEnum: {
    id: 'id',
    investorId: 'investorId',
    founderId: 'founderId',
    videoId: 'videoId',
    status: 'status',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpressInterestScalarFieldEnum = (typeof ExpressInterestScalarFieldEnum)[keyof typeof ExpressInterestScalarFieldEnum]


  export const ProfileRevealScalarFieldEnum: {
    id: 'id',
    investorId: 'investorId',
    founderId: 'founderId',
    revealedAt: 'revealedAt'
  };

  export type ProfileRevealScalarFieldEnum = (typeof ProfileRevealScalarFieldEnum)[keyof typeof ProfileRevealScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    participant1Id: 'participant1Id',
    participant2Id: 'participant2Id',
    status: 'status',
    isRevealed: 'isRevealed',
    lastMessageAt: 'lastMessageAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    type: 'type',
    attachmentUrl: 'attachmentUrl',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageLimitScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    period: 'period',
    count: 'count',
    resetsAt: 'resetsAt',
    createdAt: 'createdAt'
  };

  export type MessageLimitScalarFieldEnum = (typeof MessageLimitScalarFieldEnum)[keyof typeof MessageLimitScalarFieldEnum]


  export const ContentReportScalarFieldEnum: {
    id: 'id',
    reporterId: 'reporterId',
    videoId: 'videoId',
    category: 'category',
    details: 'details',
    status: 'status',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt'
  };

  export type ContentReportScalarFieldEnum = (typeof ContentReportScalarFieldEnum)[keyof typeof ContentReportScalarFieldEnum]


  export const ContentFlagScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    flagType: 'flagType',
    severity: 'severity',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type ContentFlagScalarFieldEnum = (typeof ContentFlagScalarFieldEnum)[keyof typeof ContentFlagScalarFieldEnum]


  export const ModerationActionRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    reason: 'reason',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type ModerationActionRecordScalarFieldEnum = (typeof ModerationActionRecordScalarFieldEnum)[keyof typeof ModerationActionRecordScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tier: 'tier',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubId: 'stripeSubId',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    canceledAt: 'canceledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const FeaturedContentScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    startsAt: 'startsAt',
    expiresAt: 'expiresAt',
    tier: 'tier',
    createdAt: 'createdAt'
  };

  export type FeaturedContentScalarFieldEnum = (typeof FeaturedContentScalarFieldEnum)[keyof typeof FeaturedContentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    priority: 'priority',
    title: 'title',
    body: 'body',
    data: 'data',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    pushEnabled: 'pushEnabled',
    emailEnabled: 'emailEnabled'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const FeedPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    industries: 'industries',
    stages: 'stages',
    notifyOnMatches: 'notifyOnMatches',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedPreferenceScalarFieldEnum = (typeof FeedPreferenceScalarFieldEnum)[keyof typeof FeedPreferenceScalarFieldEnum]


  export const SearchHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    query: 'query',
    filters: 'filters',
    createdAt: 'createdAt'
  };

  export type SearchHistoryScalarFieldEnum = (typeof SearchHistoryScalarFieldEnum)[keyof typeof SearchHistoryScalarFieldEnum]


  export const OnboardingProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    step: 'step',
    completed: 'completed',
    data: 'data',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OnboardingProgressScalarFieldEnum = (typeof OnboardingProgressScalarFieldEnum)[keyof typeof OnboardingProgressScalarFieldEnum]


  export const AccountTypeChangeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fromType: 'fromType',
    toType: 'toType',
    changedAt: 'changedAt'
  };

  export type AccountTypeChangeScalarFieldEnum = (typeof AccountTypeChangeScalarFieldEnum)[keyof typeof AccountTypeChangeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


  /**
   * Reference to a field of type 'VideoType'
   */
  export type EnumVideoTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoType'>
    


  /**
   * Reference to a field of type 'VideoType[]'
   */
  export type ListEnumVideoTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoType[]'>
    


  /**
   * Reference to a field of type 'VideoVisibility'
   */
  export type EnumVideoVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoVisibility'>
    


  /**
   * Reference to a field of type 'VideoVisibility[]'
   */
  export type ListEnumVideoVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoVisibility[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ConversationStatus'
   */
  export type EnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus'>
    


  /**
   * Reference to a field of type 'ConversationStatus[]'
   */
  export type ListEnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus[]'>
    


  /**
   * Reference to a field of type 'ReportCategory'
   */
  export type EnumReportCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportCategory'>
    


  /**
   * Reference to a field of type 'ReportCategory[]'
   */
  export type ListEnumReportCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportCategory[]'>
    


  /**
   * Reference to a field of type 'ModerationAction'
   */
  export type EnumModerationActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModerationAction'>
    


  /**
   * Reference to a field of type 'ModerationAction[]'
   */
  export type ListEnumModerationActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModerationAction[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    isVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    resetPasswordExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    founderProfile?: XOR<FounderProfileNullableRelationFilter, FounderProfileWhereInput> | null
    investorProfile?: XOR<InvestorProfileNullableRelationFilter, InvestorProfileWhereInput> | null
    builderProfile?: XOR<BuilderProfileNullableRelationFilter, BuilderProfileWhereInput> | null
    investorVerification?: XOR<InvestorVerificationNullableRelationFilter, InvestorVerificationWhereInput> | null
    videos?: VideoListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    saves?: SaveListRelationFilter
    shares?: ShareListRelationFilter
    videoViews?: VideoViewListRelationFilter
    following?: FollowListRelationFilter
    followers?: FollowListRelationFilter
    sentMessages?: MessageListRelationFilter
    conversations1?: ConversationListRelationFilter
    conversations2?: ConversationListRelationFilter
    expressedInterests?: ExpressInterestListRelationFilter
    receivedInterests?: ExpressInterestListRelationFilter
    profileRevealsAsInvestor?: ProfileRevealListRelationFilter
    profileRevealsAsFounder?: ProfileRevealListRelationFilter
    notifications?: NotificationListRelationFilter
    notificationPrefs?: NotificationPreferenceListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    contentReports?: ContentReportListRelationFilter
    moderationActions?: ModerationActionRecordListRelationFilter
    sessions?: SessionListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    onboardingProgress?: XOR<OnboardingProgressNullableRelationFilter, OnboardingProgressWhereInput> | null
    accountTypeChanges?: AccountTypeChangeListRelationFilter
    messagesSent?: MessageLimitListRelationFilter
    feedPreferences?: XOR<FeedPreferenceNullableRelationFilter, FeedPreferenceWhereInput> | null
    blockedUsers?: BlockListRelationFilter
    blockedBy?: BlockListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    accountType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordExpires?: SortOrderInput | SortOrder
    profile?: UserProfileOrderByWithRelationInput
    founderProfile?: FounderProfileOrderByWithRelationInput
    investorProfile?: InvestorProfileOrderByWithRelationInput
    builderProfile?: BuilderProfileOrderByWithRelationInput
    investorVerification?: InvestorVerificationOrderByWithRelationInput
    videos?: VideoOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    saves?: SaveOrderByRelationAggregateInput
    shares?: ShareOrderByRelationAggregateInput
    videoViews?: VideoViewOrderByRelationAggregateInput
    following?: FollowOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    conversations1?: ConversationOrderByRelationAggregateInput
    conversations2?: ConversationOrderByRelationAggregateInput
    expressedInterests?: ExpressInterestOrderByRelationAggregateInput
    receivedInterests?: ExpressInterestOrderByRelationAggregateInput
    profileRevealsAsInvestor?: ProfileRevealOrderByRelationAggregateInput
    profileRevealsAsFounder?: ProfileRevealOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    notificationPrefs?: NotificationPreferenceOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    contentReports?: ContentReportOrderByRelationAggregateInput
    moderationActions?: ModerationActionRecordOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    searchHistory?: SearchHistoryOrderByRelationAggregateInput
    onboardingProgress?: OnboardingProgressOrderByWithRelationInput
    accountTypeChanges?: AccountTypeChangeOrderByRelationAggregateInput
    messagesSent?: MessageLimitOrderByRelationAggregateInput
    feedPreferences?: FeedPreferenceOrderByWithRelationInput
    blockedUsers?: BlockOrderByRelationAggregateInput
    blockedBy?: BlockOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    isVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    resetPasswordExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    founderProfile?: XOR<FounderProfileNullableRelationFilter, FounderProfileWhereInput> | null
    investorProfile?: XOR<InvestorProfileNullableRelationFilter, InvestorProfileWhereInput> | null
    builderProfile?: XOR<BuilderProfileNullableRelationFilter, BuilderProfileWhereInput> | null
    investorVerification?: XOR<InvestorVerificationNullableRelationFilter, InvestorVerificationWhereInput> | null
    videos?: VideoListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    saves?: SaveListRelationFilter
    shares?: ShareListRelationFilter
    videoViews?: VideoViewListRelationFilter
    following?: FollowListRelationFilter
    followers?: FollowListRelationFilter
    sentMessages?: MessageListRelationFilter
    conversations1?: ConversationListRelationFilter
    conversations2?: ConversationListRelationFilter
    expressedInterests?: ExpressInterestListRelationFilter
    receivedInterests?: ExpressInterestListRelationFilter
    profileRevealsAsInvestor?: ProfileRevealListRelationFilter
    profileRevealsAsFounder?: ProfileRevealListRelationFilter
    notifications?: NotificationListRelationFilter
    notificationPrefs?: NotificationPreferenceListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    contentReports?: ContentReportListRelationFilter
    moderationActions?: ModerationActionRecordListRelationFilter
    sessions?: SessionListRelationFilter
    searchHistory?: SearchHistoryListRelationFilter
    onboardingProgress?: XOR<OnboardingProgressNullableRelationFilter, OnboardingProgressWhereInput> | null
    accountTypeChanges?: AccountTypeChangeListRelationFilter
    messagesSent?: MessageLimitListRelationFilter
    feedPreferences?: XOR<FeedPreferenceNullableRelationFilter, FeedPreferenceWhereInput> | null
    blockedUsers?: BlockListRelationFilter
    blockedBy?: BlockListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    accountType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordExpires?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    accountType?: EnumAccountTypeWithAggregatesFilter<"User"> | $Enums.AccountType
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    resetPasswordToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetPasswordExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: StringFilter<"Block"> | string
    blockerId?: StringFilter<"Block"> | string
    blockedId?: StringFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blocker?: XOR<UserRelationFilter, UserWhereInput>
    blocked?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
    blocker?: UserOrderByWithRelationInput
    blocked?: UserOrderByWithRelationInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockerId_blockedId?: BlockBlockerIdBlockedIdCompoundUniqueInput
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    blockerId?: StringFilter<"Block"> | string
    blockedId?: StringFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blocker?: XOR<UserRelationFilter, UserWhereInput>
    blocked?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "blockerId_blockedId">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Block"> | string
    blockerId?: StringWithAggregatesFilter<"Block"> | string
    blockedId?: StringWithAggregatesFilter<"Block"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    device?: StringNullableFilter<"Session"> | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    device?: StringNullableFilter<"Session"> | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    device?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    avatar?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    location?: StringNullableFilter<"UserProfile"> | string | null
    website?: StringNullableFilter<"UserProfile"> | string | null
    isPublic?: BoolFilter<"UserProfile"> | boolean
    showInSearch?: BoolFilter<"UserProfile"> | boolean
    showActivityStatus?: BoolFilter<"UserProfile"> | boolean
    allowMessagesFromEveryone?: BoolFilter<"UserProfile"> | boolean
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    socialLinks?: SocialLinkListRelationFilter
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    showInSearch?: SortOrder
    showActivityStatus?: SortOrder
    allowMessagesFromEveryone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    socialLinks?: SocialLinkOrderByRelationAggregateInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    avatar?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    location?: StringNullableFilter<"UserProfile"> | string | null
    website?: StringNullableFilter<"UserProfile"> | string | null
    isPublic?: BoolFilter<"UserProfile"> | boolean
    showInSearch?: BoolFilter<"UserProfile"> | boolean
    showActivityStatus?: BoolFilter<"UserProfile"> | boolean
    allowMessagesFromEveryone?: BoolFilter<"UserProfile"> | boolean
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    socialLinks?: SocialLinkListRelationFilter
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    showInSearch?: SortOrder
    showActivityStatus?: SortOrder
    allowMessagesFromEveryone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    avatar?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    location?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    website?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    isPublic?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    showInSearch?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    showActivityStatus?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    allowMessagesFromEveryone?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type SocialLinkWhereInput = {
    AND?: SocialLinkWhereInput | SocialLinkWhereInput[]
    OR?: SocialLinkWhereInput[]
    NOT?: SocialLinkWhereInput | SocialLinkWhereInput[]
    id?: StringFilter<"SocialLink"> | string
    profileId?: StringFilter<"SocialLink"> | string
    platform?: StringFilter<"SocialLink"> | string
    url?: StringFilter<"SocialLink"> | string
    profile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type SocialLinkOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
  }

  export type SocialLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_platform?: SocialLinkProfileIdPlatformCompoundUniqueInput
    AND?: SocialLinkWhereInput | SocialLinkWhereInput[]
    OR?: SocialLinkWhereInput[]
    NOT?: SocialLinkWhereInput | SocialLinkWhereInput[]
    profileId?: StringFilter<"SocialLink"> | string
    platform?: StringFilter<"SocialLink"> | string
    url?: StringFilter<"SocialLink"> | string
    profile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "id" | "profileId_platform">

  export type SocialLinkOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
    _count?: SocialLinkCountOrderByAggregateInput
    _max?: SocialLinkMaxOrderByAggregateInput
    _min?: SocialLinkMinOrderByAggregateInput
  }

  export type SocialLinkScalarWhereWithAggregatesInput = {
    AND?: SocialLinkScalarWhereWithAggregatesInput | SocialLinkScalarWhereWithAggregatesInput[]
    OR?: SocialLinkScalarWhereWithAggregatesInput[]
    NOT?: SocialLinkScalarWhereWithAggregatesInput | SocialLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialLink"> | string
    profileId?: StringWithAggregatesFilter<"SocialLink"> | string
    platform?: StringWithAggregatesFilter<"SocialLink"> | string
    url?: StringWithAggregatesFilter<"SocialLink"> | string
  }

  export type FounderProfileWhereInput = {
    AND?: FounderProfileWhereInput | FounderProfileWhereInput[]
    OR?: FounderProfileWhereInput[]
    NOT?: FounderProfileWhereInput | FounderProfileWhereInput[]
    id?: StringFilter<"FounderProfile"> | string
    userId?: StringFilter<"FounderProfile"> | string
    tagline?: StringNullableFilter<"FounderProfile"> | string | null
    companyName?: StringNullableFilter<"FounderProfile"> | string | null
    industry?: StringNullableFilter<"FounderProfile"> | string | null
    lookingForFunding?: BoolFilter<"FounderProfile"> | boolean
    lookingForCofounder?: BoolFilter<"FounderProfile"> | boolean
    lookingForFeedback?: BoolFilter<"FounderProfile"> | boolean
    previousVentures?: StringNullableFilter<"FounderProfile"> | string | null
    education?: StringNullableFilter<"FounderProfile"> | string | null
    skills?: StringNullableListFilter<"FounderProfile">
    createdAt?: DateTimeFilter<"FounderProfile"> | Date | string
    updatedAt?: DateTimeFilter<"FounderProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    fundraisingDetails?: XOR<FundraisingDetailsNullableRelationFilter, FundraisingDetailsWhereInput> | null
  }

  export type FounderProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tagline?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    lookingForFunding?: SortOrder
    lookingForCofounder?: SortOrder
    lookingForFeedback?: SortOrder
    previousVentures?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    skills?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    fundraisingDetails?: FundraisingDetailsOrderByWithRelationInput
  }

  export type FounderProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: FounderProfileWhereInput | FounderProfileWhereInput[]
    OR?: FounderProfileWhereInput[]
    NOT?: FounderProfileWhereInput | FounderProfileWhereInput[]
    tagline?: StringNullableFilter<"FounderProfile"> | string | null
    companyName?: StringNullableFilter<"FounderProfile"> | string | null
    industry?: StringNullableFilter<"FounderProfile"> | string | null
    lookingForFunding?: BoolFilter<"FounderProfile"> | boolean
    lookingForCofounder?: BoolFilter<"FounderProfile"> | boolean
    lookingForFeedback?: BoolFilter<"FounderProfile"> | boolean
    previousVentures?: StringNullableFilter<"FounderProfile"> | string | null
    education?: StringNullableFilter<"FounderProfile"> | string | null
    skills?: StringNullableListFilter<"FounderProfile">
    createdAt?: DateTimeFilter<"FounderProfile"> | Date | string
    updatedAt?: DateTimeFilter<"FounderProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    fundraisingDetails?: XOR<FundraisingDetailsNullableRelationFilter, FundraisingDetailsWhereInput> | null
  }, "id" | "userId">

  export type FounderProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tagline?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    lookingForFunding?: SortOrder
    lookingForCofounder?: SortOrder
    lookingForFeedback?: SortOrder
    previousVentures?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    skills?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FounderProfileCountOrderByAggregateInput
    _max?: FounderProfileMaxOrderByAggregateInput
    _min?: FounderProfileMinOrderByAggregateInput
  }

  export type FounderProfileScalarWhereWithAggregatesInput = {
    AND?: FounderProfileScalarWhereWithAggregatesInput | FounderProfileScalarWhereWithAggregatesInput[]
    OR?: FounderProfileScalarWhereWithAggregatesInput[]
    NOT?: FounderProfileScalarWhereWithAggregatesInput | FounderProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FounderProfile"> | string
    userId?: StringWithAggregatesFilter<"FounderProfile"> | string
    tagline?: StringNullableWithAggregatesFilter<"FounderProfile"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"FounderProfile"> | string | null
    industry?: StringNullableWithAggregatesFilter<"FounderProfile"> | string | null
    lookingForFunding?: BoolWithAggregatesFilter<"FounderProfile"> | boolean
    lookingForCofounder?: BoolWithAggregatesFilter<"FounderProfile"> | boolean
    lookingForFeedback?: BoolWithAggregatesFilter<"FounderProfile"> | boolean
    previousVentures?: StringNullableWithAggregatesFilter<"FounderProfile"> | string | null
    education?: StringNullableWithAggregatesFilter<"FounderProfile"> | string | null
    skills?: StringNullableListFilter<"FounderProfile">
    createdAt?: DateTimeWithAggregatesFilter<"FounderProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FounderProfile"> | Date | string
  }

  export type FundraisingDetailsWhereInput = {
    AND?: FundraisingDetailsWhereInput | FundraisingDetailsWhereInput[]
    OR?: FundraisingDetailsWhereInput[]
    NOT?: FundraisingDetailsWhereInput | FundraisingDetailsWhereInput[]
    id?: StringFilter<"FundraisingDetails"> | string
    founderId?: StringFilter<"FundraisingDetails"> | string
    stage?: StringFilter<"FundraisingDetails"> | string
    amount?: IntNullableFilter<"FundraisingDetails"> | number | null
    industry?: StringNullableFilter<"FundraisingDetails"> | string | null
    createdAt?: DateTimeFilter<"FundraisingDetails"> | Date | string
    updatedAt?: DateTimeFilter<"FundraisingDetails"> | Date | string
    founderProfile?: XOR<FounderProfileRelationFilter, FounderProfileWhereInput>
  }

  export type FundraisingDetailsOrderByWithRelationInput = {
    id?: SortOrder
    founderId?: SortOrder
    stage?: SortOrder
    amount?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founderProfile?: FounderProfileOrderByWithRelationInput
  }

  export type FundraisingDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    founderId?: string
    AND?: FundraisingDetailsWhereInput | FundraisingDetailsWhereInput[]
    OR?: FundraisingDetailsWhereInput[]
    NOT?: FundraisingDetailsWhereInput | FundraisingDetailsWhereInput[]
    stage?: StringFilter<"FundraisingDetails"> | string
    amount?: IntNullableFilter<"FundraisingDetails"> | number | null
    industry?: StringNullableFilter<"FundraisingDetails"> | string | null
    createdAt?: DateTimeFilter<"FundraisingDetails"> | Date | string
    updatedAt?: DateTimeFilter<"FundraisingDetails"> | Date | string
    founderProfile?: XOR<FounderProfileRelationFilter, FounderProfileWhereInput>
  }, "id" | "founderId">

  export type FundraisingDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    founderId?: SortOrder
    stage?: SortOrder
    amount?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FundraisingDetailsCountOrderByAggregateInput
    _avg?: FundraisingDetailsAvgOrderByAggregateInput
    _max?: FundraisingDetailsMaxOrderByAggregateInput
    _min?: FundraisingDetailsMinOrderByAggregateInput
    _sum?: FundraisingDetailsSumOrderByAggregateInput
  }

  export type FundraisingDetailsScalarWhereWithAggregatesInput = {
    AND?: FundraisingDetailsScalarWhereWithAggregatesInput | FundraisingDetailsScalarWhereWithAggregatesInput[]
    OR?: FundraisingDetailsScalarWhereWithAggregatesInput[]
    NOT?: FundraisingDetailsScalarWhereWithAggregatesInput | FundraisingDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FundraisingDetails"> | string
    founderId?: StringWithAggregatesFilter<"FundraisingDetails"> | string
    stage?: StringWithAggregatesFilter<"FundraisingDetails"> | string
    amount?: IntNullableWithAggregatesFilter<"FundraisingDetails"> | number | null
    industry?: StringNullableWithAggregatesFilter<"FundraisingDetails"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FundraisingDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FundraisingDetails"> | Date | string
  }

  export type InvestorProfileWhereInput = {
    AND?: InvestorProfileWhereInput | InvestorProfileWhereInput[]
    OR?: InvestorProfileWhereInput[]
    NOT?: InvestorProfileWhereInput | InvestorProfileWhereInput[]
    id?: StringFilter<"InvestorProfile"> | string
    userId?: StringFilter<"InvestorProfile"> | string
    firm?: StringNullableFilter<"InvestorProfile"> | string | null
    title?: StringNullableFilter<"InvestorProfile"> | string | null
    thesis?: StringNullableFilter<"InvestorProfile"> | string | null
    thesisVideo?: StringNullableFilter<"InvestorProfile"> | string | null
    checkSizeMin?: IntNullableFilter<"InvestorProfile"> | number | null
    checkSizeMax?: IntNullableFilter<"InvestorProfile"> | number | null
    stages?: StringNullableListFilter<"InvestorProfile">
    industries?: StringNullableListFilter<"InvestorProfile">
    geographies?: StringNullableListFilter<"InvestorProfile">
    isPublicMode?: BoolFilter<"InvestorProfile"> | boolean
    createdAt?: DateTimeFilter<"InvestorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    portfolio?: PortfolioListRelationFilter
  }

  export type InvestorProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firm?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    thesis?: SortOrderInput | SortOrder
    thesisVideo?: SortOrderInput | SortOrder
    checkSizeMin?: SortOrderInput | SortOrder
    checkSizeMax?: SortOrderInput | SortOrder
    stages?: SortOrder
    industries?: SortOrder
    geographies?: SortOrder
    isPublicMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    portfolio?: PortfolioOrderByRelationAggregateInput
  }

  export type InvestorProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: InvestorProfileWhereInput | InvestorProfileWhereInput[]
    OR?: InvestorProfileWhereInput[]
    NOT?: InvestorProfileWhereInput | InvestorProfileWhereInput[]
    firm?: StringNullableFilter<"InvestorProfile"> | string | null
    title?: StringNullableFilter<"InvestorProfile"> | string | null
    thesis?: StringNullableFilter<"InvestorProfile"> | string | null
    thesisVideo?: StringNullableFilter<"InvestorProfile"> | string | null
    checkSizeMin?: IntNullableFilter<"InvestorProfile"> | number | null
    checkSizeMax?: IntNullableFilter<"InvestorProfile"> | number | null
    stages?: StringNullableListFilter<"InvestorProfile">
    industries?: StringNullableListFilter<"InvestorProfile">
    geographies?: StringNullableListFilter<"InvestorProfile">
    isPublicMode?: BoolFilter<"InvestorProfile"> | boolean
    createdAt?: DateTimeFilter<"InvestorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    portfolio?: PortfolioListRelationFilter
  }, "id" | "userId">

  export type InvestorProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firm?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    thesis?: SortOrderInput | SortOrder
    thesisVideo?: SortOrderInput | SortOrder
    checkSizeMin?: SortOrderInput | SortOrder
    checkSizeMax?: SortOrderInput | SortOrder
    stages?: SortOrder
    industries?: SortOrder
    geographies?: SortOrder
    isPublicMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorProfileCountOrderByAggregateInput
    _avg?: InvestorProfileAvgOrderByAggregateInput
    _max?: InvestorProfileMaxOrderByAggregateInput
    _min?: InvestorProfileMinOrderByAggregateInput
    _sum?: InvestorProfileSumOrderByAggregateInput
  }

  export type InvestorProfileScalarWhereWithAggregatesInput = {
    AND?: InvestorProfileScalarWhereWithAggregatesInput | InvestorProfileScalarWhereWithAggregatesInput[]
    OR?: InvestorProfileScalarWhereWithAggregatesInput[]
    NOT?: InvestorProfileScalarWhereWithAggregatesInput | InvestorProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvestorProfile"> | string
    userId?: StringWithAggregatesFilter<"InvestorProfile"> | string
    firm?: StringNullableWithAggregatesFilter<"InvestorProfile"> | string | null
    title?: StringNullableWithAggregatesFilter<"InvestorProfile"> | string | null
    thesis?: StringNullableWithAggregatesFilter<"InvestorProfile"> | string | null
    thesisVideo?: StringNullableWithAggregatesFilter<"InvestorProfile"> | string | null
    checkSizeMin?: IntNullableWithAggregatesFilter<"InvestorProfile"> | number | null
    checkSizeMax?: IntNullableWithAggregatesFilter<"InvestorProfile"> | number | null
    stages?: StringNullableListFilter<"InvestorProfile">
    industries?: StringNullableListFilter<"InvestorProfile">
    geographies?: StringNullableListFilter<"InvestorProfile">
    isPublicMode?: BoolWithAggregatesFilter<"InvestorProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InvestorProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvestorProfile"> | Date | string
  }

  export type PortfolioWhereInput = {
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    id?: StringFilter<"Portfolio"> | string
    investorProfileId?: StringFilter<"Portfolio"> | string
    companyName?: StringFilter<"Portfolio"> | string
    companyUrl?: StringNullableFilter<"Portfolio"> | string | null
    investmentYear?: IntNullableFilter<"Portfolio"> | number | null
    investorProfile?: XOR<InvestorProfileRelationFilter, InvestorProfileWhereInput>
  }

  export type PortfolioOrderByWithRelationInput = {
    id?: SortOrder
    investorProfileId?: SortOrder
    companyName?: SortOrder
    companyUrl?: SortOrderInput | SortOrder
    investmentYear?: SortOrderInput | SortOrder
    investorProfile?: InvestorProfileOrderByWithRelationInput
  }

  export type PortfolioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    investorProfileId?: StringFilter<"Portfolio"> | string
    companyName?: StringFilter<"Portfolio"> | string
    companyUrl?: StringNullableFilter<"Portfolio"> | string | null
    investmentYear?: IntNullableFilter<"Portfolio"> | number | null
    investorProfile?: XOR<InvestorProfileRelationFilter, InvestorProfileWhereInput>
  }, "id">

  export type PortfolioOrderByWithAggregationInput = {
    id?: SortOrder
    investorProfileId?: SortOrder
    companyName?: SortOrder
    companyUrl?: SortOrderInput | SortOrder
    investmentYear?: SortOrderInput | SortOrder
    _count?: PortfolioCountOrderByAggregateInput
    _avg?: PortfolioAvgOrderByAggregateInput
    _max?: PortfolioMaxOrderByAggregateInput
    _min?: PortfolioMinOrderByAggregateInput
    _sum?: PortfolioSumOrderByAggregateInput
  }

  export type PortfolioScalarWhereWithAggregatesInput = {
    AND?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    OR?: PortfolioScalarWhereWithAggregatesInput[]
    NOT?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Portfolio"> | string
    investorProfileId?: StringWithAggregatesFilter<"Portfolio"> | string
    companyName?: StringWithAggregatesFilter<"Portfolio"> | string
    companyUrl?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    investmentYear?: IntNullableWithAggregatesFilter<"Portfolio"> | number | null
  }

  export type BuilderProfileWhereInput = {
    AND?: BuilderProfileWhereInput | BuilderProfileWhereInput[]
    OR?: BuilderProfileWhereInput[]
    NOT?: BuilderProfileWhereInput | BuilderProfileWhereInput[]
    id?: StringFilter<"BuilderProfile"> | string
    userId?: StringFilter<"BuilderProfile"> | string
    skills?: StringNullableListFilter<"BuilderProfile">
    portfolioUrls?: StringNullableListFilter<"BuilderProfile">
    availability?: StringFilter<"BuilderProfile"> | string
    lookingForProject?: BoolFilter<"BuilderProfile"> | boolean
    industryInterests?: StringNullableListFilter<"BuilderProfile">
    createdAt?: DateTimeFilter<"BuilderProfile"> | Date | string
    updatedAt?: DateTimeFilter<"BuilderProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BuilderProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    skills?: SortOrder
    portfolioUrls?: SortOrder
    availability?: SortOrder
    lookingForProject?: SortOrder
    industryInterests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BuilderProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: BuilderProfileWhereInput | BuilderProfileWhereInput[]
    OR?: BuilderProfileWhereInput[]
    NOT?: BuilderProfileWhereInput | BuilderProfileWhereInput[]
    skills?: StringNullableListFilter<"BuilderProfile">
    portfolioUrls?: StringNullableListFilter<"BuilderProfile">
    availability?: StringFilter<"BuilderProfile"> | string
    lookingForProject?: BoolFilter<"BuilderProfile"> | boolean
    industryInterests?: StringNullableListFilter<"BuilderProfile">
    createdAt?: DateTimeFilter<"BuilderProfile"> | Date | string
    updatedAt?: DateTimeFilter<"BuilderProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type BuilderProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    skills?: SortOrder
    portfolioUrls?: SortOrder
    availability?: SortOrder
    lookingForProject?: SortOrder
    industryInterests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuilderProfileCountOrderByAggregateInput
    _max?: BuilderProfileMaxOrderByAggregateInput
    _min?: BuilderProfileMinOrderByAggregateInput
  }

  export type BuilderProfileScalarWhereWithAggregatesInput = {
    AND?: BuilderProfileScalarWhereWithAggregatesInput | BuilderProfileScalarWhereWithAggregatesInput[]
    OR?: BuilderProfileScalarWhereWithAggregatesInput[]
    NOT?: BuilderProfileScalarWhereWithAggregatesInput | BuilderProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuilderProfile"> | string
    userId?: StringWithAggregatesFilter<"BuilderProfile"> | string
    skills?: StringNullableListFilter<"BuilderProfile">
    portfolioUrls?: StringNullableListFilter<"BuilderProfile">
    availability?: StringWithAggregatesFilter<"BuilderProfile"> | string
    lookingForProject?: BoolWithAggregatesFilter<"BuilderProfile"> | boolean
    industryInterests?: StringNullableListFilter<"BuilderProfile">
    createdAt?: DateTimeWithAggregatesFilter<"BuilderProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BuilderProfile"> | Date | string
  }

  export type InvestorVerificationWhereInput = {
    AND?: InvestorVerificationWhereInput | InvestorVerificationWhereInput[]
    OR?: InvestorVerificationWhereInput[]
    NOT?: InvestorVerificationWhereInput | InvestorVerificationWhereInput[]
    id?: StringFilter<"InvestorVerification"> | string
    userId?: StringFilter<"InvestorVerification"> | string
    linkedinUrl?: StringNullableFilter<"InvestorVerification"> | string | null
    proofUrl?: StringNullableFilter<"InvestorVerification"> | string | null
    proofDocument?: StringNullableFilter<"InvestorVerification"> | string | null
    status?: EnumVerificationStatusFilter<"InvestorVerification"> | $Enums.VerificationStatus
    reviewerNotes?: StringNullableFilter<"InvestorVerification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"InvestorVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"InvestorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorVerification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InvestorVerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    proofUrl?: SortOrderInput | SortOrder
    proofDocument?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewerNotes?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InvestorVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: InvestorVerificationWhereInput | InvestorVerificationWhereInput[]
    OR?: InvestorVerificationWhereInput[]
    NOT?: InvestorVerificationWhereInput | InvestorVerificationWhereInput[]
    linkedinUrl?: StringNullableFilter<"InvestorVerification"> | string | null
    proofUrl?: StringNullableFilter<"InvestorVerification"> | string | null
    proofDocument?: StringNullableFilter<"InvestorVerification"> | string | null
    status?: EnumVerificationStatusFilter<"InvestorVerification"> | $Enums.VerificationStatus
    reviewerNotes?: StringNullableFilter<"InvestorVerification"> | string | null
    reviewedAt?: DateTimeNullableFilter<"InvestorVerification"> | Date | string | null
    createdAt?: DateTimeFilter<"InvestorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorVerification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type InvestorVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    proofUrl?: SortOrderInput | SortOrder
    proofDocument?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewerNotes?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorVerificationCountOrderByAggregateInput
    _max?: InvestorVerificationMaxOrderByAggregateInput
    _min?: InvestorVerificationMinOrderByAggregateInput
  }

  export type InvestorVerificationScalarWhereWithAggregatesInput = {
    AND?: InvestorVerificationScalarWhereWithAggregatesInput | InvestorVerificationScalarWhereWithAggregatesInput[]
    OR?: InvestorVerificationScalarWhereWithAggregatesInput[]
    NOT?: InvestorVerificationScalarWhereWithAggregatesInput | InvestorVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvestorVerification"> | string
    userId?: StringWithAggregatesFilter<"InvestorVerification"> | string
    linkedinUrl?: StringNullableWithAggregatesFilter<"InvestorVerification"> | string | null
    proofUrl?: StringNullableWithAggregatesFilter<"InvestorVerification"> | string | null
    proofDocument?: StringNullableWithAggregatesFilter<"InvestorVerification"> | string | null
    status?: EnumVerificationStatusWithAggregatesFilter<"InvestorVerification"> | $Enums.VerificationStatus
    reviewerNotes?: StringNullableWithAggregatesFilter<"InvestorVerification"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"InvestorVerification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvestorVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvestorVerification"> | Date | string
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    id?: StringFilter<"Video"> | string
    userId?: StringFilter<"Video"> | string
    videoUrl?: StringFilter<"Video"> | string
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    type?: EnumVideoTypeFilter<"Video"> | $Enums.VideoType
    visibility?: EnumVideoVisibilityFilter<"Video"> | $Enums.VideoVisibility
    isPinned?: BoolFilter<"Video"> | boolean
    caption?: StringNullableFilter<"Video"> | string | null
    duration?: IntFilter<"Video"> | number
    tags?: StringNullableListFilter<"Video">
    qualityScore?: IntNullableFilter<"Video"> | number | null
    viewCount?: IntFilter<"Video"> | number
    likeCount?: IntFilter<"Video"> | number
    commentCount?: IntFilter<"Video"> | number
    shareCount?: IntFilter<"Video"> | number
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transcript?: XOR<VideoTranscriptNullableRelationFilter, VideoTranscriptWhereInput> | null
    analytics?: XOR<VideoAnalyticsNullableRelationFilter, VideoAnalyticsWhereInput> | null
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    saves?: SaveListRelationFilter
    shares?: ShareListRelationFilter
    views?: VideoViewListRelationFilter
    reports?: ContentReportListRelationFilter
    expressInterests?: ExpressInterestListRelationFilter
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    caption?: SortOrderInput | SortOrder
    duration?: SortOrder
    tags?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transcript?: VideoTranscriptOrderByWithRelationInput
    analytics?: VideoAnalyticsOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    saves?: SaveOrderByRelationAggregateInput
    shares?: ShareOrderByRelationAggregateInput
    views?: VideoViewOrderByRelationAggregateInput
    reports?: ContentReportOrderByRelationAggregateInput
    expressInterests?: ExpressInterestOrderByRelationAggregateInput
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    userId?: StringFilter<"Video"> | string
    videoUrl?: StringFilter<"Video"> | string
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    type?: EnumVideoTypeFilter<"Video"> | $Enums.VideoType
    visibility?: EnumVideoVisibilityFilter<"Video"> | $Enums.VideoVisibility
    isPinned?: BoolFilter<"Video"> | boolean
    caption?: StringNullableFilter<"Video"> | string | null
    duration?: IntFilter<"Video"> | number
    tags?: StringNullableListFilter<"Video">
    qualityScore?: IntNullableFilter<"Video"> | number | null
    viewCount?: IntFilter<"Video"> | number
    likeCount?: IntFilter<"Video"> | number
    commentCount?: IntFilter<"Video"> | number
    shareCount?: IntFilter<"Video"> | number
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transcript?: XOR<VideoTranscriptNullableRelationFilter, VideoTranscriptWhereInput> | null
    analytics?: XOR<VideoAnalyticsNullableRelationFilter, VideoAnalyticsWhereInput> | null
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    saves?: SaveListRelationFilter
    shares?: ShareListRelationFilter
    views?: VideoViewListRelationFilter
    reports?: ContentReportListRelationFilter
    expressInterests?: ExpressInterestListRelationFilter
  }, "id">

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    caption?: SortOrderInput | SortOrder
    duration?: SortOrder
    tags?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Video"> | string
    userId?: StringWithAggregatesFilter<"Video"> | string
    videoUrl?: StringWithAggregatesFilter<"Video"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Video"> | string | null
    type?: EnumVideoTypeWithAggregatesFilter<"Video"> | $Enums.VideoType
    visibility?: EnumVideoVisibilityWithAggregatesFilter<"Video"> | $Enums.VideoVisibility
    isPinned?: BoolWithAggregatesFilter<"Video"> | boolean
    caption?: StringNullableWithAggregatesFilter<"Video"> | string | null
    duration?: IntWithAggregatesFilter<"Video"> | number
    tags?: StringNullableListFilter<"Video">
    qualityScore?: IntNullableWithAggregatesFilter<"Video"> | number | null
    viewCount?: IntWithAggregatesFilter<"Video"> | number
    likeCount?: IntWithAggregatesFilter<"Video"> | number
    commentCount?: IntWithAggregatesFilter<"Video"> | number
    shareCount?: IntWithAggregatesFilter<"Video"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
  }

  export type VideoTranscriptWhereInput = {
    AND?: VideoTranscriptWhereInput | VideoTranscriptWhereInput[]
    OR?: VideoTranscriptWhereInput[]
    NOT?: VideoTranscriptWhereInput | VideoTranscriptWhereInput[]
    id?: StringFilter<"VideoTranscript"> | string
    videoId?: StringFilter<"VideoTranscript"> | string
    text?: StringFilter<"VideoTranscript"> | string
    createdAt?: DateTimeFilter<"VideoTranscript"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }

  export type VideoTranscriptOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    video?: VideoOrderByWithRelationInput
  }

  export type VideoTranscriptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    videoId?: string
    AND?: VideoTranscriptWhereInput | VideoTranscriptWhereInput[]
    OR?: VideoTranscriptWhereInput[]
    NOT?: VideoTranscriptWhereInput | VideoTranscriptWhereInput[]
    text?: StringFilter<"VideoTranscript"> | string
    createdAt?: DateTimeFilter<"VideoTranscript"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }, "id" | "videoId">

  export type VideoTranscriptOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    _count?: VideoTranscriptCountOrderByAggregateInput
    _max?: VideoTranscriptMaxOrderByAggregateInput
    _min?: VideoTranscriptMinOrderByAggregateInput
  }

  export type VideoTranscriptScalarWhereWithAggregatesInput = {
    AND?: VideoTranscriptScalarWhereWithAggregatesInput | VideoTranscriptScalarWhereWithAggregatesInput[]
    OR?: VideoTranscriptScalarWhereWithAggregatesInput[]
    NOT?: VideoTranscriptScalarWhereWithAggregatesInput | VideoTranscriptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoTranscript"> | string
    videoId?: StringWithAggregatesFilter<"VideoTranscript"> | string
    text?: StringWithAggregatesFilter<"VideoTranscript"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VideoTranscript"> | Date | string
  }

  export type VideoAnalyticsWhereInput = {
    AND?: VideoAnalyticsWhereInput | VideoAnalyticsWhereInput[]
    OR?: VideoAnalyticsWhereInput[]
    NOT?: VideoAnalyticsWhereInput | VideoAnalyticsWhereInput[]
    id?: StringFilter<"VideoAnalytics"> | string
    videoId?: StringFilter<"VideoAnalytics"> | string
    totalViews?: IntFilter<"VideoAnalytics"> | number
    uniqueViews?: IntFilter<"VideoAnalytics"> | number
    investorViews?: IntFilter<"VideoAnalytics"> | number
    founderViews?: IntFilter<"VideoAnalytics"> | number
    builderViews?: IntFilter<"VideoAnalytics"> | number
    averageWatchTime?: FloatFilter<"VideoAnalytics"> | number
    completionRate?: FloatFilter<"VideoAnalytics"> | number
    replayRate?: FloatFilter<"VideoAnalytics"> | number
    createdAt?: DateTimeFilter<"VideoAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"VideoAnalytics"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }

  export type VideoAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    totalViews?: SortOrder
    uniqueViews?: SortOrder
    investorViews?: SortOrder
    founderViews?: SortOrder
    builderViews?: SortOrder
    averageWatchTime?: SortOrder
    completionRate?: SortOrder
    replayRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    video?: VideoOrderByWithRelationInput
  }

  export type VideoAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    videoId?: string
    AND?: VideoAnalyticsWhereInput | VideoAnalyticsWhereInput[]
    OR?: VideoAnalyticsWhereInput[]
    NOT?: VideoAnalyticsWhereInput | VideoAnalyticsWhereInput[]
    totalViews?: IntFilter<"VideoAnalytics"> | number
    uniqueViews?: IntFilter<"VideoAnalytics"> | number
    investorViews?: IntFilter<"VideoAnalytics"> | number
    founderViews?: IntFilter<"VideoAnalytics"> | number
    builderViews?: IntFilter<"VideoAnalytics"> | number
    averageWatchTime?: FloatFilter<"VideoAnalytics"> | number
    completionRate?: FloatFilter<"VideoAnalytics"> | number
    replayRate?: FloatFilter<"VideoAnalytics"> | number
    createdAt?: DateTimeFilter<"VideoAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"VideoAnalytics"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }, "id" | "videoId">

  export type VideoAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    totalViews?: SortOrder
    uniqueViews?: SortOrder
    investorViews?: SortOrder
    founderViews?: SortOrder
    builderViews?: SortOrder
    averageWatchTime?: SortOrder
    completionRate?: SortOrder
    replayRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoAnalyticsCountOrderByAggregateInput
    _avg?: VideoAnalyticsAvgOrderByAggregateInput
    _max?: VideoAnalyticsMaxOrderByAggregateInput
    _min?: VideoAnalyticsMinOrderByAggregateInput
    _sum?: VideoAnalyticsSumOrderByAggregateInput
  }

  export type VideoAnalyticsScalarWhereWithAggregatesInput = {
    AND?: VideoAnalyticsScalarWhereWithAggregatesInput | VideoAnalyticsScalarWhereWithAggregatesInput[]
    OR?: VideoAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: VideoAnalyticsScalarWhereWithAggregatesInput | VideoAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoAnalytics"> | string
    videoId?: StringWithAggregatesFilter<"VideoAnalytics"> | string
    totalViews?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    uniqueViews?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    investorViews?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    founderViews?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    builderViews?: IntWithAggregatesFilter<"VideoAnalytics"> | number
    averageWatchTime?: FloatWithAggregatesFilter<"VideoAnalytics"> | number
    completionRate?: FloatWithAggregatesFilter<"VideoAnalytics"> | number
    replayRate?: FloatWithAggregatesFilter<"VideoAnalytics"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VideoAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoAnalytics"> | Date | string
  }

  export type VideoViewWhereInput = {
    AND?: VideoViewWhereInput | VideoViewWhereInput[]
    OR?: VideoViewWhereInput[]
    NOT?: VideoViewWhereInput | VideoViewWhereInput[]
    id?: StringFilter<"VideoView"> | string
    videoId?: StringFilter<"VideoView"> | string
    viewerId?: StringFilter<"VideoView"> | string
    watchTime?: IntFilter<"VideoView"> | number
    completed?: BoolFilter<"VideoView"> | boolean
    replays?: IntFilter<"VideoView"> | number
    createdAt?: DateTimeFilter<"VideoView"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    viewer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VideoViewOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    viewerId?: SortOrder
    watchTime?: SortOrder
    completed?: SortOrder
    replays?: SortOrder
    createdAt?: SortOrder
    video?: VideoOrderByWithRelationInput
    viewer?: UserOrderByWithRelationInput
  }

  export type VideoViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    videoId_viewerId?: VideoViewVideoIdViewerIdCompoundUniqueInput
    AND?: VideoViewWhereInput | VideoViewWhereInput[]
    OR?: VideoViewWhereInput[]
    NOT?: VideoViewWhereInput | VideoViewWhereInput[]
    videoId?: StringFilter<"VideoView"> | string
    viewerId?: StringFilter<"VideoView"> | string
    watchTime?: IntFilter<"VideoView"> | number
    completed?: BoolFilter<"VideoView"> | boolean
    replays?: IntFilter<"VideoView"> | number
    createdAt?: DateTimeFilter<"VideoView"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    viewer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "videoId_viewerId">

  export type VideoViewOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    viewerId?: SortOrder
    watchTime?: SortOrder
    completed?: SortOrder
    replays?: SortOrder
    createdAt?: SortOrder
    _count?: VideoViewCountOrderByAggregateInput
    _avg?: VideoViewAvgOrderByAggregateInput
    _max?: VideoViewMaxOrderByAggregateInput
    _min?: VideoViewMinOrderByAggregateInput
    _sum?: VideoViewSumOrderByAggregateInput
  }

  export type VideoViewScalarWhereWithAggregatesInput = {
    AND?: VideoViewScalarWhereWithAggregatesInput | VideoViewScalarWhereWithAggregatesInput[]
    OR?: VideoViewScalarWhereWithAggregatesInput[]
    NOT?: VideoViewScalarWhereWithAggregatesInput | VideoViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoView"> | string
    videoId?: StringWithAggregatesFilter<"VideoView"> | string
    viewerId?: StringWithAggregatesFilter<"VideoView"> | string
    watchTime?: IntWithAggregatesFilter<"VideoView"> | number
    completed?: BoolWithAggregatesFilter<"VideoView"> | boolean
    replays?: IntWithAggregatesFilter<"VideoView"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VideoView"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    videoId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    video?: VideoOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    videoId_userId?: LikeVideoIdUserIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    videoId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "videoId_userId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    videoId?: StringWithAggregatesFilter<"Like"> | string
    userId?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    videoId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    isHidden?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    video?: VideoOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    videoId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    isHidden?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    videoId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    isHidden?: BoolWithAggregatesFilter<"Comment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type SaveWhereInput = {
    AND?: SaveWhereInput | SaveWhereInput[]
    OR?: SaveWhereInput[]
    NOT?: SaveWhereInput | SaveWhereInput[]
    id?: StringFilter<"Save"> | string
    videoId?: StringFilter<"Save"> | string
    userId?: StringFilter<"Save"> | string
    listId?: StringNullableFilter<"Save"> | string | null
    createdAt?: DateTimeFilter<"Save"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    list?: XOR<SaveListNullableRelationFilter, SaveListWhereInput> | null
  }

  export type SaveOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    listId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    video?: VideoOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    list?: SaveListOrderByWithRelationInput
  }

  export type SaveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    videoId_userId?: SaveVideoIdUserIdCompoundUniqueInput
    AND?: SaveWhereInput | SaveWhereInput[]
    OR?: SaveWhereInput[]
    NOT?: SaveWhereInput | SaveWhereInput[]
    videoId?: StringFilter<"Save"> | string
    userId?: StringFilter<"Save"> | string
    listId?: StringNullableFilter<"Save"> | string | null
    createdAt?: DateTimeFilter<"Save"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    list?: XOR<SaveListNullableRelationFilter, SaveListWhereInput> | null
  }, "id" | "videoId_userId">

  export type SaveOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    listId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SaveCountOrderByAggregateInput
    _max?: SaveMaxOrderByAggregateInput
    _min?: SaveMinOrderByAggregateInput
  }

  export type SaveScalarWhereWithAggregatesInput = {
    AND?: SaveScalarWhereWithAggregatesInput | SaveScalarWhereWithAggregatesInput[]
    OR?: SaveScalarWhereWithAggregatesInput[]
    NOT?: SaveScalarWhereWithAggregatesInput | SaveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Save"> | string
    videoId?: StringWithAggregatesFilter<"Save"> | string
    userId?: StringWithAggregatesFilter<"Save"> | string
    listId?: StringNullableWithAggregatesFilter<"Save"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Save"> | Date | string
  }

  export type SaveListWhereInput = {
    AND?: SaveListWhereInput | SaveListWhereInput[]
    OR?: SaveListWhereInput[]
    NOT?: SaveListWhereInput | SaveListWhereInput[]
    id?: StringFilter<"SaveList"> | string
    userId?: StringFilter<"SaveList"> | string
    name?: StringFilter<"SaveList"> | string
    isDefault?: BoolFilter<"SaveList"> | boolean
    createdAt?: DateTimeFilter<"SaveList"> | Date | string
    saves?: SaveListRelationFilter
  }

  export type SaveListOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    saves?: SaveOrderByRelationAggregateInput
  }

  export type SaveListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_name?: SaveListUserIdNameCompoundUniqueInput
    AND?: SaveListWhereInput | SaveListWhereInput[]
    OR?: SaveListWhereInput[]
    NOT?: SaveListWhereInput | SaveListWhereInput[]
    userId?: StringFilter<"SaveList"> | string
    name?: StringFilter<"SaveList"> | string
    isDefault?: BoolFilter<"SaveList"> | boolean
    createdAt?: DateTimeFilter<"SaveList"> | Date | string
    saves?: SaveListRelationFilter
  }, "id" | "userId_name">

  export type SaveListOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    _count?: SaveListCountOrderByAggregateInput
    _max?: SaveListMaxOrderByAggregateInput
    _min?: SaveListMinOrderByAggregateInput
  }

  export type SaveListScalarWhereWithAggregatesInput = {
    AND?: SaveListScalarWhereWithAggregatesInput | SaveListScalarWhereWithAggregatesInput[]
    OR?: SaveListScalarWhereWithAggregatesInput[]
    NOT?: SaveListScalarWhereWithAggregatesInput | SaveListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaveList"> | string
    userId?: StringWithAggregatesFilter<"SaveList"> | string
    name?: StringWithAggregatesFilter<"SaveList"> | string
    isDefault?: BoolWithAggregatesFilter<"SaveList"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SaveList"> | Date | string
  }

  export type ShareWhereInput = {
    AND?: ShareWhereInput | ShareWhereInput[]
    OR?: ShareWhereInput[]
    NOT?: ShareWhereInput | ShareWhereInput[]
    id?: StringFilter<"Share"> | string
    videoId?: StringFilter<"Share"> | string
    userId?: StringFilter<"Share"> | string
    platform?: StringFilter<"Share"> | string
    createdAt?: DateTimeFilter<"Share"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ShareOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
    video?: VideoOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShareWhereInput | ShareWhereInput[]
    OR?: ShareWhereInput[]
    NOT?: ShareWhereInput | ShareWhereInput[]
    videoId?: StringFilter<"Share"> | string
    userId?: StringFilter<"Share"> | string
    platform?: StringFilter<"Share"> | string
    createdAt?: DateTimeFilter<"Share"> | Date | string
    video?: XOR<VideoRelationFilter, VideoWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ShareOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
    _count?: ShareCountOrderByAggregateInput
    _max?: ShareMaxOrderByAggregateInput
    _min?: ShareMinOrderByAggregateInput
  }

  export type ShareScalarWhereWithAggregatesInput = {
    AND?: ShareScalarWhereWithAggregatesInput | ShareScalarWhereWithAggregatesInput[]
    OR?: ShareScalarWhereWithAggregatesInput[]
    NOT?: ShareScalarWhereWithAggregatesInput | ShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Share"> | string
    videoId?: StringWithAggregatesFilter<"Share"> | string
    userId?: StringWithAggregatesFilter<"Share"> | string
    platform?: StringWithAggregatesFilter<"Share"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Share"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: FollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "followerId_followingId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    followerId?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type ExpressInterestWhereInput = {
    AND?: ExpressInterestWhereInput | ExpressInterestWhereInput[]
    OR?: ExpressInterestWhereInput[]
    NOT?: ExpressInterestWhereInput | ExpressInterestWhereInput[]
    id?: StringFilter<"ExpressInterest"> | string
    investorId?: StringFilter<"ExpressInterest"> | string
    founderId?: StringFilter<"ExpressInterest"> | string
    videoId?: StringFilter<"ExpressInterest"> | string
    status?: StringFilter<"ExpressInterest"> | string
    message?: StringNullableFilter<"ExpressInterest"> | string | null
    createdAt?: DateTimeFilter<"ExpressInterest"> | Date | string
    updatedAt?: DateTimeFilter<"ExpressInterest"> | Date | string
    investor?: XOR<UserRelationFilter, UserWhereInput>
    founder?: XOR<UserRelationFilter, UserWhereInput>
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }

  export type ExpressInterestOrderByWithRelationInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    videoId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    investor?: UserOrderByWithRelationInput
    founder?: UserOrderByWithRelationInput
    video?: VideoOrderByWithRelationInput
  }

  export type ExpressInterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    investorId_founderId_videoId?: ExpressInterestInvestorIdFounderIdVideoIdCompoundUniqueInput
    AND?: ExpressInterestWhereInput | ExpressInterestWhereInput[]
    OR?: ExpressInterestWhereInput[]
    NOT?: ExpressInterestWhereInput | ExpressInterestWhereInput[]
    investorId?: StringFilter<"ExpressInterest"> | string
    founderId?: StringFilter<"ExpressInterest"> | string
    videoId?: StringFilter<"ExpressInterest"> | string
    status?: StringFilter<"ExpressInterest"> | string
    message?: StringNullableFilter<"ExpressInterest"> | string | null
    createdAt?: DateTimeFilter<"ExpressInterest"> | Date | string
    updatedAt?: DateTimeFilter<"ExpressInterest"> | Date | string
    investor?: XOR<UserRelationFilter, UserWhereInput>
    founder?: XOR<UserRelationFilter, UserWhereInput>
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }, "id" | "investorId_founderId_videoId">

  export type ExpressInterestOrderByWithAggregationInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    videoId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpressInterestCountOrderByAggregateInput
    _max?: ExpressInterestMaxOrderByAggregateInput
    _min?: ExpressInterestMinOrderByAggregateInput
  }

  export type ExpressInterestScalarWhereWithAggregatesInput = {
    AND?: ExpressInterestScalarWhereWithAggregatesInput | ExpressInterestScalarWhereWithAggregatesInput[]
    OR?: ExpressInterestScalarWhereWithAggregatesInput[]
    NOT?: ExpressInterestScalarWhereWithAggregatesInput | ExpressInterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpressInterest"> | string
    investorId?: StringWithAggregatesFilter<"ExpressInterest"> | string
    founderId?: StringWithAggregatesFilter<"ExpressInterest"> | string
    videoId?: StringWithAggregatesFilter<"ExpressInterest"> | string
    status?: StringWithAggregatesFilter<"ExpressInterest"> | string
    message?: StringNullableWithAggregatesFilter<"ExpressInterest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExpressInterest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpressInterest"> | Date | string
  }

  export type ProfileRevealWhereInput = {
    AND?: ProfileRevealWhereInput | ProfileRevealWhereInput[]
    OR?: ProfileRevealWhereInput[]
    NOT?: ProfileRevealWhereInput | ProfileRevealWhereInput[]
    id?: StringFilter<"ProfileReveal"> | string
    investorId?: StringFilter<"ProfileReveal"> | string
    founderId?: StringFilter<"ProfileReveal"> | string
    revealedAt?: DateTimeFilter<"ProfileReveal"> | Date | string
    investor?: XOR<UserRelationFilter, UserWhereInput>
    founder?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileRevealOrderByWithRelationInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    revealedAt?: SortOrder
    investor?: UserOrderByWithRelationInput
    founder?: UserOrderByWithRelationInput
  }

  export type ProfileRevealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    investorId_founderId?: ProfileRevealInvestorIdFounderIdCompoundUniqueInput
    AND?: ProfileRevealWhereInput | ProfileRevealWhereInput[]
    OR?: ProfileRevealWhereInput[]
    NOT?: ProfileRevealWhereInput | ProfileRevealWhereInput[]
    investorId?: StringFilter<"ProfileReveal"> | string
    founderId?: StringFilter<"ProfileReveal"> | string
    revealedAt?: DateTimeFilter<"ProfileReveal"> | Date | string
    investor?: XOR<UserRelationFilter, UserWhereInput>
    founder?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "investorId_founderId">

  export type ProfileRevealOrderByWithAggregationInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    revealedAt?: SortOrder
    _count?: ProfileRevealCountOrderByAggregateInput
    _max?: ProfileRevealMaxOrderByAggregateInput
    _min?: ProfileRevealMinOrderByAggregateInput
  }

  export type ProfileRevealScalarWhereWithAggregatesInput = {
    AND?: ProfileRevealScalarWhereWithAggregatesInput | ProfileRevealScalarWhereWithAggregatesInput[]
    OR?: ProfileRevealScalarWhereWithAggregatesInput[]
    NOT?: ProfileRevealScalarWhereWithAggregatesInput | ProfileRevealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileReveal"> | string
    investorId?: StringWithAggregatesFilter<"ProfileReveal"> | string
    founderId?: StringWithAggregatesFilter<"ProfileReveal"> | string
    revealedAt?: DateTimeWithAggregatesFilter<"ProfileReveal"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    participant1Id?: StringFilter<"Conversation"> | string
    participant2Id?: StringFilter<"Conversation"> | string
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    isRevealed?: BoolFilter<"Conversation"> | boolean
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    participant1?: XOR<UserRelationFilter, UserWhereInput>
    participant2?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    participant1Id?: SortOrder
    participant2Id?: SortOrder
    status?: SortOrder
    isRevealed?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participant1?: UserOrderByWithRelationInput
    participant2?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    participant1Id_participant2Id?: ConversationParticipant1IdParticipant2IdCompoundUniqueInput
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    participant1Id?: StringFilter<"Conversation"> | string
    participant2Id?: StringFilter<"Conversation"> | string
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    isRevealed?: BoolFilter<"Conversation"> | boolean
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    participant1?: XOR<UserRelationFilter, UserWhereInput>
    participant2?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }, "id" | "participant1Id_participant2Id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    participant1Id?: SortOrder
    participant2Id?: SortOrder
    status?: SortOrder
    isRevealed?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    participant1Id?: StringWithAggregatesFilter<"Conversation"> | string
    participant2Id?: StringWithAggregatesFilter<"Conversation"> | string
    status?: EnumConversationStatusWithAggregatesFilter<"Conversation"> | $Enums.ConversationStatus
    isRevealed?: BoolWithAggregatesFilter<"Conversation"> | boolean
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    attachmentUrl?: StringNullableFilter<"Message"> | string | null
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    attachmentUrl?: StringNullableFilter<"Message"> | string | null
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    type?: StringWithAggregatesFilter<"Message"> | string
    attachmentUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type MessageLimitWhereInput = {
    AND?: MessageLimitWhereInput | MessageLimitWhereInput[]
    OR?: MessageLimitWhereInput[]
    NOT?: MessageLimitWhereInput | MessageLimitWhereInput[]
    id?: StringFilter<"MessageLimit"> | string
    userId?: StringFilter<"MessageLimit"> | string
    period?: StringFilter<"MessageLimit"> | string
    count?: IntFilter<"MessageLimit"> | number
    resetsAt?: DateTimeFilter<"MessageLimit"> | Date | string
    createdAt?: DateTimeFilter<"MessageLimit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageLimitOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    count?: SortOrder
    resetsAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MessageLimitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_period?: MessageLimitUserIdPeriodCompoundUniqueInput
    AND?: MessageLimitWhereInput | MessageLimitWhereInput[]
    OR?: MessageLimitWhereInput[]
    NOT?: MessageLimitWhereInput | MessageLimitWhereInput[]
    userId?: StringFilter<"MessageLimit"> | string
    period?: StringFilter<"MessageLimit"> | string
    count?: IntFilter<"MessageLimit"> | number
    resetsAt?: DateTimeFilter<"MessageLimit"> | Date | string
    createdAt?: DateTimeFilter<"MessageLimit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_period">

  export type MessageLimitOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    count?: SortOrder
    resetsAt?: SortOrder
    createdAt?: SortOrder
    _count?: MessageLimitCountOrderByAggregateInput
    _avg?: MessageLimitAvgOrderByAggregateInput
    _max?: MessageLimitMaxOrderByAggregateInput
    _min?: MessageLimitMinOrderByAggregateInput
    _sum?: MessageLimitSumOrderByAggregateInput
  }

  export type MessageLimitScalarWhereWithAggregatesInput = {
    AND?: MessageLimitScalarWhereWithAggregatesInput | MessageLimitScalarWhereWithAggregatesInput[]
    OR?: MessageLimitScalarWhereWithAggregatesInput[]
    NOT?: MessageLimitScalarWhereWithAggregatesInput | MessageLimitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageLimit"> | string
    userId?: StringWithAggregatesFilter<"MessageLimit"> | string
    period?: StringWithAggregatesFilter<"MessageLimit"> | string
    count?: IntWithAggregatesFilter<"MessageLimit"> | number
    resetsAt?: DateTimeWithAggregatesFilter<"MessageLimit"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageLimit"> | Date | string
  }

  export type ContentReportWhereInput = {
    AND?: ContentReportWhereInput | ContentReportWhereInput[]
    OR?: ContentReportWhereInput[]
    NOT?: ContentReportWhereInput | ContentReportWhereInput[]
    id?: StringFilter<"ContentReport"> | string
    reporterId?: StringFilter<"ContentReport"> | string
    videoId?: StringFilter<"ContentReport"> | string
    category?: EnumReportCategoryFilter<"ContentReport"> | $Enums.ReportCategory
    details?: StringNullableFilter<"ContentReport"> | string | null
    status?: StringFilter<"ContentReport"> | string
    reviewedAt?: DateTimeNullableFilter<"ContentReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentReport"> | Date | string
    reporter?: XOR<UserRelationFilter, UserWhereInput>
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }

  export type ContentReportOrderByWithRelationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    videoId?: SortOrder
    category?: SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reporter?: UserOrderByWithRelationInput
    video?: VideoOrderByWithRelationInput
  }

  export type ContentReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentReportWhereInput | ContentReportWhereInput[]
    OR?: ContentReportWhereInput[]
    NOT?: ContentReportWhereInput | ContentReportWhereInput[]
    reporterId?: StringFilter<"ContentReport"> | string
    videoId?: StringFilter<"ContentReport"> | string
    category?: EnumReportCategoryFilter<"ContentReport"> | $Enums.ReportCategory
    details?: StringNullableFilter<"ContentReport"> | string | null
    status?: StringFilter<"ContentReport"> | string
    reviewedAt?: DateTimeNullableFilter<"ContentReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentReport"> | Date | string
    reporter?: XOR<UserRelationFilter, UserWhereInput>
    video?: XOR<VideoRelationFilter, VideoWhereInput>
  }, "id">

  export type ContentReportOrderByWithAggregationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    videoId?: SortOrder
    category?: SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContentReportCountOrderByAggregateInput
    _max?: ContentReportMaxOrderByAggregateInput
    _min?: ContentReportMinOrderByAggregateInput
  }

  export type ContentReportScalarWhereWithAggregatesInput = {
    AND?: ContentReportScalarWhereWithAggregatesInput | ContentReportScalarWhereWithAggregatesInput[]
    OR?: ContentReportScalarWhereWithAggregatesInput[]
    NOT?: ContentReportScalarWhereWithAggregatesInput | ContentReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentReport"> | string
    reporterId?: StringWithAggregatesFilter<"ContentReport"> | string
    videoId?: StringWithAggregatesFilter<"ContentReport"> | string
    category?: EnumReportCategoryWithAggregatesFilter<"ContentReport"> | $Enums.ReportCategory
    details?: StringNullableWithAggregatesFilter<"ContentReport"> | string | null
    status?: StringWithAggregatesFilter<"ContentReport"> | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ContentReport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentReport"> | Date | string
  }

  export type ContentFlagWhereInput = {
    AND?: ContentFlagWhereInput | ContentFlagWhereInput[]
    OR?: ContentFlagWhereInput[]
    NOT?: ContentFlagWhereInput | ContentFlagWhereInput[]
    id?: StringFilter<"ContentFlag"> | string
    videoId?: StringFilter<"ContentFlag"> | string
    flagType?: StringFilter<"ContentFlag"> | string
    severity?: StringFilter<"ContentFlag"> | string
    details?: StringNullableFilter<"ContentFlag"> | string | null
    createdAt?: DateTimeFilter<"ContentFlag"> | Date | string
  }

  export type ContentFlagOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    flagType?: SortOrder
    severity?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ContentFlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentFlagWhereInput | ContentFlagWhereInput[]
    OR?: ContentFlagWhereInput[]
    NOT?: ContentFlagWhereInput | ContentFlagWhereInput[]
    videoId?: StringFilter<"ContentFlag"> | string
    flagType?: StringFilter<"ContentFlag"> | string
    severity?: StringFilter<"ContentFlag"> | string
    details?: StringNullableFilter<"ContentFlag"> | string | null
    createdAt?: DateTimeFilter<"ContentFlag"> | Date | string
  }, "id">

  export type ContentFlagOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    flagType?: SortOrder
    severity?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContentFlagCountOrderByAggregateInput
    _max?: ContentFlagMaxOrderByAggregateInput
    _min?: ContentFlagMinOrderByAggregateInput
  }

  export type ContentFlagScalarWhereWithAggregatesInput = {
    AND?: ContentFlagScalarWhereWithAggregatesInput | ContentFlagScalarWhereWithAggregatesInput[]
    OR?: ContentFlagScalarWhereWithAggregatesInput[]
    NOT?: ContentFlagScalarWhereWithAggregatesInput | ContentFlagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentFlag"> | string
    videoId?: StringWithAggregatesFilter<"ContentFlag"> | string
    flagType?: StringWithAggregatesFilter<"ContentFlag"> | string
    severity?: StringWithAggregatesFilter<"ContentFlag"> | string
    details?: StringNullableWithAggregatesFilter<"ContentFlag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentFlag"> | Date | string
  }

  export type ModerationActionRecordWhereInput = {
    AND?: ModerationActionRecordWhereInput | ModerationActionRecordWhereInput[]
    OR?: ModerationActionRecordWhereInput[]
    NOT?: ModerationActionRecordWhereInput | ModerationActionRecordWhereInput[]
    id?: StringFilter<"ModerationActionRecord"> | string
    userId?: StringFilter<"ModerationActionRecord"> | string
    action?: EnumModerationActionFilter<"ModerationActionRecord"> | $Enums.ModerationAction
    reason?: StringFilter<"ModerationActionRecord"> | string
    expiresAt?: DateTimeNullableFilter<"ModerationActionRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ModerationActionRecord"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ModerationActionRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ModerationActionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModerationActionRecordWhereInput | ModerationActionRecordWhereInput[]
    OR?: ModerationActionRecordWhereInput[]
    NOT?: ModerationActionRecordWhereInput | ModerationActionRecordWhereInput[]
    userId?: StringFilter<"ModerationActionRecord"> | string
    action?: EnumModerationActionFilter<"ModerationActionRecord"> | $Enums.ModerationAction
    reason?: StringFilter<"ModerationActionRecord"> | string
    expiresAt?: DateTimeNullableFilter<"ModerationActionRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ModerationActionRecord"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ModerationActionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ModerationActionRecordCountOrderByAggregateInput
    _max?: ModerationActionRecordMaxOrderByAggregateInput
    _min?: ModerationActionRecordMinOrderByAggregateInput
  }

  export type ModerationActionRecordScalarWhereWithAggregatesInput = {
    AND?: ModerationActionRecordScalarWhereWithAggregatesInput | ModerationActionRecordScalarWhereWithAggregatesInput[]
    OR?: ModerationActionRecordScalarWhereWithAggregatesInput[]
    NOT?: ModerationActionRecordScalarWhereWithAggregatesInput | ModerationActionRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModerationActionRecord"> | string
    userId?: StringWithAggregatesFilter<"ModerationActionRecord"> | string
    action?: EnumModerationActionWithAggregatesFilter<"ModerationActionRecord"> | $Enums.ModerationAction
    reason?: StringWithAggregatesFilter<"ModerationActionRecord"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ModerationActionRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ModerationActionRecord"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubId?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubId?: SortOrderInput | SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    tier?: EnumSubscriptionTierWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionTier
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type FeaturedContentWhereInput = {
    AND?: FeaturedContentWhereInput | FeaturedContentWhereInput[]
    OR?: FeaturedContentWhereInput[]
    NOT?: FeaturedContentWhereInput | FeaturedContentWhereInput[]
    id?: StringFilter<"FeaturedContent"> | string
    videoId?: StringFilter<"FeaturedContent"> | string
    startsAt?: DateTimeFilter<"FeaturedContent"> | Date | string
    expiresAt?: DateTimeFilter<"FeaturedContent"> | Date | string
    tier?: StringFilter<"FeaturedContent"> | string
    createdAt?: DateTimeFilter<"FeaturedContent"> | Date | string
  }

  export type FeaturedContentOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    tier?: SortOrder
    createdAt?: SortOrder
  }

  export type FeaturedContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeaturedContentWhereInput | FeaturedContentWhereInput[]
    OR?: FeaturedContentWhereInput[]
    NOT?: FeaturedContentWhereInput | FeaturedContentWhereInput[]
    videoId?: StringFilter<"FeaturedContent"> | string
    startsAt?: DateTimeFilter<"FeaturedContent"> | Date | string
    expiresAt?: DateTimeFilter<"FeaturedContent"> | Date | string
    tier?: StringFilter<"FeaturedContent"> | string
    createdAt?: DateTimeFilter<"FeaturedContent"> | Date | string
  }, "id">

  export type FeaturedContentOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    tier?: SortOrder
    createdAt?: SortOrder
    _count?: FeaturedContentCountOrderByAggregateInput
    _max?: FeaturedContentMaxOrderByAggregateInput
    _min?: FeaturedContentMinOrderByAggregateInput
  }

  export type FeaturedContentScalarWhereWithAggregatesInput = {
    AND?: FeaturedContentScalarWhereWithAggregatesInput | FeaturedContentScalarWhereWithAggregatesInput[]
    OR?: FeaturedContentScalarWhereWithAggregatesInput[]
    NOT?: FeaturedContentScalarWhereWithAggregatesInput | FeaturedContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeaturedContent"> | string
    videoId?: StringWithAggregatesFilter<"FeaturedContent"> | string
    startsAt?: DateTimeWithAggregatesFilter<"FeaturedContent"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"FeaturedContent"> | Date | string
    tier?: StringWithAggregatesFilter<"FeaturedContent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedContent"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    priority?: EnumNotificationPriorityWithAggregatesFilter<"Notification"> | $Enums.NotificationPriority
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    data?: JsonNullableWithAggregatesFilter<"Notification">
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    type?: StringFilter<"NotificationPreference"> | string
    pushEnabled?: BoolFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_type?: NotificationPreferenceUserIdTypeCompoundUniqueInput
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    userId?: StringFilter<"NotificationPreference"> | string
    type?: StringFilter<"NotificationPreference"> | string
    pushEnabled?: BoolFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_type">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    type?: StringWithAggregatesFilter<"NotificationPreference"> | string
    pushEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
  }

  export type FeedPreferenceWhereInput = {
    AND?: FeedPreferenceWhereInput | FeedPreferenceWhereInput[]
    OR?: FeedPreferenceWhereInput[]
    NOT?: FeedPreferenceWhereInput | FeedPreferenceWhereInput[]
    id?: StringFilter<"FeedPreference"> | string
    userId?: StringFilter<"FeedPreference"> | string
    industries?: StringNullableListFilter<"FeedPreference">
    stages?: StringNullableListFilter<"FeedPreference">
    notifyOnMatches?: BoolFilter<"FeedPreference"> | boolean
    createdAt?: DateTimeFilter<"FeedPreference"> | Date | string
    updatedAt?: DateTimeFilter<"FeedPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FeedPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    industries?: SortOrder
    stages?: SortOrder
    notifyOnMatches?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FeedPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: FeedPreferenceWhereInput | FeedPreferenceWhereInput[]
    OR?: FeedPreferenceWhereInput[]
    NOT?: FeedPreferenceWhereInput | FeedPreferenceWhereInput[]
    industries?: StringNullableListFilter<"FeedPreference">
    stages?: StringNullableListFilter<"FeedPreference">
    notifyOnMatches?: BoolFilter<"FeedPreference"> | boolean
    createdAt?: DateTimeFilter<"FeedPreference"> | Date | string
    updatedAt?: DateTimeFilter<"FeedPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type FeedPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    industries?: SortOrder
    stages?: SortOrder
    notifyOnMatches?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedPreferenceCountOrderByAggregateInput
    _max?: FeedPreferenceMaxOrderByAggregateInput
    _min?: FeedPreferenceMinOrderByAggregateInput
  }

  export type FeedPreferenceScalarWhereWithAggregatesInput = {
    AND?: FeedPreferenceScalarWhereWithAggregatesInput | FeedPreferenceScalarWhereWithAggregatesInput[]
    OR?: FeedPreferenceScalarWhereWithAggregatesInput[]
    NOT?: FeedPreferenceScalarWhereWithAggregatesInput | FeedPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedPreference"> | string
    userId?: StringWithAggregatesFilter<"FeedPreference"> | string
    industries?: StringNullableListFilter<"FeedPreference">
    stages?: StringNullableListFilter<"FeedPreference">
    notifyOnMatches?: BoolWithAggregatesFilter<"FeedPreference"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FeedPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeedPreference"> | Date | string
  }

  export type SearchHistoryWhereInput = {
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    userId?: StringFilter<"SearchHistory"> | string
    query?: StringFilter<"SearchHistory"> | string
    filters?: JsonNullableFilter<"SearchHistory">
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SearchHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    filters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SearchHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    userId?: StringFilter<"SearchHistory"> | string
    query?: StringFilter<"SearchHistory"> | string
    filters?: JsonNullableFilter<"SearchHistory">
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SearchHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    filters?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SearchHistoryCountOrderByAggregateInput
    _max?: SearchHistoryMaxOrderByAggregateInput
    _min?: SearchHistoryMinOrderByAggregateInput
  }

  export type SearchHistoryScalarWhereWithAggregatesInput = {
    AND?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    OR?: SearchHistoryScalarWhereWithAggregatesInput[]
    NOT?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchHistory"> | string
    userId?: StringWithAggregatesFilter<"SearchHistory"> | string
    query?: StringWithAggregatesFilter<"SearchHistory"> | string
    filters?: JsonNullableWithAggregatesFilter<"SearchHistory">
    createdAt?: DateTimeWithAggregatesFilter<"SearchHistory"> | Date | string
  }

  export type OnboardingProgressWhereInput = {
    AND?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    OR?: OnboardingProgressWhereInput[]
    NOT?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    id?: StringFilter<"OnboardingProgress"> | string
    userId?: StringFilter<"OnboardingProgress"> | string
    step?: IntFilter<"OnboardingProgress"> | number
    completed?: BoolFilter<"OnboardingProgress"> | boolean
    data?: JsonNullableFilter<"OnboardingProgress">
    completedAt?: DateTimeNullableFilter<"OnboardingProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    updatedAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OnboardingProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    completed?: SortOrder
    data?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OnboardingProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    OR?: OnboardingProgressWhereInput[]
    NOT?: OnboardingProgressWhereInput | OnboardingProgressWhereInput[]
    step?: IntFilter<"OnboardingProgress"> | number
    completed?: BoolFilter<"OnboardingProgress"> | boolean
    data?: JsonNullableFilter<"OnboardingProgress">
    completedAt?: DateTimeNullableFilter<"OnboardingProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    updatedAt?: DateTimeFilter<"OnboardingProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type OnboardingProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    completed?: SortOrder
    data?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OnboardingProgressCountOrderByAggregateInput
    _avg?: OnboardingProgressAvgOrderByAggregateInput
    _max?: OnboardingProgressMaxOrderByAggregateInput
    _min?: OnboardingProgressMinOrderByAggregateInput
    _sum?: OnboardingProgressSumOrderByAggregateInput
  }

  export type OnboardingProgressScalarWhereWithAggregatesInput = {
    AND?: OnboardingProgressScalarWhereWithAggregatesInput | OnboardingProgressScalarWhereWithAggregatesInput[]
    OR?: OnboardingProgressScalarWhereWithAggregatesInput[]
    NOT?: OnboardingProgressScalarWhereWithAggregatesInput | OnboardingProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OnboardingProgress"> | string
    userId?: StringWithAggregatesFilter<"OnboardingProgress"> | string
    step?: IntWithAggregatesFilter<"OnboardingProgress"> | number
    completed?: BoolWithAggregatesFilter<"OnboardingProgress"> | boolean
    data?: JsonNullableWithAggregatesFilter<"OnboardingProgress">
    completedAt?: DateTimeNullableWithAggregatesFilter<"OnboardingProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OnboardingProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OnboardingProgress"> | Date | string
  }

  export type AccountTypeChangeWhereInput = {
    AND?: AccountTypeChangeWhereInput | AccountTypeChangeWhereInput[]
    OR?: AccountTypeChangeWhereInput[]
    NOT?: AccountTypeChangeWhereInput | AccountTypeChangeWhereInput[]
    id?: StringFilter<"AccountTypeChange"> | string
    userId?: StringFilter<"AccountTypeChange"> | string
    fromType?: EnumAccountTypeFilter<"AccountTypeChange"> | $Enums.AccountType
    toType?: EnumAccountTypeFilter<"AccountTypeChange"> | $Enums.AccountType
    changedAt?: DateTimeFilter<"AccountTypeChange"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountTypeChangeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    fromType?: SortOrder
    toType?: SortOrder
    changedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountTypeChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountTypeChangeWhereInput | AccountTypeChangeWhereInput[]
    OR?: AccountTypeChangeWhereInput[]
    NOT?: AccountTypeChangeWhereInput | AccountTypeChangeWhereInput[]
    userId?: StringFilter<"AccountTypeChange"> | string
    fromType?: EnumAccountTypeFilter<"AccountTypeChange"> | $Enums.AccountType
    toType?: EnumAccountTypeFilter<"AccountTypeChange"> | $Enums.AccountType
    changedAt?: DateTimeFilter<"AccountTypeChange"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AccountTypeChangeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    fromType?: SortOrder
    toType?: SortOrder
    changedAt?: SortOrder
    _count?: AccountTypeChangeCountOrderByAggregateInput
    _max?: AccountTypeChangeMaxOrderByAggregateInput
    _min?: AccountTypeChangeMinOrderByAggregateInput
  }

  export type AccountTypeChangeScalarWhereWithAggregatesInput = {
    AND?: AccountTypeChangeScalarWhereWithAggregatesInput | AccountTypeChangeScalarWhereWithAggregatesInput[]
    OR?: AccountTypeChangeScalarWhereWithAggregatesInput[]
    NOT?: AccountTypeChangeScalarWhereWithAggregatesInput | AccountTypeChangeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountTypeChange"> | string
    userId?: StringWithAggregatesFilter<"AccountTypeChange"> | string
    fromType?: EnumAccountTypeWithAggregatesFilter<"AccountTypeChange"> | $Enums.AccountType
    toType?: EnumAccountTypeWithAggregatesFilter<"AccountTypeChange"> | $Enums.AccountType
    changedAt?: DateTimeWithAggregatesFilter<"AccountTypeChange"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlockCreateInput = {
    id?: string
    createdAt?: Date | string
    blocker: UserCreateNestedOneWithoutBlockedUsersInput
    blocked: UserCreateNestedOneWithoutBlockedByInput
  }

  export type BlockUncheckedCreateInput = {
    id?: string
    blockerId: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: UserUpdateOneRequiredWithoutBlockedUsersNestedInput
    blocked?: UserUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyInput = {
    id?: string
    blockerId: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    device?: string | null
    ip?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    device?: string | null
    ip?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    device?: string | null
    ip?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    socialLinks?: SocialLinkCreateNestedManyWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    socialLinks?: SocialLinkUncheckedCreateNestedManyWithoutProfileInput
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    showInSearch?: BoolFieldUpdateOperationsInput | boolean
    showActivityStatus?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFromEveryone?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    socialLinks?: SocialLinkUpdateManyWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    showInSearch?: BoolFieldUpdateOperationsInput | boolean
    showActivityStatus?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFromEveryone?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: SocialLinkUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    showInSearch?: BoolFieldUpdateOperationsInput | boolean
    showActivityStatus?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFromEveryone?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    showInSearch?: BoolFieldUpdateOperationsInput | boolean
    showActivityStatus?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFromEveryone?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinkCreateInput = {
    id?: string
    platform: string
    url: string
    profile: UserProfileCreateNestedOneWithoutSocialLinksInput
  }

  export type SocialLinkUncheckedCreateInput = {
    id?: string
    profileId: string
    platform: string
    url: string
  }

  export type SocialLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    profile?: UserProfileUpdateOneRequiredWithoutSocialLinksNestedInput
  }

  export type SocialLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkCreateManyInput = {
    id?: string
    profileId: string
    platform: string
    url: string
  }

  export type SocialLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type FounderProfileCreateInput = {
    id?: string
    tagline?: string | null
    companyName?: string | null
    industry?: string | null
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: string | null
    education?: string | null
    skills?: FounderProfileCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFounderProfileInput
    fundraisingDetails?: FundraisingDetailsCreateNestedOneWithoutFounderProfileInput
  }

  export type FounderProfileUncheckedCreateInput = {
    id?: string
    userId: string
    tagline?: string | null
    companyName?: string | null
    industry?: string | null
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: string | null
    education?: string | null
    skills?: FounderProfileCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    fundraisingDetails?: FundraisingDetailsUncheckedCreateNestedOneWithoutFounderProfileInput
  }

  export type FounderProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    lookingForFunding?: BoolFieldUpdateOperationsInput | boolean
    lookingForCofounder?: BoolFieldUpdateOperationsInput | boolean
    lookingForFeedback?: BoolFieldUpdateOperationsInput | boolean
    previousVentures?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: FounderProfileUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFounderProfileNestedInput
    fundraisingDetails?: FundraisingDetailsUpdateOneWithoutFounderProfileNestedInput
  }

  export type FounderProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    lookingForFunding?: BoolFieldUpdateOperationsInput | boolean
    lookingForCofounder?: BoolFieldUpdateOperationsInput | boolean
    lookingForFeedback?: BoolFieldUpdateOperationsInput | boolean
    previousVentures?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: FounderProfileUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundraisingDetails?: FundraisingDetailsUncheckedUpdateOneWithoutFounderProfileNestedInput
  }

  export type FounderProfileCreateManyInput = {
    id?: string
    userId: string
    tagline?: string | null
    companyName?: string | null
    industry?: string | null
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: string | null
    education?: string | null
    skills?: FounderProfileCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    lookingForFunding?: BoolFieldUpdateOperationsInput | boolean
    lookingForCofounder?: BoolFieldUpdateOperationsInput | boolean
    lookingForFeedback?: BoolFieldUpdateOperationsInput | boolean
    previousVentures?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: FounderProfileUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    lookingForFunding?: BoolFieldUpdateOperationsInput | boolean
    lookingForCofounder?: BoolFieldUpdateOperationsInput | boolean
    lookingForFeedback?: BoolFieldUpdateOperationsInput | boolean
    previousVentures?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: FounderProfileUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundraisingDetailsCreateInput = {
    id?: string
    stage: string
    amount?: number | null
    industry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founderProfile: FounderProfileCreateNestedOneWithoutFundraisingDetailsInput
  }

  export type FundraisingDetailsUncheckedCreateInput = {
    id?: string
    founderId: string
    stage: string
    amount?: number | null
    industry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundraisingDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderProfile?: FounderProfileUpdateOneRequiredWithoutFundraisingDetailsNestedInput
  }

  export type FundraisingDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundraisingDetailsCreateManyInput = {
    id?: string
    founderId: string
    stage: string
    amount?: number | null
    industry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundraisingDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundraisingDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorProfileCreateInput = {
    id?: string
    firm?: string | null
    title?: string | null
    thesis?: string | null
    thesisVideo?: string | null
    checkSizeMin?: number | null
    checkSizeMax?: number | null
    stages?: InvestorProfileCreatestagesInput | string[]
    industries?: InvestorProfileCreateindustriesInput | string[]
    geographies?: InvestorProfileCreategeographiesInput | string[]
    isPublicMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestorProfileInput
    portfolio?: PortfolioCreateNestedManyWithoutInvestorProfileInput
  }

  export type InvestorProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firm?: string | null
    title?: string | null
    thesis?: string | null
    thesisVideo?: string | null
    checkSizeMin?: number | null
    checkSizeMax?: number | null
    stages?: InvestorProfileCreatestagesInput | string[]
    industries?: InvestorProfileCreateindustriesInput | string[]
    geographies?: InvestorProfileCreategeographiesInput | string[]
    isPublicMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioUncheckedCreateNestedManyWithoutInvestorProfileInput
  }

  export type InvestorProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    thesisVideo?: NullableStringFieldUpdateOperationsInput | string | null
    checkSizeMin?: NullableIntFieldUpdateOperationsInput | number | null
    checkSizeMax?: NullableIntFieldUpdateOperationsInput | number | null
    stages?: InvestorProfileUpdatestagesInput | string[]
    industries?: InvestorProfileUpdateindustriesInput | string[]
    geographies?: InvestorProfileUpdategeographiesInput | string[]
    isPublicMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestorProfileNestedInput
    portfolio?: PortfolioUpdateManyWithoutInvestorProfileNestedInput
  }

  export type InvestorProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    thesisVideo?: NullableStringFieldUpdateOperationsInput | string | null
    checkSizeMin?: NullableIntFieldUpdateOperationsInput | number | null
    checkSizeMax?: NullableIntFieldUpdateOperationsInput | number | null
    stages?: InvestorProfileUpdatestagesInput | string[]
    industries?: InvestorProfileUpdateindustriesInput | string[]
    geographies?: InvestorProfileUpdategeographiesInput | string[]
    isPublicMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUncheckedUpdateManyWithoutInvestorProfileNestedInput
  }

  export type InvestorProfileCreateManyInput = {
    id?: string
    userId: string
    firm?: string | null
    title?: string | null
    thesis?: string | null
    thesisVideo?: string | null
    checkSizeMin?: number | null
    checkSizeMax?: number | null
    stages?: InvestorProfileCreatestagesInput | string[]
    industries?: InvestorProfileCreateindustriesInput | string[]
    geographies?: InvestorProfileCreategeographiesInput | string[]
    isPublicMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    thesisVideo?: NullableStringFieldUpdateOperationsInput | string | null
    checkSizeMin?: NullableIntFieldUpdateOperationsInput | number | null
    checkSizeMax?: NullableIntFieldUpdateOperationsInput | number | null
    stages?: InvestorProfileUpdatestagesInput | string[]
    industries?: InvestorProfileUpdateindustriesInput | string[]
    geographies?: InvestorProfileUpdategeographiesInput | string[]
    isPublicMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    thesisVideo?: NullableStringFieldUpdateOperationsInput | string | null
    checkSizeMin?: NullableIntFieldUpdateOperationsInput | number | null
    checkSizeMax?: NullableIntFieldUpdateOperationsInput | number | null
    stages?: InvestorProfileUpdatestagesInput | string[]
    industries?: InvestorProfileUpdateindustriesInput | string[]
    geographies?: InvestorProfileUpdategeographiesInput | string[]
    isPublicMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioCreateInput = {
    id?: string
    companyName: string
    companyUrl?: string | null
    investmentYear?: number | null
    investorProfile: InvestorProfileCreateNestedOneWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateInput = {
    id?: string
    investorProfileId: string
    companyName: string
    companyUrl?: string | null
    investmentYear?: number | null
  }

  export type PortfolioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    investmentYear?: NullableIntFieldUpdateOperationsInput | number | null
    investorProfile?: InvestorProfileUpdateOneRequiredWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorProfileId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    investmentYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PortfolioCreateManyInput = {
    id?: string
    investorProfileId: string
    companyName: string
    companyUrl?: string | null
    investmentYear?: number | null
  }

  export type PortfolioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    investmentYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PortfolioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorProfileId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    investmentYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BuilderProfileCreateInput = {
    id?: string
    skills?: BuilderProfileCreateskillsInput | string[]
    portfolioUrls?: BuilderProfileCreateportfolioUrlsInput | string[]
    availability?: string
    lookingForProject?: boolean
    industryInterests?: BuilderProfileCreateindustryInterestsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBuilderProfileInput
  }

  export type BuilderProfileUncheckedCreateInput = {
    id?: string
    userId: string
    skills?: BuilderProfileCreateskillsInput | string[]
    portfolioUrls?: BuilderProfileCreateportfolioUrlsInput | string[]
    availability?: string
    lookingForProject?: boolean
    industryInterests?: BuilderProfileCreateindustryInterestsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuilderProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: BuilderProfileUpdateskillsInput | string[]
    portfolioUrls?: BuilderProfileUpdateportfolioUrlsInput | string[]
    availability?: StringFieldUpdateOperationsInput | string
    lookingForProject?: BoolFieldUpdateOperationsInput | boolean
    industryInterests?: BuilderProfileUpdateindustryInterestsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBuilderProfileNestedInput
  }

  export type BuilderProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skills?: BuilderProfileUpdateskillsInput | string[]
    portfolioUrls?: BuilderProfileUpdateportfolioUrlsInput | string[]
    availability?: StringFieldUpdateOperationsInput | string
    lookingForProject?: BoolFieldUpdateOperationsInput | boolean
    industryInterests?: BuilderProfileUpdateindustryInterestsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuilderProfileCreateManyInput = {
    id?: string
    userId: string
    skills?: BuilderProfileCreateskillsInput | string[]
    portfolioUrls?: BuilderProfileCreateportfolioUrlsInput | string[]
    availability?: string
    lookingForProject?: boolean
    industryInterests?: BuilderProfileCreateindustryInterestsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuilderProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: BuilderProfileUpdateskillsInput | string[]
    portfolioUrls?: BuilderProfileUpdateportfolioUrlsInput | string[]
    availability?: StringFieldUpdateOperationsInput | string
    lookingForProject?: BoolFieldUpdateOperationsInput | boolean
    industryInterests?: BuilderProfileUpdateindustryInterestsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuilderProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    skills?: BuilderProfileUpdateskillsInput | string[]
    portfolioUrls?: BuilderProfileUpdateportfolioUrlsInput | string[]
    availability?: StringFieldUpdateOperationsInput | string
    lookingForProject?: BoolFieldUpdateOperationsInput | boolean
    industryInterests?: BuilderProfileUpdateindustryInterestsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorVerificationCreateInput = {
    id?: string
    linkedinUrl?: string | null
    proofUrl?: string | null
    proofDocument?: string | null
    status?: $Enums.VerificationStatus
    reviewerNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestorVerificationInput
  }

  export type InvestorVerificationUncheckedCreateInput = {
    id?: string
    userId: string
    linkedinUrl?: string | null
    proofUrl?: string | null
    proofDocument?: string | null
    status?: $Enums.VerificationStatus
    reviewerNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestorVerificationNestedInput
  }

  export type InvestorVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorVerificationCreateManyInput = {
    id?: string
    userId: string
    linkedinUrl?: string | null
    proofUrl?: string | null
    proofDocument?: string | null
    status?: $Enums.VerificationStatus
    reviewerNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type VideoCreateManyInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoTranscriptCreateInput = {
    id?: string
    text: string
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutTranscriptInput
  }

  export type VideoTranscriptUncheckedCreateInput = {
    id?: string
    videoId: string
    text: string
    createdAt?: Date | string
  }

  export type VideoTranscriptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutTranscriptNestedInput
  }

  export type VideoTranscriptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoTranscriptCreateManyInput = {
    id?: string
    videoId: string
    text: string
    createdAt?: Date | string
  }

  export type VideoTranscriptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoTranscriptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoAnalyticsCreateInput = {
    id?: string
    totalViews?: number
    uniqueViews?: number
    investorViews?: number
    founderViews?: number
    builderViews?: number
    averageWatchTime?: number
    completionRate?: number
    replayRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    video: VideoCreateNestedOneWithoutAnalyticsInput
  }

  export type VideoAnalyticsUncheckedCreateInput = {
    id?: string
    videoId: string
    totalViews?: number
    uniqueViews?: number
    investorViews?: number
    founderViews?: number
    builderViews?: number
    averageWatchTime?: number
    completionRate?: number
    replayRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    investorViews?: IntFieldUpdateOperationsInput | number
    founderViews?: IntFieldUpdateOperationsInput | number
    builderViews?: IntFieldUpdateOperationsInput | number
    averageWatchTime?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    replayRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type VideoAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    investorViews?: IntFieldUpdateOperationsInput | number
    founderViews?: IntFieldUpdateOperationsInput | number
    builderViews?: IntFieldUpdateOperationsInput | number
    averageWatchTime?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    replayRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoAnalyticsCreateManyInput = {
    id?: string
    videoId: string
    totalViews?: number
    uniqueViews?: number
    investorViews?: number
    founderViews?: number
    builderViews?: number
    averageWatchTime?: number
    completionRate?: number
    replayRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    investorViews?: IntFieldUpdateOperationsInput | number
    founderViews?: IntFieldUpdateOperationsInput | number
    builderViews?: IntFieldUpdateOperationsInput | number
    averageWatchTime?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    replayRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    investorViews?: IntFieldUpdateOperationsInput | number
    founderViews?: IntFieldUpdateOperationsInput | number
    builderViews?: IntFieldUpdateOperationsInput | number
    averageWatchTime?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    replayRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoViewCreateInput = {
    id?: string
    watchTime?: number
    completed?: boolean
    replays?: number
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutViewsInput
    viewer: UserCreateNestedOneWithoutVideoViewsInput
  }

  export type VideoViewUncheckedCreateInput = {
    id?: string
    videoId: string
    viewerId: string
    watchTime?: number
    completed?: boolean
    replays?: number
    createdAt?: Date | string
  }

  export type VideoViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutViewsNestedInput
    viewer?: UserUpdateOneRequiredWithoutVideoViewsNestedInput
  }

  export type VideoViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    viewerId?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoViewCreateManyInput = {
    id?: string
    videoId: string
    viewerId: string
    watchTime?: number
    completed?: boolean
    replays?: number
    createdAt?: Date | string
  }

  export type VideoViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    viewerId?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    videoId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    videoId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    video: VideoCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    videoId: string
    userId: string
    content: string
    parentId?: string | null
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    videoId: string
    userId: string
    content: string
    parentId?: string | null
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveCreateInput = {
    id?: string
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutSavesInput
    user: UserCreateNestedOneWithoutSavesInput
    list?: SaveListCreateNestedOneWithoutSavesInput
  }

  export type SaveUncheckedCreateInput = {
    id?: string
    videoId: string
    userId: string
    listId?: string | null
    createdAt?: Date | string
  }

  export type SaveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutSavesNestedInput
    user?: UserUpdateOneRequiredWithoutSavesNestedInput
    list?: SaveListUpdateOneWithoutSavesNestedInput
  }

  export type SaveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveCreateManyInput = {
    id?: string
    videoId: string
    userId: string
    listId?: string | null
    createdAt?: Date | string
  }

  export type SaveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveListCreateInput = {
    id?: string
    userId: string
    name: string
    isDefault?: boolean
    createdAt?: Date | string
    saves?: SaveCreateNestedManyWithoutListInput
  }

  export type SaveListUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    isDefault?: boolean
    createdAt?: Date | string
    saves?: SaveUncheckedCreateNestedManyWithoutListInput
  }

  export type SaveListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saves?: SaveUpdateManyWithoutListNestedInput
  }

  export type SaveListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saves?: SaveUncheckedUpdateManyWithoutListNestedInput
  }

  export type SaveListCreateManyInput = {
    id?: string
    userId: string
    name: string
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type SaveListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareCreateInput = {
    id?: string
    platform: string
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutSharesInput
    user: UserCreateNestedOneWithoutSharesInput
  }

  export type ShareUncheckedCreateInput = {
    id?: string
    videoId: string
    userId: string
    platform: string
    createdAt?: Date | string
  }

  export type ShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutSharesNestedInput
    user?: UserUpdateOneRequiredWithoutSharesNestedInput
  }

  export type ShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareCreateManyInput = {
    id?: string
    videoId: string
    userId: string
    platform: string
    createdAt?: Date | string
  }

  export type ShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpressInterestCreateInput = {
    id?: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investor: UserCreateNestedOneWithoutExpressedInterestsInput
    founder: UserCreateNestedOneWithoutReceivedInterestsInput
    video: VideoCreateNestedOneWithoutExpressInterestsInput
  }

  export type ExpressInterestUncheckedCreateInput = {
    id?: string
    investorId: string
    founderId: string
    videoId: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpressInterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: UserUpdateOneRequiredWithoutExpressedInterestsNestedInput
    founder?: UserUpdateOneRequiredWithoutReceivedInterestsNestedInput
    video?: VideoUpdateOneRequiredWithoutExpressInterestsNestedInput
  }

  export type ExpressInterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpressInterestCreateManyInput = {
    id?: string
    investorId: string
    founderId: string
    videoId: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpressInterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpressInterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileRevealCreateInput = {
    id?: string
    revealedAt?: Date | string
    investor: UserCreateNestedOneWithoutProfileRevealsAsInvestorInput
    founder: UserCreateNestedOneWithoutProfileRevealsAsFounderInput
  }

  export type ProfileRevealUncheckedCreateInput = {
    id?: string
    investorId: string
    founderId: string
    revealedAt?: Date | string
  }

  export type ProfileRevealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: UserUpdateOneRequiredWithoutProfileRevealsAsInvestorNestedInput
    founder?: UserUpdateOneRequiredWithoutProfileRevealsAsFounderNestedInput
  }

  export type ProfileRevealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileRevealCreateManyInput = {
    id?: string
    investorId: string
    founderId: string
    revealedAt?: Date | string
  }

  export type ProfileRevealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileRevealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant1: UserCreateNestedOneWithoutConversations1Input
    participant2: UserCreateNestedOneWithoutConversations2Input
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    participant1Id: string
    participant2Id: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant1?: UserUpdateOneRequiredWithoutConversations1NestedInput
    participant2?: UserUpdateOneRequiredWithoutConversations2NestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1Id?: StringFieldUpdateOperationsInput | string
    participant2Id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    participant1Id: string
    participant2Id: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1Id?: StringFieldUpdateOperationsInput | string
    participant2Id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    type?: string
    attachmentUrl?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    type?: string
    attachmentUrl?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    type?: string
    attachmentUrl?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLimitCreateInput = {
    id?: string
    period: string
    count?: number
    resetsAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesSentInput
  }

  export type MessageLimitUncheckedCreateInput = {
    id?: string
    userId: string
    period: string
    count?: number
    resetsAt: Date | string
    createdAt?: Date | string
  }

  export type MessageLimitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type MessageLimitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLimitCreateManyInput = {
    id?: string
    userId: string
    period: string
    count?: number
    resetsAt: Date | string
    createdAt?: Date | string
  }

  export type MessageLimitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLimitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReportCreateInput = {
    id?: string
    category: $Enums.ReportCategory
    details?: string | null
    status?: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutContentReportsInput
    video: VideoCreateNestedOneWithoutReportsInput
  }

  export type ContentReportUncheckedCreateInput = {
    id?: string
    reporterId: string
    videoId: string
    category: $Enums.ReportCategory
    details?: string | null
    status?: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContentReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutContentReportsNestedInput
    video?: VideoUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ContentReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReportCreateManyInput = {
    id?: string
    reporterId: string
    videoId: string
    category: $Enums.ReportCategory
    details?: string | null
    status?: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContentReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentFlagCreateInput = {
    id?: string
    videoId: string
    flagType: string
    severity: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ContentFlagUncheckedCreateInput = {
    id?: string
    videoId: string
    flagType: string
    severity: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ContentFlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    flagType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentFlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    flagType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentFlagCreateManyInput = {
    id?: string
    videoId: string
    flagType: string
    severity: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ContentFlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    flagType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentFlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    flagType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationActionRecordCreateInput = {
    id?: string
    action: $Enums.ModerationAction
    reason: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutModerationActionsInput
  }

  export type ModerationActionRecordUncheckedCreateInput = {
    id?: string
    userId: string
    action: $Enums.ModerationAction
    reason: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModerationActionRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutModerationActionsNestedInput
  }

  export type ModerationActionRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationActionRecordCreateManyInput = {
    id?: string
    userId: string
    action: $Enums.ModerationAction
    reason: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModerationActionRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationActionRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    stripeSubId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    tier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    stripeSubId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    tier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    stripeSubId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedContentCreateInput = {
    id?: string
    videoId: string
    startsAt: Date | string
    expiresAt: Date | string
    tier: string
    createdAt?: Date | string
  }

  export type FeaturedContentUncheckedCreateInput = {
    id?: string
    videoId: string
    startsAt: Date | string
    expiresAt: Date | string
    tier: string
    createdAt?: Date | string
  }

  export type FeaturedContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedContentCreateManyInput = {
    id?: string
    videoId: string
    startsAt: Date | string
    expiresAt: Date | string
    tier: string
    createdAt?: Date | string
  }

  export type FeaturedContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    priority?: $Enums.NotificationPriority
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    priority?: $Enums.NotificationPriority
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    priority?: $Enums.NotificationPriority
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    type: string
    pushEnabled?: boolean
    emailEnabled?: boolean
    user: UserCreateNestedOneWithoutNotificationPrefsInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    pushEnabled?: boolean
    emailEnabled?: boolean
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotificationPrefsNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    type: string
    pushEnabled?: boolean
    emailEnabled?: boolean
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeedPreferenceCreateInput = {
    id?: string
    industries?: FeedPreferenceCreateindustriesInput | string[]
    stages?: FeedPreferenceCreatestagesInput | string[]
    notifyOnMatches?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFeedPreferencesInput
  }

  export type FeedPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    industries?: FeedPreferenceCreateindustriesInput | string[]
    stages?: FeedPreferenceCreatestagesInput | string[]
    notifyOnMatches?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    industries?: FeedPreferenceUpdateindustriesInput | string[]
    stages?: FeedPreferenceUpdatestagesInput | string[]
    notifyOnMatches?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedPreferencesNestedInput
  }

  export type FeedPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    industries?: FeedPreferenceUpdateindustriesInput | string[]
    stages?: FeedPreferenceUpdatestagesInput | string[]
    notifyOnMatches?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedPreferenceCreateManyInput = {
    id?: string
    userId: string
    industries?: FeedPreferenceCreateindustriesInput | string[]
    stages?: FeedPreferenceCreatestagesInput | string[]
    notifyOnMatches?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    industries?: FeedPreferenceUpdateindustriesInput | string[]
    stages?: FeedPreferenceUpdatestagesInput | string[]
    notifyOnMatches?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    industries?: FeedPreferenceUpdateindustriesInput | string[]
    stages?: FeedPreferenceUpdatestagesInput | string[]
    notifyOnMatches?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryCreateInput = {
    id?: string
    query: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSearchHistoryInput
  }

  export type SearchHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    query: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SearchHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSearchHistoryNestedInput
  }

  export type SearchHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryCreateManyInput = {
    id?: string
    userId: string
    query: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SearchHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressCreateInput = {
    id?: string
    step?: number
    completed?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOnboardingProgressInput
  }

  export type OnboardingProgressUncheckedCreateInput = {
    id?: string
    userId: string
    step?: number
    completed?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingProgressNestedInput
  }

  export type OnboardingProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressCreateManyInput = {
    id?: string
    userId: string
    step?: number
    completed?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountTypeChangeCreateInput = {
    id?: string
    fromType: $Enums.AccountType
    toType: $Enums.AccountType
    changedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountTypeChangesInput
  }

  export type AccountTypeChangeUncheckedCreateInput = {
    id?: string
    userId: string
    fromType: $Enums.AccountType
    toType: $Enums.AccountType
    changedAt?: Date | string
  }

  export type AccountTypeChangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    toType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountTypeChangesNestedInput
  }

  export type AccountTypeChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fromType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    toType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountTypeChangeCreateManyInput = {
    id?: string
    userId: string
    fromType: $Enums.AccountType
    toType: $Enums.AccountType
    changedAt?: Date | string
  }

  export type AccountTypeChangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    toType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountTypeChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fromType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    toType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserProfileNullableRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type FounderProfileNullableRelationFilter = {
    is?: FounderProfileWhereInput | null
    isNot?: FounderProfileWhereInput | null
  }

  export type InvestorProfileNullableRelationFilter = {
    is?: InvestorProfileWhereInput | null
    isNot?: InvestorProfileWhereInput | null
  }

  export type BuilderProfileNullableRelationFilter = {
    is?: BuilderProfileWhereInput | null
    isNot?: BuilderProfileWhereInput | null
  }

  export type InvestorVerificationNullableRelationFilter = {
    is?: InvestorVerificationWhereInput | null
    isNot?: InvestorVerificationWhereInput | null
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type SaveListRelationFilter = {
    every?: SaveWhereInput
    some?: SaveWhereInput
    none?: SaveWhereInput
  }

  export type ShareListRelationFilter = {
    every?: ShareWhereInput
    some?: ShareWhereInput
    none?: ShareWhereInput
  }

  export type VideoViewListRelationFilter = {
    every?: VideoViewWhereInput
    some?: VideoViewWhereInput
    none?: VideoViewWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type ExpressInterestListRelationFilter = {
    every?: ExpressInterestWhereInput
    some?: ExpressInterestWhereInput
    none?: ExpressInterestWhereInput
  }

  export type ProfileRevealListRelationFilter = {
    every?: ProfileRevealWhereInput
    some?: ProfileRevealWhereInput
    none?: ProfileRevealWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationPreferenceListRelationFilter = {
    every?: NotificationPreferenceWhereInput
    some?: NotificationPreferenceWhereInput
    none?: NotificationPreferenceWhereInput
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type ContentReportListRelationFilter = {
    every?: ContentReportWhereInput
    some?: ContentReportWhereInput
    none?: ContentReportWhereInput
  }

  export type ModerationActionRecordListRelationFilter = {
    every?: ModerationActionRecordWhereInput
    some?: ModerationActionRecordWhereInput
    none?: ModerationActionRecordWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SearchHistoryListRelationFilter = {
    every?: SearchHistoryWhereInput
    some?: SearchHistoryWhereInput
    none?: SearchHistoryWhereInput
  }

  export type OnboardingProgressNullableRelationFilter = {
    is?: OnboardingProgressWhereInput | null
    isNot?: OnboardingProgressWhereInput | null
  }

  export type AccountTypeChangeListRelationFilter = {
    every?: AccountTypeChangeWhereInput
    some?: AccountTypeChangeWhereInput
    none?: AccountTypeChangeWhereInput
  }

  export type MessageLimitListRelationFilter = {
    every?: MessageLimitWhereInput
    some?: MessageLimitWhereInput
    none?: MessageLimitWhereInput
  }

  export type FeedPreferenceNullableRelationFilter = {
    is?: FeedPreferenceWhereInput | null
    isNot?: FeedPreferenceWhereInput | null
  }

  export type BlockListRelationFilter = {
    every?: BlockWhereInput
    some?: BlockWhereInput
    none?: BlockWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpressInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileRevealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModerationActionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountTypeChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageLimitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    accountType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpires?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    accountType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpires?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    accountType?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpires?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BlockBlockerIdBlockedIdCompoundUniqueInput = {
    blockerId: string
    blockedId: string
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device?: SortOrder
    ip?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device?: SortOrder
    ip?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    device?: SortOrder
    ip?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SocialLinkListRelationFilter = {
    every?: SocialLinkWhereInput
    some?: SocialLinkWhereInput
    none?: SocialLinkWhereInput
  }

  export type SocialLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    isPublic?: SortOrder
    showInSearch?: SortOrder
    showActivityStatus?: SortOrder
    allowMessagesFromEveryone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    isPublic?: SortOrder
    showInSearch?: SortOrder
    showActivityStatus?: SortOrder
    allowMessagesFromEveryone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    isPublic?: SortOrder
    showInSearch?: SortOrder
    showActivityStatus?: SortOrder
    allowMessagesFromEveryone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileRelationFilter = {
    is?: UserProfileWhereInput
    isNot?: UserProfileWhereInput
  }

  export type SocialLinkProfileIdPlatformCompoundUniqueInput = {
    profileId: string
    platform: string
  }

  export type SocialLinkCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
  }

  export type SocialLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
  }

  export type SocialLinkMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    platform?: SortOrder
    url?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FundraisingDetailsNullableRelationFilter = {
    is?: FundraisingDetailsWhereInput | null
    isNot?: FundraisingDetailsWhereInput | null
  }

  export type FounderProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tagline?: SortOrder
    companyName?: SortOrder
    industry?: SortOrder
    lookingForFunding?: SortOrder
    lookingForCofounder?: SortOrder
    lookingForFeedback?: SortOrder
    previousVentures?: SortOrder
    education?: SortOrder
    skills?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tagline?: SortOrder
    companyName?: SortOrder
    industry?: SortOrder
    lookingForFunding?: SortOrder
    lookingForCofounder?: SortOrder
    lookingForFeedback?: SortOrder
    previousVentures?: SortOrder
    education?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FounderProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tagline?: SortOrder
    companyName?: SortOrder
    industry?: SortOrder
    lookingForFunding?: SortOrder
    lookingForCofounder?: SortOrder
    lookingForFeedback?: SortOrder
    previousVentures?: SortOrder
    education?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FounderProfileRelationFilter = {
    is?: FounderProfileWhereInput
    isNot?: FounderProfileWhereInput
  }

  export type FundraisingDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    stage?: SortOrder
    amount?: SortOrder
    industry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FundraisingDetailsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FundraisingDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    stage?: SortOrder
    amount?: SortOrder
    industry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FundraisingDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    founderId?: SortOrder
    stage?: SortOrder
    amount?: SortOrder
    industry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FundraisingDetailsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PortfolioListRelationFilter = {
    every?: PortfolioWhereInput
    some?: PortfolioWhereInput
    none?: PortfolioWhereInput
  }

  export type PortfolioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firm?: SortOrder
    title?: SortOrder
    thesis?: SortOrder
    thesisVideo?: SortOrder
    checkSizeMin?: SortOrder
    checkSizeMax?: SortOrder
    stages?: SortOrder
    industries?: SortOrder
    geographies?: SortOrder
    isPublicMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorProfileAvgOrderByAggregateInput = {
    checkSizeMin?: SortOrder
    checkSizeMax?: SortOrder
  }

  export type InvestorProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firm?: SortOrder
    title?: SortOrder
    thesis?: SortOrder
    thesisVideo?: SortOrder
    checkSizeMin?: SortOrder
    checkSizeMax?: SortOrder
    isPublicMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firm?: SortOrder
    title?: SortOrder
    thesis?: SortOrder
    thesisVideo?: SortOrder
    checkSizeMin?: SortOrder
    checkSizeMax?: SortOrder
    isPublicMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorProfileSumOrderByAggregateInput = {
    checkSizeMin?: SortOrder
    checkSizeMax?: SortOrder
  }

  export type InvestorProfileRelationFilter = {
    is?: InvestorProfileWhereInput
    isNot?: InvestorProfileWhereInput
  }

  export type PortfolioCountOrderByAggregateInput = {
    id?: SortOrder
    investorProfileId?: SortOrder
    companyName?: SortOrder
    companyUrl?: SortOrder
    investmentYear?: SortOrder
  }

  export type PortfolioAvgOrderByAggregateInput = {
    investmentYear?: SortOrder
  }

  export type PortfolioMaxOrderByAggregateInput = {
    id?: SortOrder
    investorProfileId?: SortOrder
    companyName?: SortOrder
    companyUrl?: SortOrder
    investmentYear?: SortOrder
  }

  export type PortfolioMinOrderByAggregateInput = {
    id?: SortOrder
    investorProfileId?: SortOrder
    companyName?: SortOrder
    companyUrl?: SortOrder
    investmentYear?: SortOrder
  }

  export type PortfolioSumOrderByAggregateInput = {
    investmentYear?: SortOrder
  }

  export type BuilderProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    skills?: SortOrder
    portfolioUrls?: SortOrder
    availability?: SortOrder
    lookingForProject?: SortOrder
    industryInterests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuilderProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    availability?: SortOrder
    lookingForProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuilderProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    availability?: SortOrder
    lookingForProject?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type InvestorVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedinUrl?: SortOrder
    proofUrl?: SortOrder
    proofDocument?: SortOrder
    status?: SortOrder
    reviewerNotes?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedinUrl?: SortOrder
    proofUrl?: SortOrder
    proofDocument?: SortOrder
    status?: SortOrder
    reviewerNotes?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    linkedinUrl?: SortOrder
    proofUrl?: SortOrder
    proofDocument?: SortOrder
    status?: SortOrder
    reviewerNotes?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type EnumVideoTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoType | EnumVideoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoTypeFilter<$PrismaModel> | $Enums.VideoType
  }

  export type EnumVideoVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoVisibility | EnumVideoVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoVisibility[] | ListEnumVideoVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoVisibility[] | ListEnumVideoVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoVisibilityFilter<$PrismaModel> | $Enums.VideoVisibility
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type VideoTranscriptNullableRelationFilter = {
    is?: VideoTranscriptWhereInput | null
    isNot?: VideoTranscriptWhereInput | null
  }

  export type VideoAnalyticsNullableRelationFilter = {
    is?: VideoAnalyticsWhereInput | null
    isNot?: VideoAnalyticsWhereInput | null
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    type?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    caption?: SortOrder
    duration?: SortOrder
    tags?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    duration?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    type?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    caption?: SortOrder
    duration?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoUrl?: SortOrder
    thumbnailUrl?: SortOrder
    type?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    caption?: SortOrder
    duration?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    duration?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
  }

  export type EnumVideoTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoType | EnumVideoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoTypeWithAggregatesFilter<$PrismaModel> | $Enums.VideoType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoTypeFilter<$PrismaModel>
    _max?: NestedEnumVideoTypeFilter<$PrismaModel>
  }

  export type EnumVideoVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoVisibility | EnumVideoVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoVisibility[] | ListEnumVideoVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoVisibility[] | ListEnumVideoVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.VideoVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVideoVisibilityFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type VideoRelationFilter = {
    is?: VideoWhereInput
    isNot?: VideoWhereInput
  }

  export type VideoTranscriptCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoTranscriptMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoTranscriptMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type VideoAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    totalViews?: SortOrder
    uniqueViews?: SortOrder
    investorViews?: SortOrder
    founderViews?: SortOrder
    builderViews?: SortOrder
    averageWatchTime?: SortOrder
    completionRate?: SortOrder
    replayRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAnalyticsAvgOrderByAggregateInput = {
    totalViews?: SortOrder
    uniqueViews?: SortOrder
    investorViews?: SortOrder
    founderViews?: SortOrder
    builderViews?: SortOrder
    averageWatchTime?: SortOrder
    completionRate?: SortOrder
    replayRate?: SortOrder
  }

  export type VideoAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    totalViews?: SortOrder
    uniqueViews?: SortOrder
    investorViews?: SortOrder
    founderViews?: SortOrder
    builderViews?: SortOrder
    averageWatchTime?: SortOrder
    completionRate?: SortOrder
    replayRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    totalViews?: SortOrder
    uniqueViews?: SortOrder
    investorViews?: SortOrder
    founderViews?: SortOrder
    builderViews?: SortOrder
    averageWatchTime?: SortOrder
    completionRate?: SortOrder
    replayRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoAnalyticsSumOrderByAggregateInput = {
    totalViews?: SortOrder
    uniqueViews?: SortOrder
    investorViews?: SortOrder
    founderViews?: SortOrder
    builderViews?: SortOrder
    averageWatchTime?: SortOrder
    completionRate?: SortOrder
    replayRate?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type VideoViewVideoIdViewerIdCompoundUniqueInput = {
    videoId: string
    viewerId: string
  }

  export type VideoViewCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    viewerId?: SortOrder
    watchTime?: SortOrder
    completed?: SortOrder
    replays?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoViewAvgOrderByAggregateInput = {
    watchTime?: SortOrder
    replays?: SortOrder
  }

  export type VideoViewMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    viewerId?: SortOrder
    watchTime?: SortOrder
    completed?: SortOrder
    replays?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoViewMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    viewerId?: SortOrder
    watchTime?: SortOrder
    completed?: SortOrder
    replays?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoViewSumOrderByAggregateInput = {
    watchTime?: SortOrder
    replays?: SortOrder
  }

  export type LikeVideoIdUserIdCompoundUniqueInput = {
    videoId: string
    userId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    isHidden?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaveListNullableRelationFilter = {
    is?: SaveListWhereInput | null
    isNot?: SaveListWhereInput | null
  }

  export type SaveVideoIdUserIdCompoundUniqueInput = {
    videoId: string
    userId: string
  }

  export type SaveCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    listId?: SortOrder
    createdAt?: SortOrder
  }

  export type SaveMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    listId?: SortOrder
    createdAt?: SortOrder
  }

  export type SaveMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    listId?: SortOrder
    createdAt?: SortOrder
  }

  export type SaveListUserIdNameCompoundUniqueInput = {
    userId: string
    name: string
  }

  export type SaveListCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type SaveListMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type SaveListMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type ShareCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
  }

  export type ShareMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
  }

  export type ShareMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpressInterestInvestorIdFounderIdVideoIdCompoundUniqueInput = {
    investorId: string
    founderId: string
    videoId: string
  }

  export type ExpressInterestCountOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    videoId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpressInterestMaxOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    videoId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpressInterestMinOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    videoId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileRevealInvestorIdFounderIdCompoundUniqueInput = {
    investorId: string
    founderId: string
  }

  export type ProfileRevealCountOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    revealedAt?: SortOrder
  }

  export type ProfileRevealMaxOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    revealedAt?: SortOrder
  }

  export type ProfileRevealMinOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    founderId?: SortOrder
    revealedAt?: SortOrder
  }

  export type EnumConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusFilter<$PrismaModel> | $Enums.ConversationStatus
  }

  export type ConversationParticipant1IdParticipant2IdCompoundUniqueInput = {
    participant1Id: string
    participant2Id: string
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    participant1Id?: SortOrder
    participant2Id?: SortOrder
    status?: SortOrder
    isRevealed?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    participant1Id?: SortOrder
    participant2Id?: SortOrder
    status?: SortOrder
    isRevealed?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    participant1Id?: SortOrder
    participant2Id?: SortOrder
    status?: SortOrder
    isRevealed?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumConversationStatusFilter<$PrismaModel>
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    attachmentUrl?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    attachmentUrl?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    attachmentUrl?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageLimitUserIdPeriodCompoundUniqueInput = {
    userId: string
    period: string
  }

  export type MessageLimitCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    count?: SortOrder
    resetsAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageLimitAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type MessageLimitMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    count?: SortOrder
    resetsAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageLimitMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    count?: SortOrder
    resetsAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageLimitSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type EnumReportCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportCategory | EnumReportCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ReportCategory[] | ListEnumReportCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportCategory[] | ListEnumReportCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumReportCategoryFilter<$PrismaModel> | $Enums.ReportCategory
  }

  export type ContentReportCountOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    videoId?: SortOrder
    category?: SortOrder
    details?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    videoId?: SortOrder
    category?: SortOrder
    details?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentReportMinOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    videoId?: SortOrder
    category?: SortOrder
    details?: SortOrder
    status?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReportCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportCategory | EnumReportCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ReportCategory[] | ListEnumReportCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportCategory[] | ListEnumReportCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumReportCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ReportCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportCategoryFilter<$PrismaModel>
    _max?: NestedEnumReportCategoryFilter<$PrismaModel>
  }

  export type ContentFlagCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    flagType?: SortOrder
    severity?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentFlagMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    flagType?: SortOrder
    severity?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentFlagMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    flagType?: SortOrder
    severity?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumModerationActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationAction | EnumModerationActionFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumModerationActionFilter<$PrismaModel> | $Enums.ModerationAction
  }

  export type ModerationActionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ModerationActionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ModerationActionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    reason?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumModerationActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationAction | EnumModerationActionFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumModerationActionWithAggregatesFilter<$PrismaModel> | $Enums.ModerationAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationActionFilter<$PrismaModel>
    _max?: NestedEnumModerationActionFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubId?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type FeaturedContentCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    tier?: SortOrder
    createdAt?: SortOrder
  }

  export type FeaturedContentMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    tier?: SortOrder
    createdAt?: SortOrder
  }

  export type FeaturedContentMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    tier?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type NotificationPreferenceUserIdTypeCompoundUniqueInput = {
    userId: string
    type: string
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    pushEnabled?: SortOrder
    emailEnabled?: SortOrder
  }

  export type FeedPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    industries?: SortOrder
    stages?: SortOrder
    notifyOnMatches?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notifyOnMatches?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notifyOnMatches?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    filters?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    query?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    completed?: SortOrder
    data?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingProgressAvgOrderByAggregateInput = {
    step?: SortOrder
  }

  export type OnboardingProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    completed?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingProgressSumOrderByAggregateInput = {
    step?: SortOrder
  }

  export type AccountTypeChangeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fromType?: SortOrder
    toType?: SortOrder
    changedAt?: SortOrder
  }

  export type AccountTypeChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fromType?: SortOrder
    toType?: SortOrder
    changedAt?: SortOrder
  }

  export type AccountTypeChangeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fromType?: SortOrder
    toType?: SortOrder
    changedAt?: SortOrder
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type FounderProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<FounderProfileCreateWithoutUserInput, FounderProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FounderProfileCreateOrConnectWithoutUserInput
    connect?: FounderProfileWhereUniqueInput
  }

  export type InvestorProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorProfileCreateWithoutUserInput, InvestorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorProfileCreateOrConnectWithoutUserInput
    connect?: InvestorProfileWhereUniqueInput
  }

  export type BuilderProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<BuilderProfileCreateWithoutUserInput, BuilderProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BuilderProfileCreateOrConnectWithoutUserInput
    connect?: BuilderProfileWhereUniqueInput
  }

  export type InvestorVerificationCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorVerificationCreateWithoutUserInput, InvestorVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorVerificationCreateOrConnectWithoutUserInput
    connect?: InvestorVerificationWhereUniqueInput
  }

  export type VideoCreateNestedManyWithoutUserInput = {
    create?: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput> | VideoCreateWithoutUserInput[] | VideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUserInput | VideoCreateOrConnectWithoutUserInput[]
    createMany?: VideoCreateManyUserInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type SaveCreateNestedManyWithoutUserInput = {
    create?: XOR<SaveCreateWithoutUserInput, SaveUncheckedCreateWithoutUserInput> | SaveCreateWithoutUserInput[] | SaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutUserInput | SaveCreateOrConnectWithoutUserInput[]
    createMany?: SaveCreateManyUserInputEnvelope
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
  }

  export type ShareCreateNestedManyWithoutUserInput = {
    create?: XOR<ShareCreateWithoutUserInput, ShareUncheckedCreateWithoutUserInput> | ShareCreateWithoutUserInput[] | ShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShareCreateOrConnectWithoutUserInput | ShareCreateOrConnectWithoutUserInput[]
    createMany?: ShareCreateManyUserInputEnvelope
    connect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
  }

  export type VideoViewCreateNestedManyWithoutViewerInput = {
    create?: XOR<VideoViewCreateWithoutViewerInput, VideoViewUncheckedCreateWithoutViewerInput> | VideoViewCreateWithoutViewerInput[] | VideoViewUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: VideoViewCreateOrConnectWithoutViewerInput | VideoViewCreateOrConnectWithoutViewerInput[]
    createMany?: VideoViewCreateManyViewerInputEnvelope
    connect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutParticipant1Input = {
    create?: XOR<ConversationCreateWithoutParticipant1Input, ConversationUncheckedCreateWithoutParticipant1Input> | ConversationCreateWithoutParticipant1Input[] | ConversationUncheckedCreateWithoutParticipant1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipant1Input | ConversationCreateOrConnectWithoutParticipant1Input[]
    createMany?: ConversationCreateManyParticipant1InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutParticipant2Input = {
    create?: XOR<ConversationCreateWithoutParticipant2Input, ConversationUncheckedCreateWithoutParticipant2Input> | ConversationCreateWithoutParticipant2Input[] | ConversationUncheckedCreateWithoutParticipant2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipant2Input | ConversationCreateOrConnectWithoutParticipant2Input[]
    createMany?: ConversationCreateManyParticipant2InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ExpressInterestCreateNestedManyWithoutInvestorInput = {
    create?: XOR<ExpressInterestCreateWithoutInvestorInput, ExpressInterestUncheckedCreateWithoutInvestorInput> | ExpressInterestCreateWithoutInvestorInput[] | ExpressInterestUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutInvestorInput | ExpressInterestCreateOrConnectWithoutInvestorInput[]
    createMany?: ExpressInterestCreateManyInvestorInputEnvelope
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
  }

  export type ExpressInterestCreateNestedManyWithoutFounderInput = {
    create?: XOR<ExpressInterestCreateWithoutFounderInput, ExpressInterestUncheckedCreateWithoutFounderInput> | ExpressInterestCreateWithoutFounderInput[] | ExpressInterestUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutFounderInput | ExpressInterestCreateOrConnectWithoutFounderInput[]
    createMany?: ExpressInterestCreateManyFounderInputEnvelope
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
  }

  export type ProfileRevealCreateNestedManyWithoutInvestorInput = {
    create?: XOR<ProfileRevealCreateWithoutInvestorInput, ProfileRevealUncheckedCreateWithoutInvestorInput> | ProfileRevealCreateWithoutInvestorInput[] | ProfileRevealUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: ProfileRevealCreateOrConnectWithoutInvestorInput | ProfileRevealCreateOrConnectWithoutInvestorInput[]
    createMany?: ProfileRevealCreateManyInvestorInputEnvelope
    connect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
  }

  export type ProfileRevealCreateNestedManyWithoutFounderInput = {
    create?: XOR<ProfileRevealCreateWithoutFounderInput, ProfileRevealUncheckedCreateWithoutFounderInput> | ProfileRevealCreateWithoutFounderInput[] | ProfileRevealUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: ProfileRevealCreateOrConnectWithoutFounderInput | ProfileRevealCreateOrConnectWithoutFounderInput[]
    createMany?: ProfileRevealCreateManyFounderInputEnvelope
    connect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ContentReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<ContentReportCreateWithoutReporterInput, ContentReportUncheckedCreateWithoutReporterInput> | ContentReportCreateWithoutReporterInput[] | ContentReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ContentReportCreateOrConnectWithoutReporterInput | ContentReportCreateOrConnectWithoutReporterInput[]
    createMany?: ContentReportCreateManyReporterInputEnvelope
    connect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
  }

  export type ModerationActionRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<ModerationActionRecordCreateWithoutUserInput, ModerationActionRecordUncheckedCreateWithoutUserInput> | ModerationActionRecordCreateWithoutUserInput[] | ModerationActionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModerationActionRecordCreateOrConnectWithoutUserInput | ModerationActionRecordCreateOrConnectWithoutUserInput[]
    createMany?: ModerationActionRecordCreateManyUserInputEnvelope
    connect?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SearchHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type OnboardingProgressCreateNestedOneWithoutUserInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    connect?: OnboardingProgressWhereUniqueInput
  }

  export type AccountTypeChangeCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountTypeChangeCreateWithoutUserInput, AccountTypeChangeUncheckedCreateWithoutUserInput> | AccountTypeChangeCreateWithoutUserInput[] | AccountTypeChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountTypeChangeCreateOrConnectWithoutUserInput | AccountTypeChangeCreateOrConnectWithoutUserInput[]
    createMany?: AccountTypeChangeCreateManyUserInputEnvelope
    connect?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
  }

  export type MessageLimitCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageLimitCreateWithoutUserInput, MessageLimitUncheckedCreateWithoutUserInput> | MessageLimitCreateWithoutUserInput[] | MessageLimitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageLimitCreateOrConnectWithoutUserInput | MessageLimitCreateOrConnectWithoutUserInput[]
    createMany?: MessageLimitCreateManyUserInputEnvelope
    connect?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
  }

  export type FeedPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<FeedPreferenceCreateWithoutUserInput, FeedPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: FeedPreferenceCreateOrConnectWithoutUserInput
    connect?: FeedPreferenceWhereUniqueInput
  }

  export type BlockCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type FounderProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FounderProfileCreateWithoutUserInput, FounderProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FounderProfileCreateOrConnectWithoutUserInput
    connect?: FounderProfileWhereUniqueInput
  }

  export type InvestorProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorProfileCreateWithoutUserInput, InvestorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorProfileCreateOrConnectWithoutUserInput
    connect?: InvestorProfileWhereUniqueInput
  }

  export type BuilderProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<BuilderProfileCreateWithoutUserInput, BuilderProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BuilderProfileCreateOrConnectWithoutUserInput
    connect?: BuilderProfileWhereUniqueInput
  }

  export type InvestorVerificationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InvestorVerificationCreateWithoutUserInput, InvestorVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorVerificationCreateOrConnectWithoutUserInput
    connect?: InvestorVerificationWhereUniqueInput
  }

  export type VideoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput> | VideoCreateWithoutUserInput[] | VideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUserInput | VideoCreateOrConnectWithoutUserInput[]
    createMany?: VideoCreateManyUserInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type SaveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SaveCreateWithoutUserInput, SaveUncheckedCreateWithoutUserInput> | SaveCreateWithoutUserInput[] | SaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutUserInput | SaveCreateOrConnectWithoutUserInput[]
    createMany?: SaveCreateManyUserInputEnvelope
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
  }

  export type ShareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShareCreateWithoutUserInput, ShareUncheckedCreateWithoutUserInput> | ShareCreateWithoutUserInput[] | ShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShareCreateOrConnectWithoutUserInput | ShareCreateOrConnectWithoutUserInput[]
    createMany?: ShareCreateManyUserInputEnvelope
    connect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
  }

  export type VideoViewUncheckedCreateNestedManyWithoutViewerInput = {
    create?: XOR<VideoViewCreateWithoutViewerInput, VideoViewUncheckedCreateWithoutViewerInput> | VideoViewCreateWithoutViewerInput[] | VideoViewUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: VideoViewCreateOrConnectWithoutViewerInput | VideoViewCreateOrConnectWithoutViewerInput[]
    createMany?: VideoViewCreateManyViewerInputEnvelope
    connect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutParticipant1Input = {
    create?: XOR<ConversationCreateWithoutParticipant1Input, ConversationUncheckedCreateWithoutParticipant1Input> | ConversationCreateWithoutParticipant1Input[] | ConversationUncheckedCreateWithoutParticipant1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipant1Input | ConversationCreateOrConnectWithoutParticipant1Input[]
    createMany?: ConversationCreateManyParticipant1InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutParticipant2Input = {
    create?: XOR<ConversationCreateWithoutParticipant2Input, ConversationUncheckedCreateWithoutParticipant2Input> | ConversationCreateWithoutParticipant2Input[] | ConversationUncheckedCreateWithoutParticipant2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipant2Input | ConversationCreateOrConnectWithoutParticipant2Input[]
    createMany?: ConversationCreateManyParticipant2InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<ExpressInterestCreateWithoutInvestorInput, ExpressInterestUncheckedCreateWithoutInvestorInput> | ExpressInterestCreateWithoutInvestorInput[] | ExpressInterestUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutInvestorInput | ExpressInterestCreateOrConnectWithoutInvestorInput[]
    createMany?: ExpressInterestCreateManyInvestorInputEnvelope
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
  }

  export type ExpressInterestUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<ExpressInterestCreateWithoutFounderInput, ExpressInterestUncheckedCreateWithoutFounderInput> | ExpressInterestCreateWithoutFounderInput[] | ExpressInterestUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutFounderInput | ExpressInterestCreateOrConnectWithoutFounderInput[]
    createMany?: ExpressInterestCreateManyFounderInputEnvelope
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
  }

  export type ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<ProfileRevealCreateWithoutInvestorInput, ProfileRevealUncheckedCreateWithoutInvestorInput> | ProfileRevealCreateWithoutInvestorInput[] | ProfileRevealUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: ProfileRevealCreateOrConnectWithoutInvestorInput | ProfileRevealCreateOrConnectWithoutInvestorInput[]
    createMany?: ProfileRevealCreateManyInvestorInputEnvelope
    connect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
  }

  export type ProfileRevealUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<ProfileRevealCreateWithoutFounderInput, ProfileRevealUncheckedCreateWithoutFounderInput> | ProfileRevealCreateWithoutFounderInput[] | ProfileRevealUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: ProfileRevealCreateOrConnectWithoutFounderInput | ProfileRevealCreateOrConnectWithoutFounderInput[]
    createMany?: ProfileRevealCreateManyFounderInputEnvelope
    connect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ContentReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<ContentReportCreateWithoutReporterInput, ContentReportUncheckedCreateWithoutReporterInput> | ContentReportCreateWithoutReporterInput[] | ContentReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ContentReportCreateOrConnectWithoutReporterInput | ContentReportCreateOrConnectWithoutReporterInput[]
    createMany?: ContentReportCreateManyReporterInputEnvelope
    connect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
  }

  export type ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ModerationActionRecordCreateWithoutUserInput, ModerationActionRecordUncheckedCreateWithoutUserInput> | ModerationActionRecordCreateWithoutUserInput[] | ModerationActionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModerationActionRecordCreateOrConnectWithoutUserInput | ModerationActionRecordCreateOrConnectWithoutUserInput[]
    createMany?: ModerationActionRecordCreateManyUserInputEnvelope
    connect?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SearchHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type OnboardingProgressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    connect?: OnboardingProgressWhereUniqueInput
  }

  export type AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountTypeChangeCreateWithoutUserInput, AccountTypeChangeUncheckedCreateWithoutUserInput> | AccountTypeChangeCreateWithoutUserInput[] | AccountTypeChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountTypeChangeCreateOrConnectWithoutUserInput | AccountTypeChangeCreateOrConnectWithoutUserInput[]
    createMany?: AccountTypeChangeCreateManyUserInputEnvelope
    connect?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
  }

  export type MessageLimitUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageLimitCreateWithoutUserInput, MessageLimitUncheckedCreateWithoutUserInput> | MessageLimitCreateWithoutUserInput[] | MessageLimitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageLimitCreateOrConnectWithoutUserInput | MessageLimitCreateOrConnectWithoutUserInput[]
    createMany?: MessageLimitCreateManyUserInputEnvelope
    connect?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
  }

  export type FeedPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FeedPreferenceCreateWithoutUserInput, FeedPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: FeedPreferenceCreateOrConnectWithoutUserInput
    connect?: FeedPreferenceWhereUniqueInput
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type FounderProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<FounderProfileCreateWithoutUserInput, FounderProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FounderProfileCreateOrConnectWithoutUserInput
    upsert?: FounderProfileUpsertWithoutUserInput
    disconnect?: FounderProfileWhereInput | boolean
    delete?: FounderProfileWhereInput | boolean
    connect?: FounderProfileWhereUniqueInput
    update?: XOR<XOR<FounderProfileUpdateToOneWithWhereWithoutUserInput, FounderProfileUpdateWithoutUserInput>, FounderProfileUncheckedUpdateWithoutUserInput>
  }

  export type InvestorProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorProfileCreateWithoutUserInput, InvestorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorProfileCreateOrConnectWithoutUserInput
    upsert?: InvestorProfileUpsertWithoutUserInput
    disconnect?: InvestorProfileWhereInput | boolean
    delete?: InvestorProfileWhereInput | boolean
    connect?: InvestorProfileWhereUniqueInput
    update?: XOR<XOR<InvestorProfileUpdateToOneWithWhereWithoutUserInput, InvestorProfileUpdateWithoutUserInput>, InvestorProfileUncheckedUpdateWithoutUserInput>
  }

  export type BuilderProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<BuilderProfileCreateWithoutUserInput, BuilderProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BuilderProfileCreateOrConnectWithoutUserInput
    upsert?: BuilderProfileUpsertWithoutUserInput
    disconnect?: BuilderProfileWhereInput | boolean
    delete?: BuilderProfileWhereInput | boolean
    connect?: BuilderProfileWhereUniqueInput
    update?: XOR<XOR<BuilderProfileUpdateToOneWithWhereWithoutUserInput, BuilderProfileUpdateWithoutUserInput>, BuilderProfileUncheckedUpdateWithoutUserInput>
  }

  export type InvestorVerificationUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorVerificationCreateWithoutUserInput, InvestorVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorVerificationCreateOrConnectWithoutUserInput
    upsert?: InvestorVerificationUpsertWithoutUserInput
    disconnect?: InvestorVerificationWhereInput | boolean
    delete?: InvestorVerificationWhereInput | boolean
    connect?: InvestorVerificationWhereUniqueInput
    update?: XOR<XOR<InvestorVerificationUpdateToOneWithWhereWithoutUserInput, InvestorVerificationUpdateWithoutUserInput>, InvestorVerificationUncheckedUpdateWithoutUserInput>
  }

  export type VideoUpdateManyWithoutUserNestedInput = {
    create?: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput> | VideoCreateWithoutUserInput[] | VideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUserInput | VideoCreateOrConnectWithoutUserInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutUserInput | VideoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VideoCreateManyUserInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutUserInput | VideoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutUserInput | VideoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type SaveUpdateManyWithoutUserNestedInput = {
    create?: XOR<SaveCreateWithoutUserInput, SaveUncheckedCreateWithoutUserInput> | SaveCreateWithoutUserInput[] | SaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutUserInput | SaveCreateOrConnectWithoutUserInput[]
    upsert?: SaveUpsertWithWhereUniqueWithoutUserInput | SaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SaveCreateManyUserInputEnvelope
    set?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    disconnect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    delete?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    update?: SaveUpdateWithWhereUniqueWithoutUserInput | SaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SaveUpdateManyWithWhereWithoutUserInput | SaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SaveScalarWhereInput | SaveScalarWhereInput[]
  }

  export type ShareUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShareCreateWithoutUserInput, ShareUncheckedCreateWithoutUserInput> | ShareCreateWithoutUserInput[] | ShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShareCreateOrConnectWithoutUserInput | ShareCreateOrConnectWithoutUserInput[]
    upsert?: ShareUpsertWithWhereUniqueWithoutUserInput | ShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShareCreateManyUserInputEnvelope
    set?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    disconnect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    delete?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    connect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    update?: ShareUpdateWithWhereUniqueWithoutUserInput | ShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShareUpdateManyWithWhereWithoutUserInput | ShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShareScalarWhereInput | ShareScalarWhereInput[]
  }

  export type VideoViewUpdateManyWithoutViewerNestedInput = {
    create?: XOR<VideoViewCreateWithoutViewerInput, VideoViewUncheckedCreateWithoutViewerInput> | VideoViewCreateWithoutViewerInput[] | VideoViewUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: VideoViewCreateOrConnectWithoutViewerInput | VideoViewCreateOrConnectWithoutViewerInput[]
    upsert?: VideoViewUpsertWithWhereUniqueWithoutViewerInput | VideoViewUpsertWithWhereUniqueWithoutViewerInput[]
    createMany?: VideoViewCreateManyViewerInputEnvelope
    set?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    disconnect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    delete?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    connect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    update?: VideoViewUpdateWithWhereUniqueWithoutViewerInput | VideoViewUpdateWithWhereUniqueWithoutViewerInput[]
    updateMany?: VideoViewUpdateManyWithWhereWithoutViewerInput | VideoViewUpdateManyWithWhereWithoutViewerInput[]
    deleteMany?: VideoViewScalarWhereInput | VideoViewScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutParticipant1NestedInput = {
    create?: XOR<ConversationCreateWithoutParticipant1Input, ConversationUncheckedCreateWithoutParticipant1Input> | ConversationCreateWithoutParticipant1Input[] | ConversationUncheckedCreateWithoutParticipant1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipant1Input | ConversationCreateOrConnectWithoutParticipant1Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutParticipant1Input | ConversationUpsertWithWhereUniqueWithoutParticipant1Input[]
    createMany?: ConversationCreateManyParticipant1InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutParticipant1Input | ConversationUpdateWithWhereUniqueWithoutParticipant1Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutParticipant1Input | ConversationUpdateManyWithWhereWithoutParticipant1Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutParticipant2NestedInput = {
    create?: XOR<ConversationCreateWithoutParticipant2Input, ConversationUncheckedCreateWithoutParticipant2Input> | ConversationCreateWithoutParticipant2Input[] | ConversationUncheckedCreateWithoutParticipant2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipant2Input | ConversationCreateOrConnectWithoutParticipant2Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutParticipant2Input | ConversationUpsertWithWhereUniqueWithoutParticipant2Input[]
    createMany?: ConversationCreateManyParticipant2InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutParticipant2Input | ConversationUpdateWithWhereUniqueWithoutParticipant2Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutParticipant2Input | ConversationUpdateManyWithWhereWithoutParticipant2Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ExpressInterestUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<ExpressInterestCreateWithoutInvestorInput, ExpressInterestUncheckedCreateWithoutInvestorInput> | ExpressInterestCreateWithoutInvestorInput[] | ExpressInterestUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutInvestorInput | ExpressInterestCreateOrConnectWithoutInvestorInput[]
    upsert?: ExpressInterestUpsertWithWhereUniqueWithoutInvestorInput | ExpressInterestUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: ExpressInterestCreateManyInvestorInputEnvelope
    set?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    disconnect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    delete?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    update?: ExpressInterestUpdateWithWhereUniqueWithoutInvestorInput | ExpressInterestUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: ExpressInterestUpdateManyWithWhereWithoutInvestorInput | ExpressInterestUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: ExpressInterestScalarWhereInput | ExpressInterestScalarWhereInput[]
  }

  export type ExpressInterestUpdateManyWithoutFounderNestedInput = {
    create?: XOR<ExpressInterestCreateWithoutFounderInput, ExpressInterestUncheckedCreateWithoutFounderInput> | ExpressInterestCreateWithoutFounderInput[] | ExpressInterestUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutFounderInput | ExpressInterestCreateOrConnectWithoutFounderInput[]
    upsert?: ExpressInterestUpsertWithWhereUniqueWithoutFounderInput | ExpressInterestUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: ExpressInterestCreateManyFounderInputEnvelope
    set?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    disconnect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    delete?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    update?: ExpressInterestUpdateWithWhereUniqueWithoutFounderInput | ExpressInterestUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: ExpressInterestUpdateManyWithWhereWithoutFounderInput | ExpressInterestUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: ExpressInterestScalarWhereInput | ExpressInterestScalarWhereInput[]
  }

  export type ProfileRevealUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<ProfileRevealCreateWithoutInvestorInput, ProfileRevealUncheckedCreateWithoutInvestorInput> | ProfileRevealCreateWithoutInvestorInput[] | ProfileRevealUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: ProfileRevealCreateOrConnectWithoutInvestorInput | ProfileRevealCreateOrConnectWithoutInvestorInput[]
    upsert?: ProfileRevealUpsertWithWhereUniqueWithoutInvestorInput | ProfileRevealUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: ProfileRevealCreateManyInvestorInputEnvelope
    set?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    disconnect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    delete?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    connect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    update?: ProfileRevealUpdateWithWhereUniqueWithoutInvestorInput | ProfileRevealUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: ProfileRevealUpdateManyWithWhereWithoutInvestorInput | ProfileRevealUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: ProfileRevealScalarWhereInput | ProfileRevealScalarWhereInput[]
  }

  export type ProfileRevealUpdateManyWithoutFounderNestedInput = {
    create?: XOR<ProfileRevealCreateWithoutFounderInput, ProfileRevealUncheckedCreateWithoutFounderInput> | ProfileRevealCreateWithoutFounderInput[] | ProfileRevealUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: ProfileRevealCreateOrConnectWithoutFounderInput | ProfileRevealCreateOrConnectWithoutFounderInput[]
    upsert?: ProfileRevealUpsertWithWhereUniqueWithoutFounderInput | ProfileRevealUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: ProfileRevealCreateManyFounderInputEnvelope
    set?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    disconnect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    delete?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    connect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    update?: ProfileRevealUpdateWithWhereUniqueWithoutFounderInput | ProfileRevealUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: ProfileRevealUpdateManyWithWhereWithoutFounderInput | ProfileRevealUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: ProfileRevealScalarWhereInput | ProfileRevealScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type ContentReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ContentReportCreateWithoutReporterInput, ContentReportUncheckedCreateWithoutReporterInput> | ContentReportCreateWithoutReporterInput[] | ContentReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ContentReportCreateOrConnectWithoutReporterInput | ContentReportCreateOrConnectWithoutReporterInput[]
    upsert?: ContentReportUpsertWithWhereUniqueWithoutReporterInput | ContentReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ContentReportCreateManyReporterInputEnvelope
    set?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    disconnect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    delete?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    connect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    update?: ContentReportUpdateWithWhereUniqueWithoutReporterInput | ContentReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ContentReportUpdateManyWithWhereWithoutReporterInput | ContentReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ContentReportScalarWhereInput | ContentReportScalarWhereInput[]
  }

  export type ModerationActionRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModerationActionRecordCreateWithoutUserInput, ModerationActionRecordUncheckedCreateWithoutUserInput> | ModerationActionRecordCreateWithoutUserInput[] | ModerationActionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModerationActionRecordCreateOrConnectWithoutUserInput | ModerationActionRecordCreateOrConnectWithoutUserInput[]
    upsert?: ModerationActionRecordUpsertWithWhereUniqueWithoutUserInput | ModerationActionRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModerationActionRecordCreateManyUserInputEnvelope
    set?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
    disconnect?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
    delete?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
    connect?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
    update?: ModerationActionRecordUpdateWithWhereUniqueWithoutUserInput | ModerationActionRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModerationActionRecordUpdateManyWithWhereWithoutUserInput | ModerationActionRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModerationActionRecordScalarWhereInput | ModerationActionRecordScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SearchHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type OnboardingProgressUpdateOneWithoutUserNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    upsert?: OnboardingProgressUpsertWithoutUserInput
    disconnect?: OnboardingProgressWhereInput | boolean
    delete?: OnboardingProgressWhereInput | boolean
    connect?: OnboardingProgressWhereUniqueInput
    update?: XOR<XOR<OnboardingProgressUpdateToOneWithWhereWithoutUserInput, OnboardingProgressUpdateWithoutUserInput>, OnboardingProgressUncheckedUpdateWithoutUserInput>
  }

  export type AccountTypeChangeUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountTypeChangeCreateWithoutUserInput, AccountTypeChangeUncheckedCreateWithoutUserInput> | AccountTypeChangeCreateWithoutUserInput[] | AccountTypeChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountTypeChangeCreateOrConnectWithoutUserInput | AccountTypeChangeCreateOrConnectWithoutUserInput[]
    upsert?: AccountTypeChangeUpsertWithWhereUniqueWithoutUserInput | AccountTypeChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountTypeChangeCreateManyUserInputEnvelope
    set?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
    disconnect?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
    delete?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
    connect?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
    update?: AccountTypeChangeUpdateWithWhereUniqueWithoutUserInput | AccountTypeChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountTypeChangeUpdateManyWithWhereWithoutUserInput | AccountTypeChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountTypeChangeScalarWhereInput | AccountTypeChangeScalarWhereInput[]
  }

  export type MessageLimitUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageLimitCreateWithoutUserInput, MessageLimitUncheckedCreateWithoutUserInput> | MessageLimitCreateWithoutUserInput[] | MessageLimitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageLimitCreateOrConnectWithoutUserInput | MessageLimitCreateOrConnectWithoutUserInput[]
    upsert?: MessageLimitUpsertWithWhereUniqueWithoutUserInput | MessageLimitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageLimitCreateManyUserInputEnvelope
    set?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
    disconnect?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
    delete?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
    connect?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
    update?: MessageLimitUpdateWithWhereUniqueWithoutUserInput | MessageLimitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageLimitUpdateManyWithWhereWithoutUserInput | MessageLimitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageLimitScalarWhereInput | MessageLimitScalarWhereInput[]
  }

  export type FeedPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<FeedPreferenceCreateWithoutUserInput, FeedPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: FeedPreferenceCreateOrConnectWithoutUserInput
    upsert?: FeedPreferenceUpsertWithoutUserInput
    disconnect?: FeedPreferenceWhereInput | boolean
    delete?: FeedPreferenceWhereInput | boolean
    connect?: FeedPreferenceWhereUniqueInput
    update?: XOR<XOR<FeedPreferenceUpdateToOneWithWhereWithoutUserInput, FeedPreferenceUpdateWithoutUserInput>, FeedPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type BlockUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedInput | BlockUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedInput | BlockUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedInput | BlockUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type FounderProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FounderProfileCreateWithoutUserInput, FounderProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: FounderProfileCreateOrConnectWithoutUserInput
    upsert?: FounderProfileUpsertWithoutUserInput
    disconnect?: FounderProfileWhereInput | boolean
    delete?: FounderProfileWhereInput | boolean
    connect?: FounderProfileWhereUniqueInput
    update?: XOR<XOR<FounderProfileUpdateToOneWithWhereWithoutUserInput, FounderProfileUpdateWithoutUserInput>, FounderProfileUncheckedUpdateWithoutUserInput>
  }

  export type InvestorProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorProfileCreateWithoutUserInput, InvestorProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorProfileCreateOrConnectWithoutUserInput
    upsert?: InvestorProfileUpsertWithoutUserInput
    disconnect?: InvestorProfileWhereInput | boolean
    delete?: InvestorProfileWhereInput | boolean
    connect?: InvestorProfileWhereUniqueInput
    update?: XOR<XOR<InvestorProfileUpdateToOneWithWhereWithoutUserInput, InvestorProfileUpdateWithoutUserInput>, InvestorProfileUncheckedUpdateWithoutUserInput>
  }

  export type BuilderProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<BuilderProfileCreateWithoutUserInput, BuilderProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BuilderProfileCreateOrConnectWithoutUserInput
    upsert?: BuilderProfileUpsertWithoutUserInput
    disconnect?: BuilderProfileWhereInput | boolean
    delete?: BuilderProfileWhereInput | boolean
    connect?: BuilderProfileWhereUniqueInput
    update?: XOR<XOR<BuilderProfileUpdateToOneWithWhereWithoutUserInput, BuilderProfileUpdateWithoutUserInput>, BuilderProfileUncheckedUpdateWithoutUserInput>
  }

  export type InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InvestorVerificationCreateWithoutUserInput, InvestorVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: InvestorVerificationCreateOrConnectWithoutUserInput
    upsert?: InvestorVerificationUpsertWithoutUserInput
    disconnect?: InvestorVerificationWhereInput | boolean
    delete?: InvestorVerificationWhereInput | boolean
    connect?: InvestorVerificationWhereUniqueInput
    update?: XOR<XOR<InvestorVerificationUpdateToOneWithWhereWithoutUserInput, InvestorVerificationUpdateWithoutUserInput>, InvestorVerificationUncheckedUpdateWithoutUserInput>
  }

  export type VideoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput> | VideoCreateWithoutUserInput[] | VideoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutUserInput | VideoCreateOrConnectWithoutUserInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutUserInput | VideoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VideoCreateManyUserInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutUserInput | VideoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutUserInput | VideoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type SaveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SaveCreateWithoutUserInput, SaveUncheckedCreateWithoutUserInput> | SaveCreateWithoutUserInput[] | SaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutUserInput | SaveCreateOrConnectWithoutUserInput[]
    upsert?: SaveUpsertWithWhereUniqueWithoutUserInput | SaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SaveCreateManyUserInputEnvelope
    set?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    disconnect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    delete?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    update?: SaveUpdateWithWhereUniqueWithoutUserInput | SaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SaveUpdateManyWithWhereWithoutUserInput | SaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SaveScalarWhereInput | SaveScalarWhereInput[]
  }

  export type ShareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShareCreateWithoutUserInput, ShareUncheckedCreateWithoutUserInput> | ShareCreateWithoutUserInput[] | ShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShareCreateOrConnectWithoutUserInput | ShareCreateOrConnectWithoutUserInput[]
    upsert?: ShareUpsertWithWhereUniqueWithoutUserInput | ShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShareCreateManyUserInputEnvelope
    set?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    disconnect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    delete?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    connect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    update?: ShareUpdateWithWhereUniqueWithoutUserInput | ShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShareUpdateManyWithWhereWithoutUserInput | ShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShareScalarWhereInput | ShareScalarWhereInput[]
  }

  export type VideoViewUncheckedUpdateManyWithoutViewerNestedInput = {
    create?: XOR<VideoViewCreateWithoutViewerInput, VideoViewUncheckedCreateWithoutViewerInput> | VideoViewCreateWithoutViewerInput[] | VideoViewUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: VideoViewCreateOrConnectWithoutViewerInput | VideoViewCreateOrConnectWithoutViewerInput[]
    upsert?: VideoViewUpsertWithWhereUniqueWithoutViewerInput | VideoViewUpsertWithWhereUniqueWithoutViewerInput[]
    createMany?: VideoViewCreateManyViewerInputEnvelope
    set?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    disconnect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    delete?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    connect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    update?: VideoViewUpdateWithWhereUniqueWithoutViewerInput | VideoViewUpdateWithWhereUniqueWithoutViewerInput[]
    updateMany?: VideoViewUpdateManyWithWhereWithoutViewerInput | VideoViewUpdateManyWithWhereWithoutViewerInput[]
    deleteMany?: VideoViewScalarWhereInput | VideoViewScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutParticipant1NestedInput = {
    create?: XOR<ConversationCreateWithoutParticipant1Input, ConversationUncheckedCreateWithoutParticipant1Input> | ConversationCreateWithoutParticipant1Input[] | ConversationUncheckedCreateWithoutParticipant1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipant1Input | ConversationCreateOrConnectWithoutParticipant1Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutParticipant1Input | ConversationUpsertWithWhereUniqueWithoutParticipant1Input[]
    createMany?: ConversationCreateManyParticipant1InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutParticipant1Input | ConversationUpdateWithWhereUniqueWithoutParticipant1Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutParticipant1Input | ConversationUpdateManyWithWhereWithoutParticipant1Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutParticipant2NestedInput = {
    create?: XOR<ConversationCreateWithoutParticipant2Input, ConversationUncheckedCreateWithoutParticipant2Input> | ConversationCreateWithoutParticipant2Input[] | ConversationUncheckedCreateWithoutParticipant2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipant2Input | ConversationCreateOrConnectWithoutParticipant2Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutParticipant2Input | ConversationUpsertWithWhereUniqueWithoutParticipant2Input[]
    createMany?: ConversationCreateManyParticipant2InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutParticipant2Input | ConversationUpdateWithWhereUniqueWithoutParticipant2Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutParticipant2Input | ConversationUpdateManyWithWhereWithoutParticipant2Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<ExpressInterestCreateWithoutInvestorInput, ExpressInterestUncheckedCreateWithoutInvestorInput> | ExpressInterestCreateWithoutInvestorInput[] | ExpressInterestUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutInvestorInput | ExpressInterestCreateOrConnectWithoutInvestorInput[]
    upsert?: ExpressInterestUpsertWithWhereUniqueWithoutInvestorInput | ExpressInterestUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: ExpressInterestCreateManyInvestorInputEnvelope
    set?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    disconnect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    delete?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    update?: ExpressInterestUpdateWithWhereUniqueWithoutInvestorInput | ExpressInterestUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: ExpressInterestUpdateManyWithWhereWithoutInvestorInput | ExpressInterestUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: ExpressInterestScalarWhereInput | ExpressInterestScalarWhereInput[]
  }

  export type ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<ExpressInterestCreateWithoutFounderInput, ExpressInterestUncheckedCreateWithoutFounderInput> | ExpressInterestCreateWithoutFounderInput[] | ExpressInterestUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutFounderInput | ExpressInterestCreateOrConnectWithoutFounderInput[]
    upsert?: ExpressInterestUpsertWithWhereUniqueWithoutFounderInput | ExpressInterestUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: ExpressInterestCreateManyFounderInputEnvelope
    set?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    disconnect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    delete?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    update?: ExpressInterestUpdateWithWhereUniqueWithoutFounderInput | ExpressInterestUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: ExpressInterestUpdateManyWithWhereWithoutFounderInput | ExpressInterestUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: ExpressInterestScalarWhereInput | ExpressInterestScalarWhereInput[]
  }

  export type ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<ProfileRevealCreateWithoutInvestorInput, ProfileRevealUncheckedCreateWithoutInvestorInput> | ProfileRevealCreateWithoutInvestorInput[] | ProfileRevealUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: ProfileRevealCreateOrConnectWithoutInvestorInput | ProfileRevealCreateOrConnectWithoutInvestorInput[]
    upsert?: ProfileRevealUpsertWithWhereUniqueWithoutInvestorInput | ProfileRevealUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: ProfileRevealCreateManyInvestorInputEnvelope
    set?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    disconnect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    delete?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    connect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    update?: ProfileRevealUpdateWithWhereUniqueWithoutInvestorInput | ProfileRevealUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: ProfileRevealUpdateManyWithWhereWithoutInvestorInput | ProfileRevealUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: ProfileRevealScalarWhereInput | ProfileRevealScalarWhereInput[]
  }

  export type ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<ProfileRevealCreateWithoutFounderInput, ProfileRevealUncheckedCreateWithoutFounderInput> | ProfileRevealCreateWithoutFounderInput[] | ProfileRevealUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: ProfileRevealCreateOrConnectWithoutFounderInput | ProfileRevealCreateOrConnectWithoutFounderInput[]
    upsert?: ProfileRevealUpsertWithWhereUniqueWithoutFounderInput | ProfileRevealUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: ProfileRevealCreateManyFounderInputEnvelope
    set?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    disconnect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    delete?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    connect?: ProfileRevealWhereUniqueInput | ProfileRevealWhereUniqueInput[]
    update?: ProfileRevealUpdateWithWhereUniqueWithoutFounderInput | ProfileRevealUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: ProfileRevealUpdateManyWithWhereWithoutFounderInput | ProfileRevealUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: ProfileRevealScalarWhereInput | ProfileRevealScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type ContentReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ContentReportCreateWithoutReporterInput, ContentReportUncheckedCreateWithoutReporterInput> | ContentReportCreateWithoutReporterInput[] | ContentReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ContentReportCreateOrConnectWithoutReporterInput | ContentReportCreateOrConnectWithoutReporterInput[]
    upsert?: ContentReportUpsertWithWhereUniqueWithoutReporterInput | ContentReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ContentReportCreateManyReporterInputEnvelope
    set?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    disconnect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    delete?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    connect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    update?: ContentReportUpdateWithWhereUniqueWithoutReporterInput | ContentReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ContentReportUpdateManyWithWhereWithoutReporterInput | ContentReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ContentReportScalarWhereInput | ContentReportScalarWhereInput[]
  }

  export type ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModerationActionRecordCreateWithoutUserInput, ModerationActionRecordUncheckedCreateWithoutUserInput> | ModerationActionRecordCreateWithoutUserInput[] | ModerationActionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModerationActionRecordCreateOrConnectWithoutUserInput | ModerationActionRecordCreateOrConnectWithoutUserInput[]
    upsert?: ModerationActionRecordUpsertWithWhereUniqueWithoutUserInput | ModerationActionRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModerationActionRecordCreateManyUserInputEnvelope
    set?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
    disconnect?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
    delete?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
    connect?: ModerationActionRecordWhereUniqueInput | ModerationActionRecordWhereUniqueInput[]
    update?: ModerationActionRecordUpdateWithWhereUniqueWithoutUserInput | ModerationActionRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModerationActionRecordUpdateManyWithWhereWithoutUserInput | ModerationActionRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModerationActionRecordScalarWhereInput | ModerationActionRecordScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingProgressCreateOrConnectWithoutUserInput
    upsert?: OnboardingProgressUpsertWithoutUserInput
    disconnect?: OnboardingProgressWhereInput | boolean
    delete?: OnboardingProgressWhereInput | boolean
    connect?: OnboardingProgressWhereUniqueInput
    update?: XOR<XOR<OnboardingProgressUpdateToOneWithWhereWithoutUserInput, OnboardingProgressUpdateWithoutUserInput>, OnboardingProgressUncheckedUpdateWithoutUserInput>
  }

  export type AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountTypeChangeCreateWithoutUserInput, AccountTypeChangeUncheckedCreateWithoutUserInput> | AccountTypeChangeCreateWithoutUserInput[] | AccountTypeChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountTypeChangeCreateOrConnectWithoutUserInput | AccountTypeChangeCreateOrConnectWithoutUserInput[]
    upsert?: AccountTypeChangeUpsertWithWhereUniqueWithoutUserInput | AccountTypeChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountTypeChangeCreateManyUserInputEnvelope
    set?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
    disconnect?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
    delete?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
    connect?: AccountTypeChangeWhereUniqueInput | AccountTypeChangeWhereUniqueInput[]
    update?: AccountTypeChangeUpdateWithWhereUniqueWithoutUserInput | AccountTypeChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountTypeChangeUpdateManyWithWhereWithoutUserInput | AccountTypeChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountTypeChangeScalarWhereInput | AccountTypeChangeScalarWhereInput[]
  }

  export type MessageLimitUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageLimitCreateWithoutUserInput, MessageLimitUncheckedCreateWithoutUserInput> | MessageLimitCreateWithoutUserInput[] | MessageLimitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageLimitCreateOrConnectWithoutUserInput | MessageLimitCreateOrConnectWithoutUserInput[]
    upsert?: MessageLimitUpsertWithWhereUniqueWithoutUserInput | MessageLimitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageLimitCreateManyUserInputEnvelope
    set?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
    disconnect?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
    delete?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
    connect?: MessageLimitWhereUniqueInput | MessageLimitWhereUniqueInput[]
    update?: MessageLimitUpdateWithWhereUniqueWithoutUserInput | MessageLimitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageLimitUpdateManyWithWhereWithoutUserInput | MessageLimitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageLimitScalarWhereInput | MessageLimitScalarWhereInput[]
  }

  export type FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FeedPreferenceCreateWithoutUserInput, FeedPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: FeedPreferenceCreateOrConnectWithoutUserInput
    upsert?: FeedPreferenceUpsertWithoutUserInput
    disconnect?: FeedPreferenceWhereInput | boolean
    delete?: FeedPreferenceWhereInput | boolean
    connect?: FeedPreferenceWhereUniqueInput
    update?: XOR<XOR<FeedPreferenceUpdateToOneWithWhereWithoutUserInput, FeedPreferenceUpdateWithoutUserInput>, FeedPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type BlockUncheckedUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedInput | BlockUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedInput | BlockUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedInput | BlockUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBlockedUsersInput = {
    create?: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlockedByInput = {
    create?: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlockedUsersNestedInput = {
    create?: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedUsersInput
    upsert?: UserUpsertWithoutBlockedUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedUsersInput, UserUpdateWithoutBlockedUsersInput>, UserUncheckedUpdateWithoutBlockedUsersInput>
  }

  export type UserUpdateOneRequiredWithoutBlockedByNestedInput = {
    create?: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByInput
    upsert?: UserUpsertWithoutBlockedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedByInput, UserUpdateWithoutBlockedByInput>, UserUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type SocialLinkCreateNestedManyWithoutProfileInput = {
    create?: XOR<SocialLinkCreateWithoutProfileInput, SocialLinkUncheckedCreateWithoutProfileInput> | SocialLinkCreateWithoutProfileInput[] | SocialLinkUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutProfileInput | SocialLinkCreateOrConnectWithoutProfileInput[]
    createMany?: SocialLinkCreateManyProfileInputEnvelope
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
  }

  export type SocialLinkUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<SocialLinkCreateWithoutProfileInput, SocialLinkUncheckedCreateWithoutProfileInput> | SocialLinkCreateWithoutProfileInput[] | SocialLinkUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutProfileInput | SocialLinkCreateOrConnectWithoutProfileInput[]
    createMany?: SocialLinkCreateManyProfileInputEnvelope
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type SocialLinkUpdateManyWithoutProfileNestedInput = {
    create?: XOR<SocialLinkCreateWithoutProfileInput, SocialLinkUncheckedCreateWithoutProfileInput> | SocialLinkCreateWithoutProfileInput[] | SocialLinkUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutProfileInput | SocialLinkCreateOrConnectWithoutProfileInput[]
    upsert?: SocialLinkUpsertWithWhereUniqueWithoutProfileInput | SocialLinkUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: SocialLinkCreateManyProfileInputEnvelope
    set?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    disconnect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    delete?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    update?: SocialLinkUpdateWithWhereUniqueWithoutProfileInput | SocialLinkUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: SocialLinkUpdateManyWithWhereWithoutProfileInput | SocialLinkUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
  }

  export type SocialLinkUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<SocialLinkCreateWithoutProfileInput, SocialLinkUncheckedCreateWithoutProfileInput> | SocialLinkCreateWithoutProfileInput[] | SocialLinkUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutProfileInput | SocialLinkCreateOrConnectWithoutProfileInput[]
    upsert?: SocialLinkUpsertWithWhereUniqueWithoutProfileInput | SocialLinkUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: SocialLinkCreateManyProfileInputEnvelope
    set?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    disconnect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    delete?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    update?: SocialLinkUpdateWithWhereUniqueWithoutProfileInput | SocialLinkUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: SocialLinkUpdateManyWithWhereWithoutProfileInput | SocialLinkUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
  }

  export type UserProfileCreateNestedOneWithoutSocialLinksInput = {
    create?: XOR<UserProfileCreateWithoutSocialLinksInput, UserProfileUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutSocialLinksInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutSocialLinksNestedInput = {
    create?: XOR<UserProfileCreateWithoutSocialLinksInput, UserProfileUncheckedCreateWithoutSocialLinksInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutSocialLinksInput
    upsert?: UserProfileUpsertWithoutSocialLinksInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutSocialLinksInput, UserProfileUpdateWithoutSocialLinksInput>, UserProfileUncheckedUpdateWithoutSocialLinksInput>
  }

  export type FounderProfileCreateskillsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutFounderProfileInput = {
    create?: XOR<UserCreateWithoutFounderProfileInput, UserUncheckedCreateWithoutFounderProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutFounderProfileInput
    connect?: UserWhereUniqueInput
  }

  export type FundraisingDetailsCreateNestedOneWithoutFounderProfileInput = {
    create?: XOR<FundraisingDetailsCreateWithoutFounderProfileInput, FundraisingDetailsUncheckedCreateWithoutFounderProfileInput>
    connectOrCreate?: FundraisingDetailsCreateOrConnectWithoutFounderProfileInput
    connect?: FundraisingDetailsWhereUniqueInput
  }

  export type FundraisingDetailsUncheckedCreateNestedOneWithoutFounderProfileInput = {
    create?: XOR<FundraisingDetailsCreateWithoutFounderProfileInput, FundraisingDetailsUncheckedCreateWithoutFounderProfileInput>
    connectOrCreate?: FundraisingDetailsCreateOrConnectWithoutFounderProfileInput
    connect?: FundraisingDetailsWhereUniqueInput
  }

  export type FounderProfileUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutFounderProfileNestedInput = {
    create?: XOR<UserCreateWithoutFounderProfileInput, UserUncheckedCreateWithoutFounderProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutFounderProfileInput
    upsert?: UserUpsertWithoutFounderProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFounderProfileInput, UserUpdateWithoutFounderProfileInput>, UserUncheckedUpdateWithoutFounderProfileInput>
  }

  export type FundraisingDetailsUpdateOneWithoutFounderProfileNestedInput = {
    create?: XOR<FundraisingDetailsCreateWithoutFounderProfileInput, FundraisingDetailsUncheckedCreateWithoutFounderProfileInput>
    connectOrCreate?: FundraisingDetailsCreateOrConnectWithoutFounderProfileInput
    upsert?: FundraisingDetailsUpsertWithoutFounderProfileInput
    disconnect?: FundraisingDetailsWhereInput | boolean
    delete?: FundraisingDetailsWhereInput | boolean
    connect?: FundraisingDetailsWhereUniqueInput
    update?: XOR<XOR<FundraisingDetailsUpdateToOneWithWhereWithoutFounderProfileInput, FundraisingDetailsUpdateWithoutFounderProfileInput>, FundraisingDetailsUncheckedUpdateWithoutFounderProfileInput>
  }

  export type FundraisingDetailsUncheckedUpdateOneWithoutFounderProfileNestedInput = {
    create?: XOR<FundraisingDetailsCreateWithoutFounderProfileInput, FundraisingDetailsUncheckedCreateWithoutFounderProfileInput>
    connectOrCreate?: FundraisingDetailsCreateOrConnectWithoutFounderProfileInput
    upsert?: FundraisingDetailsUpsertWithoutFounderProfileInput
    disconnect?: FundraisingDetailsWhereInput | boolean
    delete?: FundraisingDetailsWhereInput | boolean
    connect?: FundraisingDetailsWhereUniqueInput
    update?: XOR<XOR<FundraisingDetailsUpdateToOneWithWhereWithoutFounderProfileInput, FundraisingDetailsUpdateWithoutFounderProfileInput>, FundraisingDetailsUncheckedUpdateWithoutFounderProfileInput>
  }

  export type FounderProfileCreateNestedOneWithoutFundraisingDetailsInput = {
    create?: XOR<FounderProfileCreateWithoutFundraisingDetailsInput, FounderProfileUncheckedCreateWithoutFundraisingDetailsInput>
    connectOrCreate?: FounderProfileCreateOrConnectWithoutFundraisingDetailsInput
    connect?: FounderProfileWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FounderProfileUpdateOneRequiredWithoutFundraisingDetailsNestedInput = {
    create?: XOR<FounderProfileCreateWithoutFundraisingDetailsInput, FounderProfileUncheckedCreateWithoutFundraisingDetailsInput>
    connectOrCreate?: FounderProfileCreateOrConnectWithoutFundraisingDetailsInput
    upsert?: FounderProfileUpsertWithoutFundraisingDetailsInput
    connect?: FounderProfileWhereUniqueInput
    update?: XOR<XOR<FounderProfileUpdateToOneWithWhereWithoutFundraisingDetailsInput, FounderProfileUpdateWithoutFundraisingDetailsInput>, FounderProfileUncheckedUpdateWithoutFundraisingDetailsInput>
  }

  export type InvestorProfileCreatestagesInput = {
    set: string[]
  }

  export type InvestorProfileCreateindustriesInput = {
    set: string[]
  }

  export type InvestorProfileCreategeographiesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutInvestorProfileInput = {
    create?: XOR<UserCreateWithoutInvestorProfileInput, UserUncheckedCreateWithoutInvestorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorProfileInput
    connect?: UserWhereUniqueInput
  }

  export type PortfolioCreateNestedManyWithoutInvestorProfileInput = {
    create?: XOR<PortfolioCreateWithoutInvestorProfileInput, PortfolioUncheckedCreateWithoutInvestorProfileInput> | PortfolioCreateWithoutInvestorProfileInput[] | PortfolioUncheckedCreateWithoutInvestorProfileInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutInvestorProfileInput | PortfolioCreateOrConnectWithoutInvestorProfileInput[]
    createMany?: PortfolioCreateManyInvestorProfileInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type PortfolioUncheckedCreateNestedManyWithoutInvestorProfileInput = {
    create?: XOR<PortfolioCreateWithoutInvestorProfileInput, PortfolioUncheckedCreateWithoutInvestorProfileInput> | PortfolioCreateWithoutInvestorProfileInput[] | PortfolioUncheckedCreateWithoutInvestorProfileInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutInvestorProfileInput | PortfolioCreateOrConnectWithoutInvestorProfileInput[]
    createMany?: PortfolioCreateManyInvestorProfileInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type InvestorProfileUpdatestagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InvestorProfileUpdateindustriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InvestorProfileUpdategeographiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutInvestorProfileNestedInput = {
    create?: XOR<UserCreateWithoutInvestorProfileInput, UserUncheckedCreateWithoutInvestorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorProfileInput
    upsert?: UserUpsertWithoutInvestorProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestorProfileInput, UserUpdateWithoutInvestorProfileInput>, UserUncheckedUpdateWithoutInvestorProfileInput>
  }

  export type PortfolioUpdateManyWithoutInvestorProfileNestedInput = {
    create?: XOR<PortfolioCreateWithoutInvestorProfileInput, PortfolioUncheckedCreateWithoutInvestorProfileInput> | PortfolioCreateWithoutInvestorProfileInput[] | PortfolioUncheckedCreateWithoutInvestorProfileInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutInvestorProfileInput | PortfolioCreateOrConnectWithoutInvestorProfileInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutInvestorProfileInput | PortfolioUpsertWithWhereUniqueWithoutInvestorProfileInput[]
    createMany?: PortfolioCreateManyInvestorProfileInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutInvestorProfileInput | PortfolioUpdateWithWhereUniqueWithoutInvestorProfileInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutInvestorProfileInput | PortfolioUpdateManyWithWhereWithoutInvestorProfileInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type PortfolioUncheckedUpdateManyWithoutInvestorProfileNestedInput = {
    create?: XOR<PortfolioCreateWithoutInvestorProfileInput, PortfolioUncheckedCreateWithoutInvestorProfileInput> | PortfolioCreateWithoutInvestorProfileInput[] | PortfolioUncheckedCreateWithoutInvestorProfileInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutInvestorProfileInput | PortfolioCreateOrConnectWithoutInvestorProfileInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutInvestorProfileInput | PortfolioUpsertWithWhereUniqueWithoutInvestorProfileInput[]
    createMany?: PortfolioCreateManyInvestorProfileInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutInvestorProfileInput | PortfolioUpdateWithWhereUniqueWithoutInvestorProfileInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutInvestorProfileInput | PortfolioUpdateManyWithWhereWithoutInvestorProfileInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type InvestorProfileCreateNestedOneWithoutPortfolioInput = {
    create?: XOR<InvestorProfileCreateWithoutPortfolioInput, InvestorProfileUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: InvestorProfileCreateOrConnectWithoutPortfolioInput
    connect?: InvestorProfileWhereUniqueInput
  }

  export type InvestorProfileUpdateOneRequiredWithoutPortfolioNestedInput = {
    create?: XOR<InvestorProfileCreateWithoutPortfolioInput, InvestorProfileUncheckedCreateWithoutPortfolioInput>
    connectOrCreate?: InvestorProfileCreateOrConnectWithoutPortfolioInput
    upsert?: InvestorProfileUpsertWithoutPortfolioInput
    connect?: InvestorProfileWhereUniqueInput
    update?: XOR<XOR<InvestorProfileUpdateToOneWithWhereWithoutPortfolioInput, InvestorProfileUpdateWithoutPortfolioInput>, InvestorProfileUncheckedUpdateWithoutPortfolioInput>
  }

  export type BuilderProfileCreateskillsInput = {
    set: string[]
  }

  export type BuilderProfileCreateportfolioUrlsInput = {
    set: string[]
  }

  export type BuilderProfileCreateindustryInterestsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutBuilderProfileInput = {
    create?: XOR<UserCreateWithoutBuilderProfileInput, UserUncheckedCreateWithoutBuilderProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuilderProfileInput
    connect?: UserWhereUniqueInput
  }

  export type BuilderProfileUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BuilderProfileUpdateportfolioUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BuilderProfileUpdateindustryInterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutBuilderProfileNestedInput = {
    create?: XOR<UserCreateWithoutBuilderProfileInput, UserUncheckedCreateWithoutBuilderProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuilderProfileInput
    upsert?: UserUpsertWithoutBuilderProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuilderProfileInput, UserUpdateWithoutBuilderProfileInput>, UserUncheckedUpdateWithoutBuilderProfileInput>
  }

  export type UserCreateNestedOneWithoutInvestorVerificationInput = {
    create?: XOR<UserCreateWithoutInvestorVerificationInput, UserUncheckedCreateWithoutInvestorVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorVerificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type UserUpdateOneRequiredWithoutInvestorVerificationNestedInput = {
    create?: XOR<UserCreateWithoutInvestorVerificationInput, UserUncheckedCreateWithoutInvestorVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorVerificationInput
    upsert?: UserUpsertWithoutInvestorVerificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestorVerificationInput, UserUpdateWithoutInvestorVerificationInput>, UserUncheckedUpdateWithoutInvestorVerificationInput>
  }

  export type VideoCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutVideosInput = {
    create?: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideosInput
    connect?: UserWhereUniqueInput
  }

  export type VideoTranscriptCreateNestedOneWithoutVideoInput = {
    create?: XOR<VideoTranscriptCreateWithoutVideoInput, VideoTranscriptUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoTranscriptCreateOrConnectWithoutVideoInput
    connect?: VideoTranscriptWhereUniqueInput
  }

  export type VideoAnalyticsCreateNestedOneWithoutVideoInput = {
    create?: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoAnalyticsCreateOrConnectWithoutVideoInput
    connect?: VideoAnalyticsWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutVideoInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutVideoInput = {
    create?: XOR<LikeCreateWithoutVideoInput, LikeUncheckedCreateWithoutVideoInput> | LikeCreateWithoutVideoInput[] | LikeUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutVideoInput | LikeCreateOrConnectWithoutVideoInput[]
    createMany?: LikeCreateManyVideoInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type SaveCreateNestedManyWithoutVideoInput = {
    create?: XOR<SaveCreateWithoutVideoInput, SaveUncheckedCreateWithoutVideoInput> | SaveCreateWithoutVideoInput[] | SaveUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutVideoInput | SaveCreateOrConnectWithoutVideoInput[]
    createMany?: SaveCreateManyVideoInputEnvelope
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
  }

  export type ShareCreateNestedManyWithoutVideoInput = {
    create?: XOR<ShareCreateWithoutVideoInput, ShareUncheckedCreateWithoutVideoInput> | ShareCreateWithoutVideoInput[] | ShareUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ShareCreateOrConnectWithoutVideoInput | ShareCreateOrConnectWithoutVideoInput[]
    createMany?: ShareCreateManyVideoInputEnvelope
    connect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
  }

  export type VideoViewCreateNestedManyWithoutVideoInput = {
    create?: XOR<VideoViewCreateWithoutVideoInput, VideoViewUncheckedCreateWithoutVideoInput> | VideoViewCreateWithoutVideoInput[] | VideoViewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoViewCreateOrConnectWithoutVideoInput | VideoViewCreateOrConnectWithoutVideoInput[]
    createMany?: VideoViewCreateManyVideoInputEnvelope
    connect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
  }

  export type ContentReportCreateNestedManyWithoutVideoInput = {
    create?: XOR<ContentReportCreateWithoutVideoInput, ContentReportUncheckedCreateWithoutVideoInput> | ContentReportCreateWithoutVideoInput[] | ContentReportUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ContentReportCreateOrConnectWithoutVideoInput | ContentReportCreateOrConnectWithoutVideoInput[]
    createMany?: ContentReportCreateManyVideoInputEnvelope
    connect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
  }

  export type ExpressInterestCreateNestedManyWithoutVideoInput = {
    create?: XOR<ExpressInterestCreateWithoutVideoInput, ExpressInterestUncheckedCreateWithoutVideoInput> | ExpressInterestCreateWithoutVideoInput[] | ExpressInterestUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutVideoInput | ExpressInterestCreateOrConnectWithoutVideoInput[]
    createMany?: ExpressInterestCreateManyVideoInputEnvelope
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
  }

  export type VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput = {
    create?: XOR<VideoTranscriptCreateWithoutVideoInput, VideoTranscriptUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoTranscriptCreateOrConnectWithoutVideoInput
    connect?: VideoTranscriptWhereUniqueInput
  }

  export type VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput = {
    create?: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoAnalyticsCreateOrConnectWithoutVideoInput
    connect?: VideoAnalyticsWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<LikeCreateWithoutVideoInput, LikeUncheckedCreateWithoutVideoInput> | LikeCreateWithoutVideoInput[] | LikeUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutVideoInput | LikeCreateOrConnectWithoutVideoInput[]
    createMany?: LikeCreateManyVideoInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type SaveUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<SaveCreateWithoutVideoInput, SaveUncheckedCreateWithoutVideoInput> | SaveCreateWithoutVideoInput[] | SaveUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutVideoInput | SaveCreateOrConnectWithoutVideoInput[]
    createMany?: SaveCreateManyVideoInputEnvelope
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
  }

  export type ShareUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<ShareCreateWithoutVideoInput, ShareUncheckedCreateWithoutVideoInput> | ShareCreateWithoutVideoInput[] | ShareUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ShareCreateOrConnectWithoutVideoInput | ShareCreateOrConnectWithoutVideoInput[]
    createMany?: ShareCreateManyVideoInputEnvelope
    connect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
  }

  export type VideoViewUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<VideoViewCreateWithoutVideoInput, VideoViewUncheckedCreateWithoutVideoInput> | VideoViewCreateWithoutVideoInput[] | VideoViewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoViewCreateOrConnectWithoutVideoInput | VideoViewCreateOrConnectWithoutVideoInput[]
    createMany?: VideoViewCreateManyVideoInputEnvelope
    connect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
  }

  export type ContentReportUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<ContentReportCreateWithoutVideoInput, ContentReportUncheckedCreateWithoutVideoInput> | ContentReportCreateWithoutVideoInput[] | ContentReportUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ContentReportCreateOrConnectWithoutVideoInput | ContentReportCreateOrConnectWithoutVideoInput[]
    createMany?: ContentReportCreateManyVideoInputEnvelope
    connect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
  }

  export type ExpressInterestUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<ExpressInterestCreateWithoutVideoInput, ExpressInterestUncheckedCreateWithoutVideoInput> | ExpressInterestCreateWithoutVideoInput[] | ExpressInterestUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutVideoInput | ExpressInterestCreateOrConnectWithoutVideoInput[]
    createMany?: ExpressInterestCreateManyVideoInputEnvelope
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
  }

  export type EnumVideoTypeFieldUpdateOperationsInput = {
    set?: $Enums.VideoType
  }

  export type EnumVideoVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.VideoVisibility
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VideoUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideosInput
    upsert?: UserUpsertWithoutVideosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVideosInput, UserUpdateWithoutVideosInput>, UserUncheckedUpdateWithoutVideosInput>
  }

  export type VideoTranscriptUpdateOneWithoutVideoNestedInput = {
    create?: XOR<VideoTranscriptCreateWithoutVideoInput, VideoTranscriptUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoTranscriptCreateOrConnectWithoutVideoInput
    upsert?: VideoTranscriptUpsertWithoutVideoInput
    disconnect?: VideoTranscriptWhereInput | boolean
    delete?: VideoTranscriptWhereInput | boolean
    connect?: VideoTranscriptWhereUniqueInput
    update?: XOR<XOR<VideoTranscriptUpdateToOneWithWhereWithoutVideoInput, VideoTranscriptUpdateWithoutVideoInput>, VideoTranscriptUncheckedUpdateWithoutVideoInput>
  }

  export type VideoAnalyticsUpdateOneWithoutVideoNestedInput = {
    create?: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoAnalyticsCreateOrConnectWithoutVideoInput
    upsert?: VideoAnalyticsUpsertWithoutVideoInput
    disconnect?: VideoAnalyticsWhereInput | boolean
    delete?: VideoAnalyticsWhereInput | boolean
    connect?: VideoAnalyticsWhereUniqueInput
    update?: XOR<XOR<VideoAnalyticsUpdateToOneWithWhereWithoutVideoInput, VideoAnalyticsUpdateWithoutVideoInput>, VideoAnalyticsUncheckedUpdateWithoutVideoInput>
  }

  export type CommentUpdateManyWithoutVideoNestedInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutVideoInput | CommentUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutVideoInput | CommentUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutVideoInput | CommentUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutVideoNestedInput = {
    create?: XOR<LikeCreateWithoutVideoInput, LikeUncheckedCreateWithoutVideoInput> | LikeCreateWithoutVideoInput[] | LikeUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutVideoInput | LikeCreateOrConnectWithoutVideoInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutVideoInput | LikeUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: LikeCreateManyVideoInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutVideoInput | LikeUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutVideoInput | LikeUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type SaveUpdateManyWithoutVideoNestedInput = {
    create?: XOR<SaveCreateWithoutVideoInput, SaveUncheckedCreateWithoutVideoInput> | SaveCreateWithoutVideoInput[] | SaveUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutVideoInput | SaveCreateOrConnectWithoutVideoInput[]
    upsert?: SaveUpsertWithWhereUniqueWithoutVideoInput | SaveUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: SaveCreateManyVideoInputEnvelope
    set?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    disconnect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    delete?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    update?: SaveUpdateWithWhereUniqueWithoutVideoInput | SaveUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: SaveUpdateManyWithWhereWithoutVideoInput | SaveUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: SaveScalarWhereInput | SaveScalarWhereInput[]
  }

  export type ShareUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ShareCreateWithoutVideoInput, ShareUncheckedCreateWithoutVideoInput> | ShareCreateWithoutVideoInput[] | ShareUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ShareCreateOrConnectWithoutVideoInput | ShareCreateOrConnectWithoutVideoInput[]
    upsert?: ShareUpsertWithWhereUniqueWithoutVideoInput | ShareUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ShareCreateManyVideoInputEnvelope
    set?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    disconnect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    delete?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    connect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    update?: ShareUpdateWithWhereUniqueWithoutVideoInput | ShareUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ShareUpdateManyWithWhereWithoutVideoInput | ShareUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ShareScalarWhereInput | ShareScalarWhereInput[]
  }

  export type VideoViewUpdateManyWithoutVideoNestedInput = {
    create?: XOR<VideoViewCreateWithoutVideoInput, VideoViewUncheckedCreateWithoutVideoInput> | VideoViewCreateWithoutVideoInput[] | VideoViewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoViewCreateOrConnectWithoutVideoInput | VideoViewCreateOrConnectWithoutVideoInput[]
    upsert?: VideoViewUpsertWithWhereUniqueWithoutVideoInput | VideoViewUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: VideoViewCreateManyVideoInputEnvelope
    set?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    disconnect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    delete?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    connect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    update?: VideoViewUpdateWithWhereUniqueWithoutVideoInput | VideoViewUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: VideoViewUpdateManyWithWhereWithoutVideoInput | VideoViewUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: VideoViewScalarWhereInput | VideoViewScalarWhereInput[]
  }

  export type ContentReportUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ContentReportCreateWithoutVideoInput, ContentReportUncheckedCreateWithoutVideoInput> | ContentReportCreateWithoutVideoInput[] | ContentReportUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ContentReportCreateOrConnectWithoutVideoInput | ContentReportCreateOrConnectWithoutVideoInput[]
    upsert?: ContentReportUpsertWithWhereUniqueWithoutVideoInput | ContentReportUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ContentReportCreateManyVideoInputEnvelope
    set?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    disconnect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    delete?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    connect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    update?: ContentReportUpdateWithWhereUniqueWithoutVideoInput | ContentReportUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ContentReportUpdateManyWithWhereWithoutVideoInput | ContentReportUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ContentReportScalarWhereInput | ContentReportScalarWhereInput[]
  }

  export type ExpressInterestUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ExpressInterestCreateWithoutVideoInput, ExpressInterestUncheckedCreateWithoutVideoInput> | ExpressInterestCreateWithoutVideoInput[] | ExpressInterestUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutVideoInput | ExpressInterestCreateOrConnectWithoutVideoInput[]
    upsert?: ExpressInterestUpsertWithWhereUniqueWithoutVideoInput | ExpressInterestUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ExpressInterestCreateManyVideoInputEnvelope
    set?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    disconnect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    delete?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    update?: ExpressInterestUpdateWithWhereUniqueWithoutVideoInput | ExpressInterestUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ExpressInterestUpdateManyWithWhereWithoutVideoInput | ExpressInterestUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ExpressInterestScalarWhereInput | ExpressInterestScalarWhereInput[]
  }

  export type VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput = {
    create?: XOR<VideoTranscriptCreateWithoutVideoInput, VideoTranscriptUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoTranscriptCreateOrConnectWithoutVideoInput
    upsert?: VideoTranscriptUpsertWithoutVideoInput
    disconnect?: VideoTranscriptWhereInput | boolean
    delete?: VideoTranscriptWhereInput | boolean
    connect?: VideoTranscriptWhereUniqueInput
    update?: XOR<XOR<VideoTranscriptUpdateToOneWithWhereWithoutVideoInput, VideoTranscriptUpdateWithoutVideoInput>, VideoTranscriptUncheckedUpdateWithoutVideoInput>
  }

  export type VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput = {
    create?: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    connectOrCreate?: VideoAnalyticsCreateOrConnectWithoutVideoInput
    upsert?: VideoAnalyticsUpsertWithoutVideoInput
    disconnect?: VideoAnalyticsWhereInput | boolean
    delete?: VideoAnalyticsWhereInput | boolean
    connect?: VideoAnalyticsWhereUniqueInput
    update?: XOR<XOR<VideoAnalyticsUpdateToOneWithWhereWithoutVideoInput, VideoAnalyticsUpdateWithoutVideoInput>, VideoAnalyticsUncheckedUpdateWithoutVideoInput>
  }

  export type CommentUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput> | CommentCreateWithoutVideoInput[] | CommentUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutVideoInput | CommentCreateOrConnectWithoutVideoInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutVideoInput | CommentUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: CommentCreateManyVideoInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutVideoInput | CommentUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutVideoInput | CommentUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<LikeCreateWithoutVideoInput, LikeUncheckedCreateWithoutVideoInput> | LikeCreateWithoutVideoInput[] | LikeUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutVideoInput | LikeCreateOrConnectWithoutVideoInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutVideoInput | LikeUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: LikeCreateManyVideoInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutVideoInput | LikeUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutVideoInput | LikeUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type SaveUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<SaveCreateWithoutVideoInput, SaveUncheckedCreateWithoutVideoInput> | SaveCreateWithoutVideoInput[] | SaveUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutVideoInput | SaveCreateOrConnectWithoutVideoInput[]
    upsert?: SaveUpsertWithWhereUniqueWithoutVideoInput | SaveUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: SaveCreateManyVideoInputEnvelope
    set?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    disconnect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    delete?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    update?: SaveUpdateWithWhereUniqueWithoutVideoInput | SaveUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: SaveUpdateManyWithWhereWithoutVideoInput | SaveUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: SaveScalarWhereInput | SaveScalarWhereInput[]
  }

  export type ShareUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ShareCreateWithoutVideoInput, ShareUncheckedCreateWithoutVideoInput> | ShareCreateWithoutVideoInput[] | ShareUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ShareCreateOrConnectWithoutVideoInput | ShareCreateOrConnectWithoutVideoInput[]
    upsert?: ShareUpsertWithWhereUniqueWithoutVideoInput | ShareUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ShareCreateManyVideoInputEnvelope
    set?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    disconnect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    delete?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    connect?: ShareWhereUniqueInput | ShareWhereUniqueInput[]
    update?: ShareUpdateWithWhereUniqueWithoutVideoInput | ShareUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ShareUpdateManyWithWhereWithoutVideoInput | ShareUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ShareScalarWhereInput | ShareScalarWhereInput[]
  }

  export type VideoViewUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<VideoViewCreateWithoutVideoInput, VideoViewUncheckedCreateWithoutVideoInput> | VideoViewCreateWithoutVideoInput[] | VideoViewUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: VideoViewCreateOrConnectWithoutVideoInput | VideoViewCreateOrConnectWithoutVideoInput[]
    upsert?: VideoViewUpsertWithWhereUniqueWithoutVideoInput | VideoViewUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: VideoViewCreateManyVideoInputEnvelope
    set?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    disconnect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    delete?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    connect?: VideoViewWhereUniqueInput | VideoViewWhereUniqueInput[]
    update?: VideoViewUpdateWithWhereUniqueWithoutVideoInput | VideoViewUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: VideoViewUpdateManyWithWhereWithoutVideoInput | VideoViewUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: VideoViewScalarWhereInput | VideoViewScalarWhereInput[]
  }

  export type ContentReportUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ContentReportCreateWithoutVideoInput, ContentReportUncheckedCreateWithoutVideoInput> | ContentReportCreateWithoutVideoInput[] | ContentReportUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ContentReportCreateOrConnectWithoutVideoInput | ContentReportCreateOrConnectWithoutVideoInput[]
    upsert?: ContentReportUpsertWithWhereUniqueWithoutVideoInput | ContentReportUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ContentReportCreateManyVideoInputEnvelope
    set?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    disconnect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    delete?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    connect?: ContentReportWhereUniqueInput | ContentReportWhereUniqueInput[]
    update?: ContentReportUpdateWithWhereUniqueWithoutVideoInput | ContentReportUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ContentReportUpdateManyWithWhereWithoutVideoInput | ContentReportUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ContentReportScalarWhereInput | ContentReportScalarWhereInput[]
  }

  export type ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ExpressInterestCreateWithoutVideoInput, ExpressInterestUncheckedCreateWithoutVideoInput> | ExpressInterestCreateWithoutVideoInput[] | ExpressInterestUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ExpressInterestCreateOrConnectWithoutVideoInput | ExpressInterestCreateOrConnectWithoutVideoInput[]
    upsert?: ExpressInterestUpsertWithWhereUniqueWithoutVideoInput | ExpressInterestUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ExpressInterestCreateManyVideoInputEnvelope
    set?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    disconnect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    delete?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    connect?: ExpressInterestWhereUniqueInput | ExpressInterestWhereUniqueInput[]
    update?: ExpressInterestUpdateWithWhereUniqueWithoutVideoInput | ExpressInterestUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ExpressInterestUpdateManyWithWhereWithoutVideoInput | ExpressInterestUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ExpressInterestScalarWhereInput | ExpressInterestScalarWhereInput[]
  }

  export type VideoCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<VideoCreateWithoutTranscriptInput, VideoUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: VideoCreateOrConnectWithoutTranscriptInput
    connect?: VideoWhereUniqueInput
  }

  export type VideoUpdateOneRequiredWithoutTranscriptNestedInput = {
    create?: XOR<VideoCreateWithoutTranscriptInput, VideoUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: VideoCreateOrConnectWithoutTranscriptInput
    upsert?: VideoUpsertWithoutTranscriptInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutTranscriptInput, VideoUpdateWithoutTranscriptInput>, VideoUncheckedUpdateWithoutTranscriptInput>
  }

  export type VideoCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<VideoCreateWithoutAnalyticsInput, VideoUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutAnalyticsInput
    connect?: VideoWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VideoUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<VideoCreateWithoutAnalyticsInput, VideoUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutAnalyticsInput
    upsert?: VideoUpsertWithoutAnalyticsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutAnalyticsInput, VideoUpdateWithoutAnalyticsInput>, VideoUncheckedUpdateWithoutAnalyticsInput>
  }

  export type VideoCreateNestedOneWithoutViewsInput = {
    create?: XOR<VideoCreateWithoutViewsInput, VideoUncheckedCreateWithoutViewsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutViewsInput
    connect?: VideoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVideoViewsInput = {
    create?: XOR<UserCreateWithoutVideoViewsInput, UserUncheckedCreateWithoutVideoViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoViewsInput
    connect?: UserWhereUniqueInput
  }

  export type VideoUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<VideoCreateWithoutViewsInput, VideoUncheckedCreateWithoutViewsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutViewsInput
    upsert?: VideoUpsertWithoutViewsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutViewsInput, VideoUpdateWithoutViewsInput>, VideoUncheckedUpdateWithoutViewsInput>
  }

  export type UserUpdateOneRequiredWithoutVideoViewsNestedInput = {
    create?: XOR<UserCreateWithoutVideoViewsInput, UserUncheckedCreateWithoutVideoViewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoViewsInput
    upsert?: UserUpsertWithoutVideoViewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVideoViewsInput, UserUpdateWithoutVideoViewsInput>, UserUncheckedUpdateWithoutVideoViewsInput>
  }

  export type VideoCreateNestedOneWithoutLikesInput = {
    create?: XOR<VideoCreateWithoutLikesInput, VideoUncheckedCreateWithoutLikesInput>
    connectOrCreate?: VideoCreateOrConnectWithoutLikesInput
    connect?: VideoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    connect?: UserWhereUniqueInput
  }

  export type VideoUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<VideoCreateWithoutLikesInput, VideoUncheckedCreateWithoutLikesInput>
    connectOrCreate?: VideoCreateOrConnectWithoutLikesInput
    upsert?: VideoUpsertWithoutLikesInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutLikesInput, VideoUpdateWithoutLikesInput>, VideoUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    upsert?: UserUpsertWithoutLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesInput, UserUpdateWithoutLikesInput>, UserUncheckedUpdateWithoutLikesInput>
  }

  export type VideoCreateNestedOneWithoutCommentsInput = {
    create?: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutCommentsInput
    connect?: VideoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type VideoUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutCommentsInput
    upsert?: VideoUpsertWithoutCommentsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutCommentsInput, VideoUpdateWithoutCommentsInput>, VideoUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type VideoCreateNestedOneWithoutSavesInput = {
    create?: XOR<VideoCreateWithoutSavesInput, VideoUncheckedCreateWithoutSavesInput>
    connectOrCreate?: VideoCreateOrConnectWithoutSavesInput
    connect?: VideoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSavesInput = {
    create?: XOR<UserCreateWithoutSavesInput, UserUncheckedCreateWithoutSavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavesInput
    connect?: UserWhereUniqueInput
  }

  export type SaveListCreateNestedOneWithoutSavesInput = {
    create?: XOR<SaveListCreateWithoutSavesInput, SaveListUncheckedCreateWithoutSavesInput>
    connectOrCreate?: SaveListCreateOrConnectWithoutSavesInput
    connect?: SaveListWhereUniqueInput
  }

  export type VideoUpdateOneRequiredWithoutSavesNestedInput = {
    create?: XOR<VideoCreateWithoutSavesInput, VideoUncheckedCreateWithoutSavesInput>
    connectOrCreate?: VideoCreateOrConnectWithoutSavesInput
    upsert?: VideoUpsertWithoutSavesInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutSavesInput, VideoUpdateWithoutSavesInput>, VideoUncheckedUpdateWithoutSavesInput>
  }

  export type UserUpdateOneRequiredWithoutSavesNestedInput = {
    create?: XOR<UserCreateWithoutSavesInput, UserUncheckedCreateWithoutSavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavesInput
    upsert?: UserUpsertWithoutSavesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavesInput, UserUpdateWithoutSavesInput>, UserUncheckedUpdateWithoutSavesInput>
  }

  export type SaveListUpdateOneWithoutSavesNestedInput = {
    create?: XOR<SaveListCreateWithoutSavesInput, SaveListUncheckedCreateWithoutSavesInput>
    connectOrCreate?: SaveListCreateOrConnectWithoutSavesInput
    upsert?: SaveListUpsertWithoutSavesInput
    disconnect?: SaveListWhereInput | boolean
    delete?: SaveListWhereInput | boolean
    connect?: SaveListWhereUniqueInput
    update?: XOR<XOR<SaveListUpdateToOneWithWhereWithoutSavesInput, SaveListUpdateWithoutSavesInput>, SaveListUncheckedUpdateWithoutSavesInput>
  }

  export type SaveCreateNestedManyWithoutListInput = {
    create?: XOR<SaveCreateWithoutListInput, SaveUncheckedCreateWithoutListInput> | SaveCreateWithoutListInput[] | SaveUncheckedCreateWithoutListInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutListInput | SaveCreateOrConnectWithoutListInput[]
    createMany?: SaveCreateManyListInputEnvelope
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
  }

  export type SaveUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<SaveCreateWithoutListInput, SaveUncheckedCreateWithoutListInput> | SaveCreateWithoutListInput[] | SaveUncheckedCreateWithoutListInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutListInput | SaveCreateOrConnectWithoutListInput[]
    createMany?: SaveCreateManyListInputEnvelope
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
  }

  export type SaveUpdateManyWithoutListNestedInput = {
    create?: XOR<SaveCreateWithoutListInput, SaveUncheckedCreateWithoutListInput> | SaveCreateWithoutListInput[] | SaveUncheckedCreateWithoutListInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutListInput | SaveCreateOrConnectWithoutListInput[]
    upsert?: SaveUpsertWithWhereUniqueWithoutListInput | SaveUpsertWithWhereUniqueWithoutListInput[]
    createMany?: SaveCreateManyListInputEnvelope
    set?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    disconnect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    delete?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    update?: SaveUpdateWithWhereUniqueWithoutListInput | SaveUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: SaveUpdateManyWithWhereWithoutListInput | SaveUpdateManyWithWhereWithoutListInput[]
    deleteMany?: SaveScalarWhereInput | SaveScalarWhereInput[]
  }

  export type SaveUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<SaveCreateWithoutListInput, SaveUncheckedCreateWithoutListInput> | SaveCreateWithoutListInput[] | SaveUncheckedCreateWithoutListInput[]
    connectOrCreate?: SaveCreateOrConnectWithoutListInput | SaveCreateOrConnectWithoutListInput[]
    upsert?: SaveUpsertWithWhereUniqueWithoutListInput | SaveUpsertWithWhereUniqueWithoutListInput[]
    createMany?: SaveCreateManyListInputEnvelope
    set?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    disconnect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    delete?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    connect?: SaveWhereUniqueInput | SaveWhereUniqueInput[]
    update?: SaveUpdateWithWhereUniqueWithoutListInput | SaveUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: SaveUpdateManyWithWhereWithoutListInput | SaveUpdateManyWithWhereWithoutListInput[]
    deleteMany?: SaveScalarWhereInput | SaveScalarWhereInput[]
  }

  export type VideoCreateNestedOneWithoutSharesInput = {
    create?: XOR<VideoCreateWithoutSharesInput, VideoUncheckedCreateWithoutSharesInput>
    connectOrCreate?: VideoCreateOrConnectWithoutSharesInput
    connect?: VideoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharesInput = {
    create?: XOR<UserCreateWithoutSharesInput, UserUncheckedCreateWithoutSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharesInput
    connect?: UserWhereUniqueInput
  }

  export type VideoUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<VideoCreateWithoutSharesInput, VideoUncheckedCreateWithoutSharesInput>
    connectOrCreate?: VideoCreateOrConnectWithoutSharesInput
    upsert?: VideoUpsertWithoutSharesInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutSharesInput, VideoUpdateWithoutSharesInput>, VideoUncheckedUpdateWithoutSharesInput>
  }

  export type UserUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<UserCreateWithoutSharesInput, UserUncheckedCreateWithoutSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharesInput
    upsert?: UserUpsertWithoutSharesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharesInput, UserUpdateWithoutSharesInput>, UserUncheckedUpdateWithoutSharesInput>
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserCreateNestedOneWithoutExpressedInterestsInput = {
    create?: XOR<UserCreateWithoutExpressedInterestsInput, UserUncheckedCreateWithoutExpressedInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpressedInterestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedInterestsInput = {
    create?: XOR<UserCreateWithoutReceivedInterestsInput, UserUncheckedCreateWithoutReceivedInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInterestsInput
    connect?: UserWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutExpressInterestsInput = {
    create?: XOR<VideoCreateWithoutExpressInterestsInput, VideoUncheckedCreateWithoutExpressInterestsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutExpressInterestsInput
    connect?: VideoWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExpressedInterestsNestedInput = {
    create?: XOR<UserCreateWithoutExpressedInterestsInput, UserUncheckedCreateWithoutExpressedInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpressedInterestsInput
    upsert?: UserUpsertWithoutExpressedInterestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpressedInterestsInput, UserUpdateWithoutExpressedInterestsInput>, UserUncheckedUpdateWithoutExpressedInterestsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedInterestsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedInterestsInput, UserUncheckedCreateWithoutReceivedInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInterestsInput
    upsert?: UserUpsertWithoutReceivedInterestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedInterestsInput, UserUpdateWithoutReceivedInterestsInput>, UserUncheckedUpdateWithoutReceivedInterestsInput>
  }

  export type VideoUpdateOneRequiredWithoutExpressInterestsNestedInput = {
    create?: XOR<VideoCreateWithoutExpressInterestsInput, VideoUncheckedCreateWithoutExpressInterestsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutExpressInterestsInput
    upsert?: VideoUpsertWithoutExpressInterestsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutExpressInterestsInput, VideoUpdateWithoutExpressInterestsInput>, VideoUncheckedUpdateWithoutExpressInterestsInput>
  }

  export type UserCreateNestedOneWithoutProfileRevealsAsInvestorInput = {
    create?: XOR<UserCreateWithoutProfileRevealsAsInvestorInput, UserUncheckedCreateWithoutProfileRevealsAsInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileRevealsAsInvestorInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProfileRevealsAsFounderInput = {
    create?: XOR<UserCreateWithoutProfileRevealsAsFounderInput, UserUncheckedCreateWithoutProfileRevealsAsFounderInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileRevealsAsFounderInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileRevealsAsInvestorNestedInput = {
    create?: XOR<UserCreateWithoutProfileRevealsAsInvestorInput, UserUncheckedCreateWithoutProfileRevealsAsInvestorInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileRevealsAsInvestorInput
    upsert?: UserUpsertWithoutProfileRevealsAsInvestorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileRevealsAsInvestorInput, UserUpdateWithoutProfileRevealsAsInvestorInput>, UserUncheckedUpdateWithoutProfileRevealsAsInvestorInput>
  }

  export type UserUpdateOneRequiredWithoutProfileRevealsAsFounderNestedInput = {
    create?: XOR<UserCreateWithoutProfileRevealsAsFounderInput, UserUncheckedCreateWithoutProfileRevealsAsFounderInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileRevealsAsFounderInput
    upsert?: UserUpsertWithoutProfileRevealsAsFounderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileRevealsAsFounderInput, UserUpdateWithoutProfileRevealsAsFounderInput>, UserUncheckedUpdateWithoutProfileRevealsAsFounderInput>
  }

  export type UserCreateNestedOneWithoutConversations1Input = {
    create?: XOR<UserCreateWithoutConversations1Input, UserUncheckedCreateWithoutConversations1Input>
    connectOrCreate?: UserCreateOrConnectWithoutConversations1Input
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversations2Input = {
    create?: XOR<UserCreateWithoutConversations2Input, UserUncheckedCreateWithoutConversations2Input>
    connectOrCreate?: UserCreateOrConnectWithoutConversations2Input
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumConversationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConversationStatus
  }

  export type UserUpdateOneRequiredWithoutConversations1NestedInput = {
    create?: XOR<UserCreateWithoutConversations1Input, UserUncheckedCreateWithoutConversations1Input>
    connectOrCreate?: UserCreateOrConnectWithoutConversations1Input
    upsert?: UserUpsertWithoutConversations1Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversations1Input, UserUpdateWithoutConversations1Input>, UserUncheckedUpdateWithoutConversations1Input>
  }

  export type UserUpdateOneRequiredWithoutConversations2NestedInput = {
    create?: XOR<UserCreateWithoutConversations2Input, UserUncheckedCreateWithoutConversations2Input>
    connectOrCreate?: UserCreateOrConnectWithoutConversations2Input
    upsert?: UserUpsertWithoutConversations2Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversations2Input, UserUpdateWithoutConversations2Input>, UserUncheckedUpdateWithoutConversations2Input>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    upsert?: UserUpsertWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesSentInput, UserUpdateWithoutMessagesSentInput>, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserCreateNestedOneWithoutContentReportsInput = {
    create?: XOR<UserCreateWithoutContentReportsInput, UserUncheckedCreateWithoutContentReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentReportsInput
    connect?: UserWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutReportsInput = {
    create?: XOR<VideoCreateWithoutReportsInput, VideoUncheckedCreateWithoutReportsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutReportsInput
    connect?: VideoWhereUniqueInput
  }

  export type EnumReportCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ReportCategory
  }

  export type UserUpdateOneRequiredWithoutContentReportsNestedInput = {
    create?: XOR<UserCreateWithoutContentReportsInput, UserUncheckedCreateWithoutContentReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentReportsInput
    upsert?: UserUpsertWithoutContentReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContentReportsInput, UserUpdateWithoutContentReportsInput>, UserUncheckedUpdateWithoutContentReportsInput>
  }

  export type VideoUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<VideoCreateWithoutReportsInput, VideoUncheckedCreateWithoutReportsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutReportsInput
    upsert?: VideoUpsertWithoutReportsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutReportsInput, VideoUpdateWithoutReportsInput>, VideoUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutModerationActionsInput = {
    create?: XOR<UserCreateWithoutModerationActionsInput, UserUncheckedCreateWithoutModerationActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModerationActionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumModerationActionFieldUpdateOperationsInput = {
    set?: $Enums.ModerationAction
  }

  export type UserUpdateOneRequiredWithoutModerationActionsNestedInput = {
    create?: XOR<UserCreateWithoutModerationActionsInput, UserUncheckedCreateWithoutModerationActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModerationActionsInput
    upsert?: UserUpsertWithoutModerationActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModerationActionsInput, UserUpdateWithoutModerationActionsInput>, UserUncheckedUpdateWithoutModerationActionsInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNotificationPrefsInput = {
    create?: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPrefsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationPrefsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPrefsInput
    upsert?: UserUpsertWithoutNotificationPrefsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPrefsInput, UserUpdateWithoutNotificationPrefsInput>, UserUncheckedUpdateWithoutNotificationPrefsInput>
  }

  export type FeedPreferenceCreateindustriesInput = {
    set: string[]
  }

  export type FeedPreferenceCreatestagesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutFeedPreferencesInput = {
    create?: XOR<UserCreateWithoutFeedPreferencesInput, UserUncheckedCreateWithoutFeedPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type FeedPreferenceUpdateindustriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FeedPreferenceUpdatestagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutFeedPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutFeedPreferencesInput, UserUncheckedCreateWithoutFeedPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedPreferencesInput
    upsert?: UserUpsertWithoutFeedPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedPreferencesInput, UserUpdateWithoutFeedPreferencesInput>, UserUncheckedUpdateWithoutFeedPreferencesInput>
  }

  export type UserCreateNestedOneWithoutSearchHistoryInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSearchHistoryNestedInput = {
    create?: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchHistoryInput
    upsert?: UserUpsertWithoutSearchHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchHistoryInput, UserUpdateWithoutSearchHistoryInput>, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type UserCreateNestedOneWithoutOnboardingProgressInput = {
    create?: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingProgressInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOnboardingProgressNestedInput = {
    create?: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingProgressInput
    upsert?: UserUpsertWithoutOnboardingProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOnboardingProgressInput, UserUpdateWithoutOnboardingProgressInput>, UserUncheckedUpdateWithoutOnboardingProgressInput>
  }

  export type UserCreateNestedOneWithoutAccountTypeChangesInput = {
    create?: XOR<UserCreateWithoutAccountTypeChangesInput, UserUncheckedCreateWithoutAccountTypeChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountTypeChangesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountTypeChangesNestedInput = {
    create?: XOR<UserCreateWithoutAccountTypeChangesInput, UserUncheckedCreateWithoutAccountTypeChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountTypeChangesInput
    upsert?: UserUpsertWithoutAccountTypeChangesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountTypeChangesInput, UserUpdateWithoutAccountTypeChangesInput>, UserUncheckedUpdateWithoutAccountTypeChangesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumVideoTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoType | EnumVideoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoTypeFilter<$PrismaModel> | $Enums.VideoType
  }

  export type NestedEnumVideoVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoVisibility | EnumVideoVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoVisibility[] | ListEnumVideoVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoVisibility[] | ListEnumVideoVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoVisibilityFilter<$PrismaModel> | $Enums.VideoVisibility
  }

  export type NestedEnumVideoTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoType | EnumVideoTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoTypeWithAggregatesFilter<$PrismaModel> | $Enums.VideoType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoTypeFilter<$PrismaModel>
    _max?: NestedEnumVideoTypeFilter<$PrismaModel>
  }

  export type NestedEnumVideoVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoVisibility | EnumVideoVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoVisibility[] | ListEnumVideoVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoVisibility[] | ListEnumVideoVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.VideoVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVideoVisibilityFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusFilter<$PrismaModel> | $Enums.ConversationStatus
  }

  export type NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumConversationStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportCategory | EnumReportCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ReportCategory[] | ListEnumReportCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportCategory[] | ListEnumReportCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumReportCategoryFilter<$PrismaModel> | $Enums.ReportCategory
  }

  export type NestedEnumReportCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportCategory | EnumReportCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ReportCategory[] | ListEnumReportCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportCategory[] | ListEnumReportCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumReportCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ReportCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportCategoryFilter<$PrismaModel>
    _max?: NestedEnumReportCategoryFilter<$PrismaModel>
  }

  export type NestedEnumModerationActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationAction | EnumModerationActionFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumModerationActionFilter<$PrismaModel> | $Enums.ModerationAction
  }

  export type NestedEnumModerationActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModerationAction | EnumModerationActionFieldRefInput<$PrismaModel>
    in?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModerationAction[] | ListEnumModerationActionFieldRefInput<$PrismaModel>
    not?: NestedEnumModerationActionWithAggregatesFilter<$PrismaModel> | $Enums.ModerationAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModerationActionFilter<$PrismaModel>
    _max?: NestedEnumModerationActionFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserProfileCreateWithoutUserInput = {
    id?: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    socialLinks?: SocialLinkCreateNestedManyWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    socialLinks?: SocialLinkUncheckedCreateNestedManyWithoutProfileInput
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type FounderProfileCreateWithoutUserInput = {
    id?: string
    tagline?: string | null
    companyName?: string | null
    industry?: string | null
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: string | null
    education?: string | null
    skills?: FounderProfileCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    fundraisingDetails?: FundraisingDetailsCreateNestedOneWithoutFounderProfileInput
  }

  export type FounderProfileUncheckedCreateWithoutUserInput = {
    id?: string
    tagline?: string | null
    companyName?: string | null
    industry?: string | null
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: string | null
    education?: string | null
    skills?: FounderProfileCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    fundraisingDetails?: FundraisingDetailsUncheckedCreateNestedOneWithoutFounderProfileInput
  }

  export type FounderProfileCreateOrConnectWithoutUserInput = {
    where: FounderProfileWhereUniqueInput
    create: XOR<FounderProfileCreateWithoutUserInput, FounderProfileUncheckedCreateWithoutUserInput>
  }

  export type InvestorProfileCreateWithoutUserInput = {
    id?: string
    firm?: string | null
    title?: string | null
    thesis?: string | null
    thesisVideo?: string | null
    checkSizeMin?: number | null
    checkSizeMax?: number | null
    stages?: InvestorProfileCreatestagesInput | string[]
    industries?: InvestorProfileCreateindustriesInput | string[]
    geographies?: InvestorProfileCreategeographiesInput | string[]
    isPublicMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedManyWithoutInvestorProfileInput
  }

  export type InvestorProfileUncheckedCreateWithoutUserInput = {
    id?: string
    firm?: string | null
    title?: string | null
    thesis?: string | null
    thesisVideo?: string | null
    checkSizeMin?: number | null
    checkSizeMax?: number | null
    stages?: InvestorProfileCreatestagesInput | string[]
    industries?: InvestorProfileCreateindustriesInput | string[]
    geographies?: InvestorProfileCreategeographiesInput | string[]
    isPublicMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioUncheckedCreateNestedManyWithoutInvestorProfileInput
  }

  export type InvestorProfileCreateOrConnectWithoutUserInput = {
    where: InvestorProfileWhereUniqueInput
    create: XOR<InvestorProfileCreateWithoutUserInput, InvestorProfileUncheckedCreateWithoutUserInput>
  }

  export type BuilderProfileCreateWithoutUserInput = {
    id?: string
    skills?: BuilderProfileCreateskillsInput | string[]
    portfolioUrls?: BuilderProfileCreateportfolioUrlsInput | string[]
    availability?: string
    lookingForProject?: boolean
    industryInterests?: BuilderProfileCreateindustryInterestsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuilderProfileUncheckedCreateWithoutUserInput = {
    id?: string
    skills?: BuilderProfileCreateskillsInput | string[]
    portfolioUrls?: BuilderProfileCreateportfolioUrlsInput | string[]
    availability?: string
    lookingForProject?: boolean
    industryInterests?: BuilderProfileCreateindustryInterestsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuilderProfileCreateOrConnectWithoutUserInput = {
    where: BuilderProfileWhereUniqueInput
    create: XOR<BuilderProfileCreateWithoutUserInput, BuilderProfileUncheckedCreateWithoutUserInput>
  }

  export type InvestorVerificationCreateWithoutUserInput = {
    id?: string
    linkedinUrl?: string | null
    proofUrl?: string | null
    proofDocument?: string | null
    status?: $Enums.VerificationStatus
    reviewerNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorVerificationUncheckedCreateWithoutUserInput = {
    id?: string
    linkedinUrl?: string | null
    proofUrl?: string | null
    proofDocument?: string | null
    status?: $Enums.VerificationStatus
    reviewerNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorVerificationCreateOrConnectWithoutUserInput = {
    where: InvestorVerificationWhereUniqueInput
    create: XOR<InvestorVerificationCreateWithoutUserInput, InvestorVerificationUncheckedCreateWithoutUserInput>
  }

  export type VideoCreateWithoutUserInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutUserInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutUserInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput>
  }

  export type VideoCreateManyUserInputEnvelope = {
    data: VideoCreateManyUserInput | VideoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    content: string
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    video: VideoCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    videoId: string
    content: string
    parentId?: string | null
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutUserInput = {
    id?: string
    videoId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeCreateManyUserInputEnvelope = {
    data: LikeCreateManyUserInput | LikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SaveCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutSavesInput
    list?: SaveListCreateNestedOneWithoutSavesInput
  }

  export type SaveUncheckedCreateWithoutUserInput = {
    id?: string
    videoId: string
    listId?: string | null
    createdAt?: Date | string
  }

  export type SaveCreateOrConnectWithoutUserInput = {
    where: SaveWhereUniqueInput
    create: XOR<SaveCreateWithoutUserInput, SaveUncheckedCreateWithoutUserInput>
  }

  export type SaveCreateManyUserInputEnvelope = {
    data: SaveCreateManyUserInput | SaveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShareCreateWithoutUserInput = {
    id?: string
    platform: string
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutSharesInput
  }

  export type ShareUncheckedCreateWithoutUserInput = {
    id?: string
    videoId: string
    platform: string
    createdAt?: Date | string
  }

  export type ShareCreateOrConnectWithoutUserInput = {
    where: ShareWhereUniqueInput
    create: XOR<ShareCreateWithoutUserInput, ShareUncheckedCreateWithoutUserInput>
  }

  export type ShareCreateManyUserInputEnvelope = {
    data: ShareCreateManyUserInput | ShareCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VideoViewCreateWithoutViewerInput = {
    id?: string
    watchTime?: number
    completed?: boolean
    replays?: number
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutViewsInput
  }

  export type VideoViewUncheckedCreateWithoutViewerInput = {
    id?: string
    videoId: string
    watchTime?: number
    completed?: boolean
    replays?: number
    createdAt?: Date | string
  }

  export type VideoViewCreateOrConnectWithoutViewerInput = {
    where: VideoViewWhereUniqueInput
    create: XOR<VideoViewCreateWithoutViewerInput, VideoViewUncheckedCreateWithoutViewerInput>
  }

  export type VideoViewCreateManyViewerInputEnvelope = {
    data: VideoViewCreateManyViewerInput | VideoViewCreateManyViewerInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    type?: string
    attachmentUrl?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    content: string
    type?: string
    attachmentUrl?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutParticipant1Input = {
    id?: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant2: UserCreateNestedOneWithoutConversations2Input
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipant1Input = {
    id?: string
    participant2Id: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipant1Input = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipant1Input, ConversationUncheckedCreateWithoutParticipant1Input>
  }

  export type ConversationCreateManyParticipant1InputEnvelope = {
    data: ConversationCreateManyParticipant1Input | ConversationCreateManyParticipant1Input[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutParticipant2Input = {
    id?: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant1: UserCreateNestedOneWithoutConversations1Input
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipant2Input = {
    id?: string
    participant1Id: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipant2Input = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipant2Input, ConversationUncheckedCreateWithoutParticipant2Input>
  }

  export type ConversationCreateManyParticipant2InputEnvelope = {
    data: ConversationCreateManyParticipant2Input | ConversationCreateManyParticipant2Input[]
    skipDuplicates?: boolean
  }

  export type ExpressInterestCreateWithoutInvestorInput = {
    id?: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: UserCreateNestedOneWithoutReceivedInterestsInput
    video: VideoCreateNestedOneWithoutExpressInterestsInput
  }

  export type ExpressInterestUncheckedCreateWithoutInvestorInput = {
    id?: string
    founderId: string
    videoId: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpressInterestCreateOrConnectWithoutInvestorInput = {
    where: ExpressInterestWhereUniqueInput
    create: XOR<ExpressInterestCreateWithoutInvestorInput, ExpressInterestUncheckedCreateWithoutInvestorInput>
  }

  export type ExpressInterestCreateManyInvestorInputEnvelope = {
    data: ExpressInterestCreateManyInvestorInput | ExpressInterestCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type ExpressInterestCreateWithoutFounderInput = {
    id?: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investor: UserCreateNestedOneWithoutExpressedInterestsInput
    video: VideoCreateNestedOneWithoutExpressInterestsInput
  }

  export type ExpressInterestUncheckedCreateWithoutFounderInput = {
    id?: string
    investorId: string
    videoId: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpressInterestCreateOrConnectWithoutFounderInput = {
    where: ExpressInterestWhereUniqueInput
    create: XOR<ExpressInterestCreateWithoutFounderInput, ExpressInterestUncheckedCreateWithoutFounderInput>
  }

  export type ExpressInterestCreateManyFounderInputEnvelope = {
    data: ExpressInterestCreateManyFounderInput | ExpressInterestCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type ProfileRevealCreateWithoutInvestorInput = {
    id?: string
    revealedAt?: Date | string
    founder: UserCreateNestedOneWithoutProfileRevealsAsFounderInput
  }

  export type ProfileRevealUncheckedCreateWithoutInvestorInput = {
    id?: string
    founderId: string
    revealedAt?: Date | string
  }

  export type ProfileRevealCreateOrConnectWithoutInvestorInput = {
    where: ProfileRevealWhereUniqueInput
    create: XOR<ProfileRevealCreateWithoutInvestorInput, ProfileRevealUncheckedCreateWithoutInvestorInput>
  }

  export type ProfileRevealCreateManyInvestorInputEnvelope = {
    data: ProfileRevealCreateManyInvestorInput | ProfileRevealCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type ProfileRevealCreateWithoutFounderInput = {
    id?: string
    revealedAt?: Date | string
    investor: UserCreateNestedOneWithoutProfileRevealsAsInvestorInput
  }

  export type ProfileRevealUncheckedCreateWithoutFounderInput = {
    id?: string
    investorId: string
    revealedAt?: Date | string
  }

  export type ProfileRevealCreateOrConnectWithoutFounderInput = {
    where: ProfileRevealWhereUniqueInput
    create: XOR<ProfileRevealCreateWithoutFounderInput, ProfileRevealUncheckedCreateWithoutFounderInput>
  }

  export type ProfileRevealCreateManyFounderInputEnvelope = {
    data: ProfileRevealCreateManyFounderInput | ProfileRevealCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    priority?: $Enums.NotificationPriority
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    priority?: $Enums.NotificationPriority
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    type: string
    pushEnabled?: boolean
    emailEnabled?: boolean
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    pushEnabled?: boolean
    emailEnabled?: boolean
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceCreateManyUserInputEnvelope = {
    data: NotificationPreferenceCreateManyUserInput | NotificationPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    stripeSubId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    stripeSubId?: string | null
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type ContentReportCreateWithoutReporterInput = {
    id?: string
    category: $Enums.ReportCategory
    details?: string | null
    status?: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutReportsInput
  }

  export type ContentReportUncheckedCreateWithoutReporterInput = {
    id?: string
    videoId: string
    category: $Enums.ReportCategory
    details?: string | null
    status?: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContentReportCreateOrConnectWithoutReporterInput = {
    where: ContentReportWhereUniqueInput
    create: XOR<ContentReportCreateWithoutReporterInput, ContentReportUncheckedCreateWithoutReporterInput>
  }

  export type ContentReportCreateManyReporterInputEnvelope = {
    data: ContentReportCreateManyReporterInput | ContentReportCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type ModerationActionRecordCreateWithoutUserInput = {
    id?: string
    action: $Enums.ModerationAction
    reason: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModerationActionRecordUncheckedCreateWithoutUserInput = {
    id?: string
    action: $Enums.ModerationAction
    reason: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModerationActionRecordCreateOrConnectWithoutUserInput = {
    where: ModerationActionRecordWhereUniqueInput
    create: XOR<ModerationActionRecordCreateWithoutUserInput, ModerationActionRecordUncheckedCreateWithoutUserInput>
  }

  export type ModerationActionRecordCreateManyUserInputEnvelope = {
    data: ModerationActionRecordCreateManyUserInput | ModerationActionRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    device?: string | null
    ip?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    device?: string | null
    ip?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SearchHistoryCreateWithoutUserInput = {
    id?: string
    query: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SearchHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    query: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SearchHistoryCreateOrConnectWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryCreateManyUserInputEnvelope = {
    data: SearchHistoryCreateManyUserInput | SearchHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OnboardingProgressCreateWithoutUserInput = {
    id?: string
    step?: number
    completed?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingProgressUncheckedCreateWithoutUserInput = {
    id?: string
    step?: number
    completed?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingProgressCreateOrConnectWithoutUserInput = {
    where: OnboardingProgressWhereUniqueInput
    create: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
  }

  export type AccountTypeChangeCreateWithoutUserInput = {
    id?: string
    fromType: $Enums.AccountType
    toType: $Enums.AccountType
    changedAt?: Date | string
  }

  export type AccountTypeChangeUncheckedCreateWithoutUserInput = {
    id?: string
    fromType: $Enums.AccountType
    toType: $Enums.AccountType
    changedAt?: Date | string
  }

  export type AccountTypeChangeCreateOrConnectWithoutUserInput = {
    where: AccountTypeChangeWhereUniqueInput
    create: XOR<AccountTypeChangeCreateWithoutUserInput, AccountTypeChangeUncheckedCreateWithoutUserInput>
  }

  export type AccountTypeChangeCreateManyUserInputEnvelope = {
    data: AccountTypeChangeCreateManyUserInput | AccountTypeChangeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageLimitCreateWithoutUserInput = {
    id?: string
    period: string
    count?: number
    resetsAt: Date | string
    createdAt?: Date | string
  }

  export type MessageLimitUncheckedCreateWithoutUserInput = {
    id?: string
    period: string
    count?: number
    resetsAt: Date | string
    createdAt?: Date | string
  }

  export type MessageLimitCreateOrConnectWithoutUserInput = {
    where: MessageLimitWhereUniqueInput
    create: XOR<MessageLimitCreateWithoutUserInput, MessageLimitUncheckedCreateWithoutUserInput>
  }

  export type MessageLimitCreateManyUserInputEnvelope = {
    data: MessageLimitCreateManyUserInput | MessageLimitCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedPreferenceCreateWithoutUserInput = {
    id?: string
    industries?: FeedPreferenceCreateindustriesInput | string[]
    stages?: FeedPreferenceCreatestagesInput | string[]
    notifyOnMatches?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    industries?: FeedPreferenceCreateindustriesInput | string[]
    stages?: FeedPreferenceCreatestagesInput | string[]
    notifyOnMatches?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedPreferenceCreateOrConnectWithoutUserInput = {
    where: FeedPreferenceWhereUniqueInput
    create: XOR<FeedPreferenceCreateWithoutUserInput, FeedPreferenceUncheckedCreateWithoutUserInput>
  }

  export type BlockCreateWithoutBlockerInput = {
    id?: string
    createdAt?: Date | string
    blocked: UserCreateNestedOneWithoutBlockedByInput
  }

  export type BlockUncheckedCreateWithoutBlockerInput = {
    id?: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockCreateManyBlockerInputEnvelope = {
    data: BlockCreateManyBlockerInput | BlockCreateManyBlockerInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutBlockedInput = {
    id?: string
    createdAt?: Date | string
    blocker: UserCreateNestedOneWithoutBlockedUsersInput
  }

  export type BlockUncheckedCreateWithoutBlockedInput = {
    id?: string
    blockerId: string
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput>
  }

  export type BlockCreateManyBlockedInputEnvelope = {
    data: BlockCreateManyBlockedInput | BlockCreateManyBlockedInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    showInSearch?: BoolFieldUpdateOperationsInput | boolean
    showActivityStatus?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFromEveryone?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: SocialLinkUpdateManyWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    showInSearch?: BoolFieldUpdateOperationsInput | boolean
    showActivityStatus?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFromEveryone?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: SocialLinkUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type FounderProfileUpsertWithoutUserInput = {
    update: XOR<FounderProfileUpdateWithoutUserInput, FounderProfileUncheckedUpdateWithoutUserInput>
    create: XOR<FounderProfileCreateWithoutUserInput, FounderProfileUncheckedCreateWithoutUserInput>
    where?: FounderProfileWhereInput
  }

  export type FounderProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: FounderProfileWhereInput
    data: XOR<FounderProfileUpdateWithoutUserInput, FounderProfileUncheckedUpdateWithoutUserInput>
  }

  export type FounderProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    lookingForFunding?: BoolFieldUpdateOperationsInput | boolean
    lookingForCofounder?: BoolFieldUpdateOperationsInput | boolean
    lookingForFeedback?: BoolFieldUpdateOperationsInput | boolean
    previousVentures?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: FounderProfileUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundraisingDetails?: FundraisingDetailsUpdateOneWithoutFounderProfileNestedInput
  }

  export type FounderProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    lookingForFunding?: BoolFieldUpdateOperationsInput | boolean
    lookingForCofounder?: BoolFieldUpdateOperationsInput | boolean
    lookingForFeedback?: BoolFieldUpdateOperationsInput | boolean
    previousVentures?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: FounderProfileUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fundraisingDetails?: FundraisingDetailsUncheckedUpdateOneWithoutFounderProfileNestedInput
  }

  export type InvestorProfileUpsertWithoutUserInput = {
    update: XOR<InvestorProfileUpdateWithoutUserInput, InvestorProfileUncheckedUpdateWithoutUserInput>
    create: XOR<InvestorProfileCreateWithoutUserInput, InvestorProfileUncheckedCreateWithoutUserInput>
    where?: InvestorProfileWhereInput
  }

  export type InvestorProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: InvestorProfileWhereInput
    data: XOR<InvestorProfileUpdateWithoutUserInput, InvestorProfileUncheckedUpdateWithoutUserInput>
  }

  export type InvestorProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    thesisVideo?: NullableStringFieldUpdateOperationsInput | string | null
    checkSizeMin?: NullableIntFieldUpdateOperationsInput | number | null
    checkSizeMax?: NullableIntFieldUpdateOperationsInput | number | null
    stages?: InvestorProfileUpdatestagesInput | string[]
    industries?: InvestorProfileUpdateindustriesInput | string[]
    geographies?: InvestorProfileUpdategeographiesInput | string[]
    isPublicMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateManyWithoutInvestorProfileNestedInput
  }

  export type InvestorProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    thesisVideo?: NullableStringFieldUpdateOperationsInput | string | null
    checkSizeMin?: NullableIntFieldUpdateOperationsInput | number | null
    checkSizeMax?: NullableIntFieldUpdateOperationsInput | number | null
    stages?: InvestorProfileUpdatestagesInput | string[]
    industries?: InvestorProfileUpdateindustriesInput | string[]
    geographies?: InvestorProfileUpdategeographiesInput | string[]
    isPublicMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUncheckedUpdateManyWithoutInvestorProfileNestedInput
  }

  export type BuilderProfileUpsertWithoutUserInput = {
    update: XOR<BuilderProfileUpdateWithoutUserInput, BuilderProfileUncheckedUpdateWithoutUserInput>
    create: XOR<BuilderProfileCreateWithoutUserInput, BuilderProfileUncheckedCreateWithoutUserInput>
    where?: BuilderProfileWhereInput
  }

  export type BuilderProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: BuilderProfileWhereInput
    data: XOR<BuilderProfileUpdateWithoutUserInput, BuilderProfileUncheckedUpdateWithoutUserInput>
  }

  export type BuilderProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: BuilderProfileUpdateskillsInput | string[]
    portfolioUrls?: BuilderProfileUpdateportfolioUrlsInput | string[]
    availability?: StringFieldUpdateOperationsInput | string
    lookingForProject?: BoolFieldUpdateOperationsInput | boolean
    industryInterests?: BuilderProfileUpdateindustryInterestsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuilderProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: BuilderProfileUpdateskillsInput | string[]
    portfolioUrls?: BuilderProfileUpdateportfolioUrlsInput | string[]
    availability?: StringFieldUpdateOperationsInput | string
    lookingForProject?: BoolFieldUpdateOperationsInput | boolean
    industryInterests?: BuilderProfileUpdateindustryInterestsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorVerificationUpsertWithoutUserInput = {
    update: XOR<InvestorVerificationUpdateWithoutUserInput, InvestorVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<InvestorVerificationCreateWithoutUserInput, InvestorVerificationUncheckedCreateWithoutUserInput>
    where?: InvestorVerificationWhereInput
  }

  export type InvestorVerificationUpdateToOneWithWhereWithoutUserInput = {
    where?: InvestorVerificationWhereInput
    data: XOR<InvestorVerificationUpdateWithoutUserInput, InvestorVerificationUncheckedUpdateWithoutUserInput>
  }

  export type InvestorVerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorVerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    proofDocument?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    reviewerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpsertWithWhereUniqueWithoutUserInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutUserInput, VideoUncheckedUpdateWithoutUserInput>
    create: XOR<VideoCreateWithoutUserInput, VideoUncheckedCreateWithoutUserInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutUserInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutUserInput, VideoUncheckedUpdateWithoutUserInput>
  }

  export type VideoUpdateManyWithWhereWithoutUserInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutUserInput>
  }

  export type VideoScalarWhereInput = {
    AND?: VideoScalarWhereInput | VideoScalarWhereInput[]
    OR?: VideoScalarWhereInput[]
    NOT?: VideoScalarWhereInput | VideoScalarWhereInput[]
    id?: StringFilter<"Video"> | string
    userId?: StringFilter<"Video"> | string
    videoUrl?: StringFilter<"Video"> | string
    thumbnailUrl?: StringNullableFilter<"Video"> | string | null
    type?: EnumVideoTypeFilter<"Video"> | $Enums.VideoType
    visibility?: EnumVideoVisibilityFilter<"Video"> | $Enums.VideoVisibility
    isPinned?: BoolFilter<"Video"> | boolean
    caption?: StringNullableFilter<"Video"> | string | null
    duration?: IntFilter<"Video"> | number
    tags?: StringNullableListFilter<"Video">
    qualityScore?: IntNullableFilter<"Video"> | number | null
    viewCount?: IntFilter<"Video"> | number
    likeCount?: IntFilter<"Video"> | number
    commentCount?: IntFilter<"Video"> | number
    shareCount?: IntFilter<"Video"> | number
    createdAt?: DateTimeFilter<"Video"> | Date | string
    updatedAt?: DateTimeFilter<"Video"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    videoId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    isHidden?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    videoId?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type SaveUpsertWithWhereUniqueWithoutUserInput = {
    where: SaveWhereUniqueInput
    update: XOR<SaveUpdateWithoutUserInput, SaveUncheckedUpdateWithoutUserInput>
    create: XOR<SaveCreateWithoutUserInput, SaveUncheckedCreateWithoutUserInput>
  }

  export type SaveUpdateWithWhereUniqueWithoutUserInput = {
    where: SaveWhereUniqueInput
    data: XOR<SaveUpdateWithoutUserInput, SaveUncheckedUpdateWithoutUserInput>
  }

  export type SaveUpdateManyWithWhereWithoutUserInput = {
    where: SaveScalarWhereInput
    data: XOR<SaveUpdateManyMutationInput, SaveUncheckedUpdateManyWithoutUserInput>
  }

  export type SaveScalarWhereInput = {
    AND?: SaveScalarWhereInput | SaveScalarWhereInput[]
    OR?: SaveScalarWhereInput[]
    NOT?: SaveScalarWhereInput | SaveScalarWhereInput[]
    id?: StringFilter<"Save"> | string
    videoId?: StringFilter<"Save"> | string
    userId?: StringFilter<"Save"> | string
    listId?: StringNullableFilter<"Save"> | string | null
    createdAt?: DateTimeFilter<"Save"> | Date | string
  }

  export type ShareUpsertWithWhereUniqueWithoutUserInput = {
    where: ShareWhereUniqueInput
    update: XOR<ShareUpdateWithoutUserInput, ShareUncheckedUpdateWithoutUserInput>
    create: XOR<ShareCreateWithoutUserInput, ShareUncheckedCreateWithoutUserInput>
  }

  export type ShareUpdateWithWhereUniqueWithoutUserInput = {
    where: ShareWhereUniqueInput
    data: XOR<ShareUpdateWithoutUserInput, ShareUncheckedUpdateWithoutUserInput>
  }

  export type ShareUpdateManyWithWhereWithoutUserInput = {
    where: ShareScalarWhereInput
    data: XOR<ShareUpdateManyMutationInput, ShareUncheckedUpdateManyWithoutUserInput>
  }

  export type ShareScalarWhereInput = {
    AND?: ShareScalarWhereInput | ShareScalarWhereInput[]
    OR?: ShareScalarWhereInput[]
    NOT?: ShareScalarWhereInput | ShareScalarWhereInput[]
    id?: StringFilter<"Share"> | string
    videoId?: StringFilter<"Share"> | string
    userId?: StringFilter<"Share"> | string
    platform?: StringFilter<"Share"> | string
    createdAt?: DateTimeFilter<"Share"> | Date | string
  }

  export type VideoViewUpsertWithWhereUniqueWithoutViewerInput = {
    where: VideoViewWhereUniqueInput
    update: XOR<VideoViewUpdateWithoutViewerInput, VideoViewUncheckedUpdateWithoutViewerInput>
    create: XOR<VideoViewCreateWithoutViewerInput, VideoViewUncheckedCreateWithoutViewerInput>
  }

  export type VideoViewUpdateWithWhereUniqueWithoutViewerInput = {
    where: VideoViewWhereUniqueInput
    data: XOR<VideoViewUpdateWithoutViewerInput, VideoViewUncheckedUpdateWithoutViewerInput>
  }

  export type VideoViewUpdateManyWithWhereWithoutViewerInput = {
    where: VideoViewScalarWhereInput
    data: XOR<VideoViewUpdateManyMutationInput, VideoViewUncheckedUpdateManyWithoutViewerInput>
  }

  export type VideoViewScalarWhereInput = {
    AND?: VideoViewScalarWhereInput | VideoViewScalarWhereInput[]
    OR?: VideoViewScalarWhereInput[]
    NOT?: VideoViewScalarWhereInput | VideoViewScalarWhereInput[]
    id?: StringFilter<"VideoView"> | string
    videoId?: StringFilter<"VideoView"> | string
    viewerId?: StringFilter<"VideoView"> | string
    watchTime?: IntFilter<"VideoView"> | number
    completed?: BoolFilter<"VideoView"> | boolean
    replays?: IntFilter<"VideoView"> | number
    createdAt?: DateTimeFilter<"VideoView"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    attachmentUrl?: StringNullableFilter<"Message"> | string | null
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutParticipant1Input = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutParticipant1Input, ConversationUncheckedUpdateWithoutParticipant1Input>
    create: XOR<ConversationCreateWithoutParticipant1Input, ConversationUncheckedCreateWithoutParticipant1Input>
  }

  export type ConversationUpdateWithWhereUniqueWithoutParticipant1Input = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutParticipant1Input, ConversationUncheckedUpdateWithoutParticipant1Input>
  }

  export type ConversationUpdateManyWithWhereWithoutParticipant1Input = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutParticipant1Input>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    participant1Id?: StringFilter<"Conversation"> | string
    participant2Id?: StringFilter<"Conversation"> | string
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    isRevealed?: BoolFilter<"Conversation"> | boolean
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutParticipant2Input = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutParticipant2Input, ConversationUncheckedUpdateWithoutParticipant2Input>
    create: XOR<ConversationCreateWithoutParticipant2Input, ConversationUncheckedCreateWithoutParticipant2Input>
  }

  export type ConversationUpdateWithWhereUniqueWithoutParticipant2Input = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutParticipant2Input, ConversationUncheckedUpdateWithoutParticipant2Input>
  }

  export type ConversationUpdateManyWithWhereWithoutParticipant2Input = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutParticipant2Input>
  }

  export type ExpressInterestUpsertWithWhereUniqueWithoutInvestorInput = {
    where: ExpressInterestWhereUniqueInput
    update: XOR<ExpressInterestUpdateWithoutInvestorInput, ExpressInterestUncheckedUpdateWithoutInvestorInput>
    create: XOR<ExpressInterestCreateWithoutInvestorInput, ExpressInterestUncheckedCreateWithoutInvestorInput>
  }

  export type ExpressInterestUpdateWithWhereUniqueWithoutInvestorInput = {
    where: ExpressInterestWhereUniqueInput
    data: XOR<ExpressInterestUpdateWithoutInvestorInput, ExpressInterestUncheckedUpdateWithoutInvestorInput>
  }

  export type ExpressInterestUpdateManyWithWhereWithoutInvestorInput = {
    where: ExpressInterestScalarWhereInput
    data: XOR<ExpressInterestUpdateManyMutationInput, ExpressInterestUncheckedUpdateManyWithoutInvestorInput>
  }

  export type ExpressInterestScalarWhereInput = {
    AND?: ExpressInterestScalarWhereInput | ExpressInterestScalarWhereInput[]
    OR?: ExpressInterestScalarWhereInput[]
    NOT?: ExpressInterestScalarWhereInput | ExpressInterestScalarWhereInput[]
    id?: StringFilter<"ExpressInterest"> | string
    investorId?: StringFilter<"ExpressInterest"> | string
    founderId?: StringFilter<"ExpressInterest"> | string
    videoId?: StringFilter<"ExpressInterest"> | string
    status?: StringFilter<"ExpressInterest"> | string
    message?: StringNullableFilter<"ExpressInterest"> | string | null
    createdAt?: DateTimeFilter<"ExpressInterest"> | Date | string
    updatedAt?: DateTimeFilter<"ExpressInterest"> | Date | string
  }

  export type ExpressInterestUpsertWithWhereUniqueWithoutFounderInput = {
    where: ExpressInterestWhereUniqueInput
    update: XOR<ExpressInterestUpdateWithoutFounderInput, ExpressInterestUncheckedUpdateWithoutFounderInput>
    create: XOR<ExpressInterestCreateWithoutFounderInput, ExpressInterestUncheckedCreateWithoutFounderInput>
  }

  export type ExpressInterestUpdateWithWhereUniqueWithoutFounderInput = {
    where: ExpressInterestWhereUniqueInput
    data: XOR<ExpressInterestUpdateWithoutFounderInput, ExpressInterestUncheckedUpdateWithoutFounderInput>
  }

  export type ExpressInterestUpdateManyWithWhereWithoutFounderInput = {
    where: ExpressInterestScalarWhereInput
    data: XOR<ExpressInterestUpdateManyMutationInput, ExpressInterestUncheckedUpdateManyWithoutFounderInput>
  }

  export type ProfileRevealUpsertWithWhereUniqueWithoutInvestorInput = {
    where: ProfileRevealWhereUniqueInput
    update: XOR<ProfileRevealUpdateWithoutInvestorInput, ProfileRevealUncheckedUpdateWithoutInvestorInput>
    create: XOR<ProfileRevealCreateWithoutInvestorInput, ProfileRevealUncheckedCreateWithoutInvestorInput>
  }

  export type ProfileRevealUpdateWithWhereUniqueWithoutInvestorInput = {
    where: ProfileRevealWhereUniqueInput
    data: XOR<ProfileRevealUpdateWithoutInvestorInput, ProfileRevealUncheckedUpdateWithoutInvestorInput>
  }

  export type ProfileRevealUpdateManyWithWhereWithoutInvestorInput = {
    where: ProfileRevealScalarWhereInput
    data: XOR<ProfileRevealUpdateManyMutationInput, ProfileRevealUncheckedUpdateManyWithoutInvestorInput>
  }

  export type ProfileRevealScalarWhereInput = {
    AND?: ProfileRevealScalarWhereInput | ProfileRevealScalarWhereInput[]
    OR?: ProfileRevealScalarWhereInput[]
    NOT?: ProfileRevealScalarWhereInput | ProfileRevealScalarWhereInput[]
    id?: StringFilter<"ProfileReveal"> | string
    investorId?: StringFilter<"ProfileReveal"> | string
    founderId?: StringFilter<"ProfileReveal"> | string
    revealedAt?: DateTimeFilter<"ProfileReveal"> | Date | string
  }

  export type ProfileRevealUpsertWithWhereUniqueWithoutFounderInput = {
    where: ProfileRevealWhereUniqueInput
    update: XOR<ProfileRevealUpdateWithoutFounderInput, ProfileRevealUncheckedUpdateWithoutFounderInput>
    create: XOR<ProfileRevealCreateWithoutFounderInput, ProfileRevealUncheckedCreateWithoutFounderInput>
  }

  export type ProfileRevealUpdateWithWhereUniqueWithoutFounderInput = {
    where: ProfileRevealWhereUniqueInput
    data: XOR<ProfileRevealUpdateWithoutFounderInput, ProfileRevealUncheckedUpdateWithoutFounderInput>
  }

  export type ProfileRevealUpdateManyWithWhereWithoutFounderInput = {
    where: ProfileRevealScalarWhereInput
    data: XOR<ProfileRevealUpdateManyMutationInput, ProfileRevealUncheckedUpdateManyWithoutFounderInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: NotificationPreferenceScalarWhereInput
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationPreferenceScalarWhereInput = {
    AND?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    OR?: NotificationPreferenceScalarWhereInput[]
    NOT?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    type?: StringFilter<"NotificationPreference"> | string
    pushEnabled?: BoolFilter<"NotificationPreference"> | boolean
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
  }

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: ContentReportWhereUniqueInput
    update: XOR<ContentReportUpdateWithoutReporterInput, ContentReportUncheckedUpdateWithoutReporterInput>
    create: XOR<ContentReportCreateWithoutReporterInput, ContentReportUncheckedCreateWithoutReporterInput>
  }

  export type ContentReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: ContentReportWhereUniqueInput
    data: XOR<ContentReportUpdateWithoutReporterInput, ContentReportUncheckedUpdateWithoutReporterInput>
  }

  export type ContentReportUpdateManyWithWhereWithoutReporterInput = {
    where: ContentReportScalarWhereInput
    data: XOR<ContentReportUpdateManyMutationInput, ContentReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type ContentReportScalarWhereInput = {
    AND?: ContentReportScalarWhereInput | ContentReportScalarWhereInput[]
    OR?: ContentReportScalarWhereInput[]
    NOT?: ContentReportScalarWhereInput | ContentReportScalarWhereInput[]
    id?: StringFilter<"ContentReport"> | string
    reporterId?: StringFilter<"ContentReport"> | string
    videoId?: StringFilter<"ContentReport"> | string
    category?: EnumReportCategoryFilter<"ContentReport"> | $Enums.ReportCategory
    details?: StringNullableFilter<"ContentReport"> | string | null
    status?: StringFilter<"ContentReport"> | string
    reviewedAt?: DateTimeNullableFilter<"ContentReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentReport"> | Date | string
  }

  export type ModerationActionRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: ModerationActionRecordWhereUniqueInput
    update: XOR<ModerationActionRecordUpdateWithoutUserInput, ModerationActionRecordUncheckedUpdateWithoutUserInput>
    create: XOR<ModerationActionRecordCreateWithoutUserInput, ModerationActionRecordUncheckedCreateWithoutUserInput>
  }

  export type ModerationActionRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: ModerationActionRecordWhereUniqueInput
    data: XOR<ModerationActionRecordUpdateWithoutUserInput, ModerationActionRecordUncheckedUpdateWithoutUserInput>
  }

  export type ModerationActionRecordUpdateManyWithWhereWithoutUserInput = {
    where: ModerationActionRecordScalarWhereInput
    data: XOR<ModerationActionRecordUpdateManyMutationInput, ModerationActionRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type ModerationActionRecordScalarWhereInput = {
    AND?: ModerationActionRecordScalarWhereInput | ModerationActionRecordScalarWhereInput[]
    OR?: ModerationActionRecordScalarWhereInput[]
    NOT?: ModerationActionRecordScalarWhereInput | ModerationActionRecordScalarWhereInput[]
    id?: StringFilter<"ModerationActionRecord"> | string
    userId?: StringFilter<"ModerationActionRecord"> | string
    action?: EnumModerationActionFilter<"ModerationActionRecord"> | $Enums.ModerationAction
    reason?: StringFilter<"ModerationActionRecord"> | string
    expiresAt?: DateTimeNullableFilter<"ModerationActionRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ModerationActionRecord"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    device?: StringNullableFilter<"Session"> | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type SearchHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    update: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    data: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
  }

  export type SearchHistoryUpdateManyWithWhereWithoutUserInput = {
    where: SearchHistoryScalarWhereInput
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchHistoryScalarWhereInput = {
    AND?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    OR?: SearchHistoryScalarWhereInput[]
    NOT?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    userId?: StringFilter<"SearchHistory"> | string
    query?: StringFilter<"SearchHistory"> | string
    filters?: JsonNullableFilter<"SearchHistory">
    createdAt?: DateTimeFilter<"SearchHistory"> | Date | string
  }

  export type OnboardingProgressUpsertWithoutUserInput = {
    update: XOR<OnboardingProgressUpdateWithoutUserInput, OnboardingProgressUncheckedUpdateWithoutUserInput>
    create: XOR<OnboardingProgressCreateWithoutUserInput, OnboardingProgressUncheckedCreateWithoutUserInput>
    where?: OnboardingProgressWhereInput
  }

  export type OnboardingProgressUpdateToOneWithWhereWithoutUserInput = {
    where?: OnboardingProgressWhereInput
    data: XOR<OnboardingProgressUpdateWithoutUserInput, OnboardingProgressUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountTypeChangeUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountTypeChangeWhereUniqueInput
    update: XOR<AccountTypeChangeUpdateWithoutUserInput, AccountTypeChangeUncheckedUpdateWithoutUserInput>
    create: XOR<AccountTypeChangeCreateWithoutUserInput, AccountTypeChangeUncheckedCreateWithoutUserInput>
  }

  export type AccountTypeChangeUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountTypeChangeWhereUniqueInput
    data: XOR<AccountTypeChangeUpdateWithoutUserInput, AccountTypeChangeUncheckedUpdateWithoutUserInput>
  }

  export type AccountTypeChangeUpdateManyWithWhereWithoutUserInput = {
    where: AccountTypeChangeScalarWhereInput
    data: XOR<AccountTypeChangeUpdateManyMutationInput, AccountTypeChangeUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountTypeChangeScalarWhereInput = {
    AND?: AccountTypeChangeScalarWhereInput | AccountTypeChangeScalarWhereInput[]
    OR?: AccountTypeChangeScalarWhereInput[]
    NOT?: AccountTypeChangeScalarWhereInput | AccountTypeChangeScalarWhereInput[]
    id?: StringFilter<"AccountTypeChange"> | string
    userId?: StringFilter<"AccountTypeChange"> | string
    fromType?: EnumAccountTypeFilter<"AccountTypeChange"> | $Enums.AccountType
    toType?: EnumAccountTypeFilter<"AccountTypeChange"> | $Enums.AccountType
    changedAt?: DateTimeFilter<"AccountTypeChange"> | Date | string
  }

  export type MessageLimitUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageLimitWhereUniqueInput
    update: XOR<MessageLimitUpdateWithoutUserInput, MessageLimitUncheckedUpdateWithoutUserInput>
    create: XOR<MessageLimitCreateWithoutUserInput, MessageLimitUncheckedCreateWithoutUserInput>
  }

  export type MessageLimitUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageLimitWhereUniqueInput
    data: XOR<MessageLimitUpdateWithoutUserInput, MessageLimitUncheckedUpdateWithoutUserInput>
  }

  export type MessageLimitUpdateManyWithWhereWithoutUserInput = {
    where: MessageLimitScalarWhereInput
    data: XOR<MessageLimitUpdateManyMutationInput, MessageLimitUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageLimitScalarWhereInput = {
    AND?: MessageLimitScalarWhereInput | MessageLimitScalarWhereInput[]
    OR?: MessageLimitScalarWhereInput[]
    NOT?: MessageLimitScalarWhereInput | MessageLimitScalarWhereInput[]
    id?: StringFilter<"MessageLimit"> | string
    userId?: StringFilter<"MessageLimit"> | string
    period?: StringFilter<"MessageLimit"> | string
    count?: IntFilter<"MessageLimit"> | number
    resetsAt?: DateTimeFilter<"MessageLimit"> | Date | string
    createdAt?: DateTimeFilter<"MessageLimit"> | Date | string
  }

  export type FeedPreferenceUpsertWithoutUserInput = {
    update: XOR<FeedPreferenceUpdateWithoutUserInput, FeedPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<FeedPreferenceCreateWithoutUserInput, FeedPreferenceUncheckedCreateWithoutUserInput>
    where?: FeedPreferenceWhereInput
  }

  export type FeedPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: FeedPreferenceWhereInput
    data: XOR<FeedPreferenceUpdateWithoutUserInput, FeedPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type FeedPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    industries?: FeedPreferenceUpdateindustriesInput | string[]
    stages?: FeedPreferenceUpdatestagesInput | string[]
    notifyOnMatches?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    industries?: FeedPreferenceUpdateindustriesInput | string[]
    stages?: FeedPreferenceUpdatestagesInput | string[]
    notifyOnMatches?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockerInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockerInput>
  }

  export type BlockScalarWhereInput = {
    AND?: BlockScalarWhereInput | BlockScalarWhereInput[]
    OR?: BlockScalarWhereInput[]
    NOT?: BlockScalarWhereInput | BlockScalarWhereInput[]
    id?: StringFilter<"Block"> | string
    blockerId?: StringFilter<"Block"> | string
    blockedId?: StringFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockedInput, BlockUncheckedUpdateWithoutBlockedInput>
    create: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockedInput, BlockUncheckedUpdateWithoutBlockedInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockedInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockedInput>
  }

  export type UserCreateWithoutBlockedUsersInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutBlockedUsersInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutBlockedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
  }

  export type UserCreateWithoutBlockedByInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
  }

  export type UserUncheckedCreateWithoutBlockedByInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
  }

  export type UserCreateOrConnectWithoutBlockedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
  }

  export type UserUpsertWithoutBlockedUsersInput = {
    update: XOR<UserUpdateWithoutBlockedUsersInput, UserUncheckedUpdateWithoutBlockedUsersInput>
    create: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedUsersInput, UserUncheckedUpdateWithoutBlockedUsersInput>
  }

  export type UserUpdateWithoutBlockedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserUpsertWithoutBlockedByInput = {
    update: XOR<UserUpdateWithoutBlockedByInput, UserUncheckedUpdateWithoutBlockedByInput>
    create: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedByInput, UserUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type SocialLinkCreateWithoutProfileInput = {
    id?: string
    platform: string
    url: string
  }

  export type SocialLinkUncheckedCreateWithoutProfileInput = {
    id?: string
    platform: string
    url: string
  }

  export type SocialLinkCreateOrConnectWithoutProfileInput = {
    where: SocialLinkWhereUniqueInput
    create: XOR<SocialLinkCreateWithoutProfileInput, SocialLinkUncheckedCreateWithoutProfileInput>
  }

  export type SocialLinkCreateManyProfileInputEnvelope = {
    data: SocialLinkCreateManyProfileInput | SocialLinkCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type SocialLinkUpsertWithWhereUniqueWithoutProfileInput = {
    where: SocialLinkWhereUniqueInput
    update: XOR<SocialLinkUpdateWithoutProfileInput, SocialLinkUncheckedUpdateWithoutProfileInput>
    create: XOR<SocialLinkCreateWithoutProfileInput, SocialLinkUncheckedCreateWithoutProfileInput>
  }

  export type SocialLinkUpdateWithWhereUniqueWithoutProfileInput = {
    where: SocialLinkWhereUniqueInput
    data: XOR<SocialLinkUpdateWithoutProfileInput, SocialLinkUncheckedUpdateWithoutProfileInput>
  }

  export type SocialLinkUpdateManyWithWhereWithoutProfileInput = {
    where: SocialLinkScalarWhereInput
    data: XOR<SocialLinkUpdateManyMutationInput, SocialLinkUncheckedUpdateManyWithoutProfileInput>
  }

  export type SocialLinkScalarWhereInput = {
    AND?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
    OR?: SocialLinkScalarWhereInput[]
    NOT?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
    id?: StringFilter<"SocialLink"> | string
    profileId?: StringFilter<"SocialLink"> | string
    platform?: StringFilter<"SocialLink"> | string
    url?: StringFilter<"SocialLink"> | string
  }

  export type UserProfileCreateWithoutSocialLinksInput = {
    id?: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutSocialLinksInput = {
    id?: string
    userId: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    isPublic?: boolean
    showInSearch?: boolean
    showActivityStatus?: boolean
    allowMessagesFromEveryone?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileCreateOrConnectWithoutSocialLinksInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutSocialLinksInput, UserProfileUncheckedCreateWithoutSocialLinksInput>
  }

  export type UserProfileUpsertWithoutSocialLinksInput = {
    update: XOR<UserProfileUpdateWithoutSocialLinksInput, UserProfileUncheckedUpdateWithoutSocialLinksInput>
    create: XOR<UserProfileCreateWithoutSocialLinksInput, UserProfileUncheckedCreateWithoutSocialLinksInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutSocialLinksInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutSocialLinksInput, UserProfileUncheckedUpdateWithoutSocialLinksInput>
  }

  export type UserProfileUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    showInSearch?: BoolFieldUpdateOperationsInput | boolean
    showActivityStatus?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFromEveryone?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutSocialLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    showInSearch?: BoolFieldUpdateOperationsInput | boolean
    showActivityStatus?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFromEveryone?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutFounderProfileInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutFounderProfileInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutFounderProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFounderProfileInput, UserUncheckedCreateWithoutFounderProfileInput>
  }

  export type FundraisingDetailsCreateWithoutFounderProfileInput = {
    id?: string
    stage: string
    amount?: number | null
    industry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundraisingDetailsUncheckedCreateWithoutFounderProfileInput = {
    id?: string
    stage: string
    amount?: number | null
    industry?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundraisingDetailsCreateOrConnectWithoutFounderProfileInput = {
    where: FundraisingDetailsWhereUniqueInput
    create: XOR<FundraisingDetailsCreateWithoutFounderProfileInput, FundraisingDetailsUncheckedCreateWithoutFounderProfileInput>
  }

  export type UserUpsertWithoutFounderProfileInput = {
    update: XOR<UserUpdateWithoutFounderProfileInput, UserUncheckedUpdateWithoutFounderProfileInput>
    create: XOR<UserCreateWithoutFounderProfileInput, UserUncheckedCreateWithoutFounderProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFounderProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFounderProfileInput, UserUncheckedUpdateWithoutFounderProfileInput>
  }

  export type UserUpdateWithoutFounderProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutFounderProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type FundraisingDetailsUpsertWithoutFounderProfileInput = {
    update: XOR<FundraisingDetailsUpdateWithoutFounderProfileInput, FundraisingDetailsUncheckedUpdateWithoutFounderProfileInput>
    create: XOR<FundraisingDetailsCreateWithoutFounderProfileInput, FundraisingDetailsUncheckedCreateWithoutFounderProfileInput>
    where?: FundraisingDetailsWhereInput
  }

  export type FundraisingDetailsUpdateToOneWithWhereWithoutFounderProfileInput = {
    where?: FundraisingDetailsWhereInput
    data: XOR<FundraisingDetailsUpdateWithoutFounderProfileInput, FundraisingDetailsUncheckedUpdateWithoutFounderProfileInput>
  }

  export type FundraisingDetailsUpdateWithoutFounderProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundraisingDetailsUncheckedUpdateWithoutFounderProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FounderProfileCreateWithoutFundraisingDetailsInput = {
    id?: string
    tagline?: string | null
    companyName?: string | null
    industry?: string | null
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: string | null
    education?: string | null
    skills?: FounderProfileCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFounderProfileInput
  }

  export type FounderProfileUncheckedCreateWithoutFundraisingDetailsInput = {
    id?: string
    userId: string
    tagline?: string | null
    companyName?: string | null
    industry?: string | null
    lookingForFunding?: boolean
    lookingForCofounder?: boolean
    lookingForFeedback?: boolean
    previousVentures?: string | null
    education?: string | null
    skills?: FounderProfileCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FounderProfileCreateOrConnectWithoutFundraisingDetailsInput = {
    where: FounderProfileWhereUniqueInput
    create: XOR<FounderProfileCreateWithoutFundraisingDetailsInput, FounderProfileUncheckedCreateWithoutFundraisingDetailsInput>
  }

  export type FounderProfileUpsertWithoutFundraisingDetailsInput = {
    update: XOR<FounderProfileUpdateWithoutFundraisingDetailsInput, FounderProfileUncheckedUpdateWithoutFundraisingDetailsInput>
    create: XOR<FounderProfileCreateWithoutFundraisingDetailsInput, FounderProfileUncheckedCreateWithoutFundraisingDetailsInput>
    where?: FounderProfileWhereInput
  }

  export type FounderProfileUpdateToOneWithWhereWithoutFundraisingDetailsInput = {
    where?: FounderProfileWhereInput
    data: XOR<FounderProfileUpdateWithoutFundraisingDetailsInput, FounderProfileUncheckedUpdateWithoutFundraisingDetailsInput>
  }

  export type FounderProfileUpdateWithoutFundraisingDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    lookingForFunding?: BoolFieldUpdateOperationsInput | boolean
    lookingForCofounder?: BoolFieldUpdateOperationsInput | boolean
    lookingForFeedback?: BoolFieldUpdateOperationsInput | boolean
    previousVentures?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: FounderProfileUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFounderProfileNestedInput
  }

  export type FounderProfileUncheckedUpdateWithoutFundraisingDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    lookingForFunding?: BoolFieldUpdateOperationsInput | boolean
    lookingForCofounder?: BoolFieldUpdateOperationsInput | boolean
    lookingForFeedback?: BoolFieldUpdateOperationsInput | boolean
    previousVentures?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: FounderProfileUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutInvestorProfileInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutInvestorProfileInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutInvestorProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestorProfileInput, UserUncheckedCreateWithoutInvestorProfileInput>
  }

  export type PortfolioCreateWithoutInvestorProfileInput = {
    id?: string
    companyName: string
    companyUrl?: string | null
    investmentYear?: number | null
  }

  export type PortfolioUncheckedCreateWithoutInvestorProfileInput = {
    id?: string
    companyName: string
    companyUrl?: string | null
    investmentYear?: number | null
  }

  export type PortfolioCreateOrConnectWithoutInvestorProfileInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutInvestorProfileInput, PortfolioUncheckedCreateWithoutInvestorProfileInput>
  }

  export type PortfolioCreateManyInvestorProfileInputEnvelope = {
    data: PortfolioCreateManyInvestorProfileInput | PortfolioCreateManyInvestorProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvestorProfileInput = {
    update: XOR<UserUpdateWithoutInvestorProfileInput, UserUncheckedUpdateWithoutInvestorProfileInput>
    create: XOR<UserCreateWithoutInvestorProfileInput, UserUncheckedCreateWithoutInvestorProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestorProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestorProfileInput, UserUncheckedUpdateWithoutInvestorProfileInput>
  }

  export type UserUpdateWithoutInvestorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type PortfolioUpsertWithWhereUniqueWithoutInvestorProfileInput = {
    where: PortfolioWhereUniqueInput
    update: XOR<PortfolioUpdateWithoutInvestorProfileInput, PortfolioUncheckedUpdateWithoutInvestorProfileInput>
    create: XOR<PortfolioCreateWithoutInvestorProfileInput, PortfolioUncheckedCreateWithoutInvestorProfileInput>
  }

  export type PortfolioUpdateWithWhereUniqueWithoutInvestorProfileInput = {
    where: PortfolioWhereUniqueInput
    data: XOR<PortfolioUpdateWithoutInvestorProfileInput, PortfolioUncheckedUpdateWithoutInvestorProfileInput>
  }

  export type PortfolioUpdateManyWithWhereWithoutInvestorProfileInput = {
    where: PortfolioScalarWhereInput
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyWithoutInvestorProfileInput>
  }

  export type PortfolioScalarWhereInput = {
    AND?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    OR?: PortfolioScalarWhereInput[]
    NOT?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    id?: StringFilter<"Portfolio"> | string
    investorProfileId?: StringFilter<"Portfolio"> | string
    companyName?: StringFilter<"Portfolio"> | string
    companyUrl?: StringNullableFilter<"Portfolio"> | string | null
    investmentYear?: IntNullableFilter<"Portfolio"> | number | null
  }

  export type InvestorProfileCreateWithoutPortfolioInput = {
    id?: string
    firm?: string | null
    title?: string | null
    thesis?: string | null
    thesisVideo?: string | null
    checkSizeMin?: number | null
    checkSizeMax?: number | null
    stages?: InvestorProfileCreatestagesInput | string[]
    industries?: InvestorProfileCreateindustriesInput | string[]
    geographies?: InvestorProfileCreategeographiesInput | string[]
    isPublicMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestorProfileInput
  }

  export type InvestorProfileUncheckedCreateWithoutPortfolioInput = {
    id?: string
    userId: string
    firm?: string | null
    title?: string | null
    thesis?: string | null
    thesisVideo?: string | null
    checkSizeMin?: number | null
    checkSizeMax?: number | null
    stages?: InvestorProfileCreatestagesInput | string[]
    industries?: InvestorProfileCreateindustriesInput | string[]
    geographies?: InvestorProfileCreategeographiesInput | string[]
    isPublicMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorProfileCreateOrConnectWithoutPortfolioInput = {
    where: InvestorProfileWhereUniqueInput
    create: XOR<InvestorProfileCreateWithoutPortfolioInput, InvestorProfileUncheckedCreateWithoutPortfolioInput>
  }

  export type InvestorProfileUpsertWithoutPortfolioInput = {
    update: XOR<InvestorProfileUpdateWithoutPortfolioInput, InvestorProfileUncheckedUpdateWithoutPortfolioInput>
    create: XOR<InvestorProfileCreateWithoutPortfolioInput, InvestorProfileUncheckedCreateWithoutPortfolioInput>
    where?: InvestorProfileWhereInput
  }

  export type InvestorProfileUpdateToOneWithWhereWithoutPortfolioInput = {
    where?: InvestorProfileWhereInput
    data: XOR<InvestorProfileUpdateWithoutPortfolioInput, InvestorProfileUncheckedUpdateWithoutPortfolioInput>
  }

  export type InvestorProfileUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    thesisVideo?: NullableStringFieldUpdateOperationsInput | string | null
    checkSizeMin?: NullableIntFieldUpdateOperationsInput | number | null
    checkSizeMax?: NullableIntFieldUpdateOperationsInput | number | null
    stages?: InvestorProfileUpdatestagesInput | string[]
    industries?: InvestorProfileUpdateindustriesInput | string[]
    geographies?: InvestorProfileUpdategeographiesInput | string[]
    isPublicMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestorProfileNestedInput
  }

  export type InvestorProfileUncheckedUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    thesis?: NullableStringFieldUpdateOperationsInput | string | null
    thesisVideo?: NullableStringFieldUpdateOperationsInput | string | null
    checkSizeMin?: NullableIntFieldUpdateOperationsInput | number | null
    checkSizeMax?: NullableIntFieldUpdateOperationsInput | number | null
    stages?: InvestorProfileUpdatestagesInput | string[]
    industries?: InvestorProfileUpdateindustriesInput | string[]
    geographies?: InvestorProfileUpdategeographiesInput | string[]
    isPublicMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutBuilderProfileInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutBuilderProfileInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutBuilderProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuilderProfileInput, UserUncheckedCreateWithoutBuilderProfileInput>
  }

  export type UserUpsertWithoutBuilderProfileInput = {
    update: XOR<UserUpdateWithoutBuilderProfileInput, UserUncheckedUpdateWithoutBuilderProfileInput>
    create: XOR<UserCreateWithoutBuilderProfileInput, UserUncheckedCreateWithoutBuilderProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuilderProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuilderProfileInput, UserUncheckedUpdateWithoutBuilderProfileInput>
  }

  export type UserUpdateWithoutBuilderProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutBuilderProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutInvestorVerificationInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutInvestorVerificationInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutInvestorVerificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestorVerificationInput, UserUncheckedCreateWithoutInvestorVerificationInput>
  }

  export type UserUpsertWithoutInvestorVerificationInput = {
    update: XOR<UserUpdateWithoutInvestorVerificationInput, UserUncheckedUpdateWithoutInvestorVerificationInput>
    create: XOR<UserCreateWithoutInvestorVerificationInput, UserUncheckedCreateWithoutInvestorVerificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestorVerificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestorVerificationInput, UserUncheckedUpdateWithoutInvestorVerificationInput>
  }

  export type UserUpdateWithoutInvestorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutVideosInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutVideosInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutVideosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
  }

  export type VideoTranscriptCreateWithoutVideoInput = {
    id?: string
    text: string
    createdAt?: Date | string
  }

  export type VideoTranscriptUncheckedCreateWithoutVideoInput = {
    id?: string
    text: string
    createdAt?: Date | string
  }

  export type VideoTranscriptCreateOrConnectWithoutVideoInput = {
    where: VideoTranscriptWhereUniqueInput
    create: XOR<VideoTranscriptCreateWithoutVideoInput, VideoTranscriptUncheckedCreateWithoutVideoInput>
  }

  export type VideoAnalyticsCreateWithoutVideoInput = {
    id?: string
    totalViews?: number
    uniqueViews?: number
    investorViews?: number
    founderViews?: number
    builderViews?: number
    averageWatchTime?: number
    completionRate?: number
    replayRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoAnalyticsUncheckedCreateWithoutVideoInput = {
    id?: string
    totalViews?: number
    uniqueViews?: number
    investorViews?: number
    founderViews?: number
    builderViews?: number
    averageWatchTime?: number
    completionRate?: number
    replayRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoAnalyticsCreateOrConnectWithoutVideoInput = {
    where: VideoAnalyticsWhereUniqueInput
    create: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
  }

  export type CommentCreateWithoutVideoInput = {
    id?: string
    content: string
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutVideoInput = {
    id?: string
    userId: string
    content: string
    parentId?: string | null
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutVideoInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput>
  }

  export type CommentCreateManyVideoInputEnvelope = {
    data: CommentCreateManyVideoInput | CommentCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutVideoInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutVideoInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutVideoInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutVideoInput, LikeUncheckedCreateWithoutVideoInput>
  }

  export type LikeCreateManyVideoInputEnvelope = {
    data: LikeCreateManyVideoInput | LikeCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type SaveCreateWithoutVideoInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSavesInput
    list?: SaveListCreateNestedOneWithoutSavesInput
  }

  export type SaveUncheckedCreateWithoutVideoInput = {
    id?: string
    userId: string
    listId?: string | null
    createdAt?: Date | string
  }

  export type SaveCreateOrConnectWithoutVideoInput = {
    where: SaveWhereUniqueInput
    create: XOR<SaveCreateWithoutVideoInput, SaveUncheckedCreateWithoutVideoInput>
  }

  export type SaveCreateManyVideoInputEnvelope = {
    data: SaveCreateManyVideoInput | SaveCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type ShareCreateWithoutVideoInput = {
    id?: string
    platform: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSharesInput
  }

  export type ShareUncheckedCreateWithoutVideoInput = {
    id?: string
    userId: string
    platform: string
    createdAt?: Date | string
  }

  export type ShareCreateOrConnectWithoutVideoInput = {
    where: ShareWhereUniqueInput
    create: XOR<ShareCreateWithoutVideoInput, ShareUncheckedCreateWithoutVideoInput>
  }

  export type ShareCreateManyVideoInputEnvelope = {
    data: ShareCreateManyVideoInput | ShareCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type VideoViewCreateWithoutVideoInput = {
    id?: string
    watchTime?: number
    completed?: boolean
    replays?: number
    createdAt?: Date | string
    viewer: UserCreateNestedOneWithoutVideoViewsInput
  }

  export type VideoViewUncheckedCreateWithoutVideoInput = {
    id?: string
    viewerId: string
    watchTime?: number
    completed?: boolean
    replays?: number
    createdAt?: Date | string
  }

  export type VideoViewCreateOrConnectWithoutVideoInput = {
    where: VideoViewWhereUniqueInput
    create: XOR<VideoViewCreateWithoutVideoInput, VideoViewUncheckedCreateWithoutVideoInput>
  }

  export type VideoViewCreateManyVideoInputEnvelope = {
    data: VideoViewCreateManyVideoInput | VideoViewCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type ContentReportCreateWithoutVideoInput = {
    id?: string
    category: $Enums.ReportCategory
    details?: string | null
    status?: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutContentReportsInput
  }

  export type ContentReportUncheckedCreateWithoutVideoInput = {
    id?: string
    reporterId: string
    category: $Enums.ReportCategory
    details?: string | null
    status?: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ContentReportCreateOrConnectWithoutVideoInput = {
    where: ContentReportWhereUniqueInput
    create: XOR<ContentReportCreateWithoutVideoInput, ContentReportUncheckedCreateWithoutVideoInput>
  }

  export type ContentReportCreateManyVideoInputEnvelope = {
    data: ContentReportCreateManyVideoInput | ContentReportCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type ExpressInterestCreateWithoutVideoInput = {
    id?: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    investor: UserCreateNestedOneWithoutExpressedInterestsInput
    founder: UserCreateNestedOneWithoutReceivedInterestsInput
  }

  export type ExpressInterestUncheckedCreateWithoutVideoInput = {
    id?: string
    investorId: string
    founderId: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpressInterestCreateOrConnectWithoutVideoInput = {
    where: ExpressInterestWhereUniqueInput
    create: XOR<ExpressInterestCreateWithoutVideoInput, ExpressInterestUncheckedCreateWithoutVideoInput>
  }

  export type ExpressInterestCreateManyVideoInputEnvelope = {
    data: ExpressInterestCreateManyVideoInput | ExpressInterestCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVideosInput = {
    update: XOR<UserUpdateWithoutVideosInput, UserUncheckedUpdateWithoutVideosInput>
    create: XOR<UserCreateWithoutVideosInput, UserUncheckedCreateWithoutVideosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVideosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVideosInput, UserUncheckedUpdateWithoutVideosInput>
  }

  export type UserUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type VideoTranscriptUpsertWithoutVideoInput = {
    update: XOR<VideoTranscriptUpdateWithoutVideoInput, VideoTranscriptUncheckedUpdateWithoutVideoInput>
    create: XOR<VideoTranscriptCreateWithoutVideoInput, VideoTranscriptUncheckedCreateWithoutVideoInput>
    where?: VideoTranscriptWhereInput
  }

  export type VideoTranscriptUpdateToOneWithWhereWithoutVideoInput = {
    where?: VideoTranscriptWhereInput
    data: XOR<VideoTranscriptUpdateWithoutVideoInput, VideoTranscriptUncheckedUpdateWithoutVideoInput>
  }

  export type VideoTranscriptUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoTranscriptUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoAnalyticsUpsertWithoutVideoInput = {
    update: XOR<VideoAnalyticsUpdateWithoutVideoInput, VideoAnalyticsUncheckedUpdateWithoutVideoInput>
    create: XOR<VideoAnalyticsCreateWithoutVideoInput, VideoAnalyticsUncheckedCreateWithoutVideoInput>
    where?: VideoAnalyticsWhereInput
  }

  export type VideoAnalyticsUpdateToOneWithWhereWithoutVideoInput = {
    where?: VideoAnalyticsWhereInput
    data: XOR<VideoAnalyticsUpdateWithoutVideoInput, VideoAnalyticsUncheckedUpdateWithoutVideoInput>
  }

  export type VideoAnalyticsUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    investorViews?: IntFieldUpdateOperationsInput | number
    founderViews?: IntFieldUpdateOperationsInput | number
    builderViews?: IntFieldUpdateOperationsInput | number
    averageWatchTime?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    replayRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoAnalyticsUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueViews?: IntFieldUpdateOperationsInput | number
    investorViews?: IntFieldUpdateOperationsInput | number
    founderViews?: IntFieldUpdateOperationsInput | number
    builderViews?: IntFieldUpdateOperationsInput | number
    averageWatchTime?: FloatFieldUpdateOperationsInput | number
    completionRate?: FloatFieldUpdateOperationsInput | number
    replayRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutVideoInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutVideoInput, CommentUncheckedUpdateWithoutVideoInput>
    create: XOR<CommentCreateWithoutVideoInput, CommentUncheckedCreateWithoutVideoInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutVideoInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutVideoInput, CommentUncheckedUpdateWithoutVideoInput>
  }

  export type CommentUpdateManyWithWhereWithoutVideoInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutVideoInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutVideoInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutVideoInput, LikeUncheckedUpdateWithoutVideoInput>
    create: XOR<LikeCreateWithoutVideoInput, LikeUncheckedCreateWithoutVideoInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutVideoInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutVideoInput, LikeUncheckedUpdateWithoutVideoInput>
  }

  export type LikeUpdateManyWithWhereWithoutVideoInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutVideoInput>
  }

  export type SaveUpsertWithWhereUniqueWithoutVideoInput = {
    where: SaveWhereUniqueInput
    update: XOR<SaveUpdateWithoutVideoInput, SaveUncheckedUpdateWithoutVideoInput>
    create: XOR<SaveCreateWithoutVideoInput, SaveUncheckedCreateWithoutVideoInput>
  }

  export type SaveUpdateWithWhereUniqueWithoutVideoInput = {
    where: SaveWhereUniqueInput
    data: XOR<SaveUpdateWithoutVideoInput, SaveUncheckedUpdateWithoutVideoInput>
  }

  export type SaveUpdateManyWithWhereWithoutVideoInput = {
    where: SaveScalarWhereInput
    data: XOR<SaveUpdateManyMutationInput, SaveUncheckedUpdateManyWithoutVideoInput>
  }

  export type ShareUpsertWithWhereUniqueWithoutVideoInput = {
    where: ShareWhereUniqueInput
    update: XOR<ShareUpdateWithoutVideoInput, ShareUncheckedUpdateWithoutVideoInput>
    create: XOR<ShareCreateWithoutVideoInput, ShareUncheckedCreateWithoutVideoInput>
  }

  export type ShareUpdateWithWhereUniqueWithoutVideoInput = {
    where: ShareWhereUniqueInput
    data: XOR<ShareUpdateWithoutVideoInput, ShareUncheckedUpdateWithoutVideoInput>
  }

  export type ShareUpdateManyWithWhereWithoutVideoInput = {
    where: ShareScalarWhereInput
    data: XOR<ShareUpdateManyMutationInput, ShareUncheckedUpdateManyWithoutVideoInput>
  }

  export type VideoViewUpsertWithWhereUniqueWithoutVideoInput = {
    where: VideoViewWhereUniqueInput
    update: XOR<VideoViewUpdateWithoutVideoInput, VideoViewUncheckedUpdateWithoutVideoInput>
    create: XOR<VideoViewCreateWithoutVideoInput, VideoViewUncheckedCreateWithoutVideoInput>
  }

  export type VideoViewUpdateWithWhereUniqueWithoutVideoInput = {
    where: VideoViewWhereUniqueInput
    data: XOR<VideoViewUpdateWithoutVideoInput, VideoViewUncheckedUpdateWithoutVideoInput>
  }

  export type VideoViewUpdateManyWithWhereWithoutVideoInput = {
    where: VideoViewScalarWhereInput
    data: XOR<VideoViewUpdateManyMutationInput, VideoViewUncheckedUpdateManyWithoutVideoInput>
  }

  export type ContentReportUpsertWithWhereUniqueWithoutVideoInput = {
    where: ContentReportWhereUniqueInput
    update: XOR<ContentReportUpdateWithoutVideoInput, ContentReportUncheckedUpdateWithoutVideoInput>
    create: XOR<ContentReportCreateWithoutVideoInput, ContentReportUncheckedCreateWithoutVideoInput>
  }

  export type ContentReportUpdateWithWhereUniqueWithoutVideoInput = {
    where: ContentReportWhereUniqueInput
    data: XOR<ContentReportUpdateWithoutVideoInput, ContentReportUncheckedUpdateWithoutVideoInput>
  }

  export type ContentReportUpdateManyWithWhereWithoutVideoInput = {
    where: ContentReportScalarWhereInput
    data: XOR<ContentReportUpdateManyMutationInput, ContentReportUncheckedUpdateManyWithoutVideoInput>
  }

  export type ExpressInterestUpsertWithWhereUniqueWithoutVideoInput = {
    where: ExpressInterestWhereUniqueInput
    update: XOR<ExpressInterestUpdateWithoutVideoInput, ExpressInterestUncheckedUpdateWithoutVideoInput>
    create: XOR<ExpressInterestCreateWithoutVideoInput, ExpressInterestUncheckedCreateWithoutVideoInput>
  }

  export type ExpressInterestUpdateWithWhereUniqueWithoutVideoInput = {
    where: ExpressInterestWhereUniqueInput
    data: XOR<ExpressInterestUpdateWithoutVideoInput, ExpressInterestUncheckedUpdateWithoutVideoInput>
  }

  export type ExpressInterestUpdateManyWithWhereWithoutVideoInput = {
    where: ExpressInterestScalarWhereInput
    data: XOR<ExpressInterestUpdateManyMutationInput, ExpressInterestUncheckedUpdateManyWithoutVideoInput>
  }

  export type VideoCreateWithoutTranscriptInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutTranscriptInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutTranscriptInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutTranscriptInput, VideoUncheckedCreateWithoutTranscriptInput>
  }

  export type VideoUpsertWithoutTranscriptInput = {
    update: XOR<VideoUpdateWithoutTranscriptInput, VideoUncheckedUpdateWithoutTranscriptInput>
    create: XOR<VideoCreateWithoutTranscriptInput, VideoUncheckedCreateWithoutTranscriptInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutTranscriptInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutTranscriptInput, VideoUncheckedUpdateWithoutTranscriptInput>
  }

  export type VideoUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type VideoCreateWithoutAnalyticsInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutAnalyticsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutAnalyticsInput, VideoUncheckedCreateWithoutAnalyticsInput>
  }

  export type VideoUpsertWithoutAnalyticsInput = {
    update: XOR<VideoUpdateWithoutAnalyticsInput, VideoUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<VideoCreateWithoutAnalyticsInput, VideoUncheckedCreateWithoutAnalyticsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutAnalyticsInput, VideoUncheckedUpdateWithoutAnalyticsInput>
  }

  export type VideoUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type VideoCreateWithoutViewsInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutViewsInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutViewsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutViewsInput, VideoUncheckedCreateWithoutViewsInput>
  }

  export type UserCreateWithoutVideoViewsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutVideoViewsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutVideoViewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideoViewsInput, UserUncheckedCreateWithoutVideoViewsInput>
  }

  export type VideoUpsertWithoutViewsInput = {
    update: XOR<VideoUpdateWithoutViewsInput, VideoUncheckedUpdateWithoutViewsInput>
    create: XOR<VideoCreateWithoutViewsInput, VideoUncheckedCreateWithoutViewsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutViewsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutViewsInput, VideoUncheckedUpdateWithoutViewsInput>
  }

  export type VideoUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserUpsertWithoutVideoViewsInput = {
    update: XOR<UserUpdateWithoutVideoViewsInput, UserUncheckedUpdateWithoutVideoViewsInput>
    create: XOR<UserCreateWithoutVideoViewsInput, UserUncheckedCreateWithoutVideoViewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVideoViewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVideoViewsInput, UserUncheckedUpdateWithoutVideoViewsInput>
  }

  export type UserUpdateWithoutVideoViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutVideoViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type VideoCreateWithoutLikesInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutLikesInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutLikesInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutLikesInput, VideoUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutLikesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutLikesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
  }

  export type VideoUpsertWithoutLikesInput = {
    update: XOR<VideoUpdateWithoutLikesInput, VideoUncheckedUpdateWithoutLikesInput>
    create: XOR<VideoCreateWithoutLikesInput, VideoUncheckedCreateWithoutLikesInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutLikesInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutLikesInput, VideoUncheckedUpdateWithoutLikesInput>
  }

  export type VideoUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserUpsertWithoutLikesInput = {
    update: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type VideoCreateWithoutCommentsInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutCommentsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    video: VideoCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    videoId: string
    userId: string
    content: string
    parentId?: string | null
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    content: string
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    video: VideoCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    videoId: string
    userId: string
    content: string
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type VideoUpsertWithoutCommentsInput = {
    update: XOR<VideoUpdateWithoutCommentsInput, VideoUncheckedUpdateWithoutCommentsInput>
    create: XOR<VideoCreateWithoutCommentsInput, VideoUncheckedCreateWithoutCommentsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutCommentsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutCommentsInput, VideoUncheckedUpdateWithoutCommentsInput>
  }

  export type VideoUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type VideoCreateWithoutSavesInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutSavesInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutSavesInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutSavesInput, VideoUncheckedCreateWithoutSavesInput>
  }

  export type UserCreateWithoutSavesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutSavesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutSavesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavesInput, UserUncheckedCreateWithoutSavesInput>
  }

  export type SaveListCreateWithoutSavesInput = {
    id?: string
    userId: string
    name: string
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type SaveListUncheckedCreateWithoutSavesInput = {
    id?: string
    userId: string
    name: string
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type SaveListCreateOrConnectWithoutSavesInput = {
    where: SaveListWhereUniqueInput
    create: XOR<SaveListCreateWithoutSavesInput, SaveListUncheckedCreateWithoutSavesInput>
  }

  export type VideoUpsertWithoutSavesInput = {
    update: XOR<VideoUpdateWithoutSavesInput, VideoUncheckedUpdateWithoutSavesInput>
    create: XOR<VideoCreateWithoutSavesInput, VideoUncheckedCreateWithoutSavesInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutSavesInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutSavesInput, VideoUncheckedUpdateWithoutSavesInput>
  }

  export type VideoUpdateWithoutSavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutSavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserUpsertWithoutSavesInput = {
    update: XOR<UserUpdateWithoutSavesInput, UserUncheckedUpdateWithoutSavesInput>
    create: XOR<UserCreateWithoutSavesInput, UserUncheckedCreateWithoutSavesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavesInput, UserUncheckedUpdateWithoutSavesInput>
  }

  export type UserUpdateWithoutSavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutSavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type SaveListUpsertWithoutSavesInput = {
    update: XOR<SaveListUpdateWithoutSavesInput, SaveListUncheckedUpdateWithoutSavesInput>
    create: XOR<SaveListCreateWithoutSavesInput, SaveListUncheckedCreateWithoutSavesInput>
    where?: SaveListWhereInput
  }

  export type SaveListUpdateToOneWithWhereWithoutSavesInput = {
    where?: SaveListWhereInput
    data: XOR<SaveListUpdateWithoutSavesInput, SaveListUncheckedUpdateWithoutSavesInput>
  }

  export type SaveListUpdateWithoutSavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveListUncheckedUpdateWithoutSavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveCreateWithoutListInput = {
    id?: string
    createdAt?: Date | string
    video: VideoCreateNestedOneWithoutSavesInput
    user: UserCreateNestedOneWithoutSavesInput
  }

  export type SaveUncheckedCreateWithoutListInput = {
    id?: string
    videoId: string
    userId: string
    createdAt?: Date | string
  }

  export type SaveCreateOrConnectWithoutListInput = {
    where: SaveWhereUniqueInput
    create: XOR<SaveCreateWithoutListInput, SaveUncheckedCreateWithoutListInput>
  }

  export type SaveCreateManyListInputEnvelope = {
    data: SaveCreateManyListInput | SaveCreateManyListInput[]
    skipDuplicates?: boolean
  }

  export type SaveUpsertWithWhereUniqueWithoutListInput = {
    where: SaveWhereUniqueInput
    update: XOR<SaveUpdateWithoutListInput, SaveUncheckedUpdateWithoutListInput>
    create: XOR<SaveCreateWithoutListInput, SaveUncheckedCreateWithoutListInput>
  }

  export type SaveUpdateWithWhereUniqueWithoutListInput = {
    where: SaveWhereUniqueInput
    data: XOR<SaveUpdateWithoutListInput, SaveUncheckedUpdateWithoutListInput>
  }

  export type SaveUpdateManyWithWhereWithoutListInput = {
    where: SaveScalarWhereInput
    data: XOR<SaveUpdateManyMutationInput, SaveUncheckedUpdateManyWithoutListInput>
  }

  export type VideoCreateWithoutSharesInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutSharesInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutSharesInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutSharesInput, VideoUncheckedCreateWithoutSharesInput>
  }

  export type UserCreateWithoutSharesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutSharesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutSharesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharesInput, UserUncheckedCreateWithoutSharesInput>
  }

  export type VideoUpsertWithoutSharesInput = {
    update: XOR<VideoUpdateWithoutSharesInput, VideoUncheckedUpdateWithoutSharesInput>
    create: XOR<VideoCreateWithoutSharesInput, VideoUncheckedCreateWithoutSharesInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutSharesInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutSharesInput, VideoUncheckedUpdateWithoutSharesInput>
  }

  export type VideoUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserUpsertWithoutSharesInput = {
    update: XOR<UserUpdateWithoutSharesInput, UserUncheckedUpdateWithoutSharesInput>
    create: XOR<UserCreateWithoutSharesInput, UserUncheckedCreateWithoutSharesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharesInput, UserUncheckedUpdateWithoutSharesInput>
  }

  export type UserUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutExpressedInterestsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutExpressedInterestsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutExpressedInterestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpressedInterestsInput, UserUncheckedCreateWithoutExpressedInterestsInput>
  }

  export type UserCreateWithoutReceivedInterestsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutReceivedInterestsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutReceivedInterestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedInterestsInput, UserUncheckedCreateWithoutReceivedInterestsInput>
  }

  export type VideoCreateWithoutExpressInterestsInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    reports?: ContentReportCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutExpressInterestsInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    reports?: ContentReportUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutExpressInterestsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutExpressInterestsInput, VideoUncheckedCreateWithoutExpressInterestsInput>
  }

  export type UserUpsertWithoutExpressedInterestsInput = {
    update: XOR<UserUpdateWithoutExpressedInterestsInput, UserUncheckedUpdateWithoutExpressedInterestsInput>
    create: XOR<UserCreateWithoutExpressedInterestsInput, UserUncheckedCreateWithoutExpressedInterestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpressedInterestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpressedInterestsInput, UserUncheckedUpdateWithoutExpressedInterestsInput>
  }

  export type UserUpdateWithoutExpressedInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutExpressedInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserUpsertWithoutReceivedInterestsInput = {
    update: XOR<UserUpdateWithoutReceivedInterestsInput, UserUncheckedUpdateWithoutReceivedInterestsInput>
    create: XOR<UserCreateWithoutReceivedInterestsInput, UserUncheckedCreateWithoutReceivedInterestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedInterestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedInterestsInput, UserUncheckedUpdateWithoutReceivedInterestsInput>
  }

  export type UserUpdateWithoutReceivedInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type VideoUpsertWithoutExpressInterestsInput = {
    update: XOR<VideoUpdateWithoutExpressInterestsInput, VideoUncheckedUpdateWithoutExpressInterestsInput>
    create: XOR<VideoCreateWithoutExpressInterestsInput, VideoUncheckedCreateWithoutExpressInterestsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutExpressInterestsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutExpressInterestsInput, VideoUncheckedUpdateWithoutExpressInterestsInput>
  }

  export type VideoUpdateWithoutExpressInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutExpressInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserCreateWithoutProfileRevealsAsInvestorInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutProfileRevealsAsInvestorInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutProfileRevealsAsInvestorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileRevealsAsInvestorInput, UserUncheckedCreateWithoutProfileRevealsAsInvestorInput>
  }

  export type UserCreateWithoutProfileRevealsAsFounderInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutProfileRevealsAsFounderInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutProfileRevealsAsFounderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileRevealsAsFounderInput, UserUncheckedCreateWithoutProfileRevealsAsFounderInput>
  }

  export type UserUpsertWithoutProfileRevealsAsInvestorInput = {
    update: XOR<UserUpdateWithoutProfileRevealsAsInvestorInput, UserUncheckedUpdateWithoutProfileRevealsAsInvestorInput>
    create: XOR<UserCreateWithoutProfileRevealsAsInvestorInput, UserUncheckedCreateWithoutProfileRevealsAsInvestorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileRevealsAsInvestorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileRevealsAsInvestorInput, UserUncheckedUpdateWithoutProfileRevealsAsInvestorInput>
  }

  export type UserUpdateWithoutProfileRevealsAsInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileRevealsAsInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserUpsertWithoutProfileRevealsAsFounderInput = {
    update: XOR<UserUpdateWithoutProfileRevealsAsFounderInput, UserUncheckedUpdateWithoutProfileRevealsAsFounderInput>
    create: XOR<UserCreateWithoutProfileRevealsAsFounderInput, UserUncheckedCreateWithoutProfileRevealsAsFounderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileRevealsAsFounderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileRevealsAsFounderInput, UserUncheckedUpdateWithoutProfileRevealsAsFounderInput>
  }

  export type UserUpdateWithoutProfileRevealsAsFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileRevealsAsFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutConversations1Input = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutConversations1Input = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutConversations1Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversations1Input, UserUncheckedCreateWithoutConversations1Input>
  }

  export type UserCreateWithoutConversations2Input = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutConversations2Input = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutConversations2Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversations2Input, UserUncheckedCreateWithoutConversations2Input>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content: string
    type?: string
    attachmentUrl?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content: string
    type?: string
    attachmentUrl?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConversations1Input = {
    update: XOR<UserUpdateWithoutConversations1Input, UserUncheckedUpdateWithoutConversations1Input>
    create: XOR<UserCreateWithoutConversations1Input, UserUncheckedCreateWithoutConversations1Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversations1Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversations1Input, UserUncheckedUpdateWithoutConversations1Input>
  }

  export type UserUpdateWithoutConversations1Input = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutConversations1Input = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserUpsertWithoutConversations2Input = {
    update: XOR<UserUpdateWithoutConversations2Input, UserUncheckedUpdateWithoutConversations2Input>
    create: XOR<UserCreateWithoutConversations2Input, UserUncheckedCreateWithoutConversations2Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversations2Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversations2Input, UserUncheckedUpdateWithoutConversations2Input>
  }

  export type UserUpdateWithoutConversations2Input = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutConversations2Input = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant1: UserCreateNestedOneWithoutConversations1Input
    participant2: UserCreateNestedOneWithoutConversations2Input
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    participant1Id: string
    participant2Id: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant1?: UserUpdateOneRequiredWithoutConversations1NestedInput
    participant2?: UserUpdateOneRequiredWithoutConversations2NestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    participant1Id?: StringFieldUpdateOperationsInput | string
    participant2Id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
  }

  export type UserUpsertWithoutMessagesSentInput = {
    update: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutContentReportsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutContentReportsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutContentReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContentReportsInput, UserUncheckedCreateWithoutContentReportsInput>
  }

  export type VideoCreateWithoutReportsInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVideosInput
    transcript?: VideoTranscriptCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsCreateNestedOneWithoutVideoInput
    comments?: CommentCreateNestedManyWithoutVideoInput
    likes?: LikeCreateNestedManyWithoutVideoInput
    saves?: SaveCreateNestedManyWithoutVideoInput
    shares?: ShareCreateNestedManyWithoutVideoInput
    views?: VideoViewCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutReportsInput = {
    id?: string
    userId: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transcript?: VideoTranscriptUncheckedCreateNestedOneWithoutVideoInput
    analytics?: VideoAnalyticsUncheckedCreateNestedOneWithoutVideoInput
    comments?: CommentUncheckedCreateNestedManyWithoutVideoInput
    likes?: LikeUncheckedCreateNestedManyWithoutVideoInput
    saves?: SaveUncheckedCreateNestedManyWithoutVideoInput
    shares?: ShareUncheckedCreateNestedManyWithoutVideoInput
    views?: VideoViewUncheckedCreateNestedManyWithoutVideoInput
    expressInterests?: ExpressInterestUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutReportsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutReportsInput, VideoUncheckedCreateWithoutReportsInput>
  }

  export type UserUpsertWithoutContentReportsInput = {
    update: XOR<UserUpdateWithoutContentReportsInput, UserUncheckedUpdateWithoutContentReportsInput>
    create: XOR<UserCreateWithoutContentReportsInput, UserUncheckedCreateWithoutContentReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContentReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContentReportsInput, UserUncheckedUpdateWithoutContentReportsInput>
  }

  export type UserUpdateWithoutContentReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutContentReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type VideoUpsertWithoutReportsInput = {
    update: XOR<VideoUpdateWithoutReportsInput, VideoUncheckedUpdateWithoutReportsInput>
    create: XOR<VideoCreateWithoutReportsInput, VideoUncheckedCreateWithoutReportsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutReportsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutReportsInput, VideoUncheckedUpdateWithoutReportsInput>
  }

  export type VideoUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVideosNestedInput
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserCreateWithoutModerationActionsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutModerationActionsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutModerationActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModerationActionsInput, UserUncheckedCreateWithoutModerationActionsInput>
  }

  export type UserUpsertWithoutModerationActionsInput = {
    update: XOR<UserUpdateWithoutModerationActionsInput, UserUncheckedUpdateWithoutModerationActionsInput>
    create: XOR<UserCreateWithoutModerationActionsInput, UserUncheckedCreateWithoutModerationActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModerationActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModerationActionsInput, UserUncheckedUpdateWithoutModerationActionsInput>
  }

  export type UserUpdateWithoutModerationActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutModerationActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutNotificationPrefsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutNotificationPrefsInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutNotificationPrefsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
  }

  export type UserUpsertWithoutNotificationPrefsInput = {
    update: XOR<UserUpdateWithoutNotificationPrefsInput, UserUncheckedUpdateWithoutNotificationPrefsInput>
    create: XOR<UserCreateWithoutNotificationPrefsInput, UserUncheckedCreateWithoutNotificationPrefsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPrefsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPrefsInput, UserUncheckedUpdateWithoutNotificationPrefsInput>
  }

  export type UserUpdateWithoutNotificationPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutFeedPreferencesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutFeedPreferencesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutFeedPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedPreferencesInput, UserUncheckedCreateWithoutFeedPreferencesInput>
  }

  export type UserUpsertWithoutFeedPreferencesInput = {
    update: XOR<UserUpdateWithoutFeedPreferencesInput, UserUncheckedUpdateWithoutFeedPreferencesInput>
    create: XOR<UserCreateWithoutFeedPreferencesInput, UserUncheckedCreateWithoutFeedPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedPreferencesInput, UserUncheckedUpdateWithoutFeedPreferencesInput>
  }

  export type UserUpdateWithoutFeedPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutSearchHistoryInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutSearchHistoryInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutSearchHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
  }

  export type UserUpsertWithoutSearchHistoryInput = {
    update: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
    create: XOR<UserCreateWithoutSearchHistoryInput, UserUncheckedCreateWithoutSearchHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearchHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearchHistoryInput, UserUncheckedUpdateWithoutSearchHistoryInput>
  }

  export type UserUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutSearchHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutOnboardingProgressInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    accountTypeChanges?: AccountTypeChangeCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutOnboardingProgressInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    accountTypeChanges?: AccountTypeChangeUncheckedCreateNestedManyWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutOnboardingProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
  }

  export type UserUpsertWithoutOnboardingProgressInput = {
    update: XOR<UserUpdateWithoutOnboardingProgressInput, UserUncheckedUpdateWithoutOnboardingProgressInput>
    create: XOR<UserCreateWithoutOnboardingProgressInput, UserUncheckedCreateWithoutOnboardingProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOnboardingProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOnboardingProgressInput, UserUncheckedUpdateWithoutOnboardingProgressInput>
  }

  export type UserUpdateWithoutOnboardingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutOnboardingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    accountTypeChanges?: AccountTypeChangeUncheckedUpdateManyWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type UserCreateWithoutAccountTypeChangesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationCreateNestedOneWithoutUserInput
    videos?: VideoCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    saves?: SaveCreateNestedManyWithoutUserInput
    shares?: ShareCreateNestedManyWithoutUserInput
    videoViews?: VideoViewCreateNestedManyWithoutViewerInput
    following?: FollowCreateNestedManyWithoutFollowerInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    conversations1?: ConversationCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealCreateNestedManyWithoutFounderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    contentReports?: ContentReportCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressCreateNestedOneWithoutUserInput
    messagesSent?: MessageLimitCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceCreateNestedOneWithoutUserInput
    blockedUsers?: BlockCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
  }

  export type UserUncheckedCreateWithoutAccountTypeChangesInput = {
    id?: string
    email: string
    passwordHash: string
    accountType?: $Enums.AccountType
    isVerified?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resetPasswordToken?: string | null
    resetPasswordExpires?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    founderProfile?: FounderProfileUncheckedCreateNestedOneWithoutUserInput
    investorProfile?: InvestorProfileUncheckedCreateNestedOneWithoutUserInput
    builderProfile?: BuilderProfileUncheckedCreateNestedOneWithoutUserInput
    investorVerification?: InvestorVerificationUncheckedCreateNestedOneWithoutUserInput
    videos?: VideoUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    saves?: SaveUncheckedCreateNestedManyWithoutUserInput
    shares?: ShareUncheckedCreateNestedManyWithoutUserInput
    videoViews?: VideoViewUncheckedCreateNestedManyWithoutViewerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversations1?: ConversationUncheckedCreateNestedManyWithoutParticipant1Input
    conversations2?: ConversationUncheckedCreateNestedManyWithoutParticipant2Input
    expressedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutInvestorInput
    receivedInterests?: ExpressInterestUncheckedCreateNestedManyWithoutFounderInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedCreateNestedManyWithoutInvestorInput
    profileRevealsAsFounder?: ProfileRevealUncheckedCreateNestedManyWithoutFounderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notificationPrefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    contentReports?: ContentReportUncheckedCreateNestedManyWithoutReporterInput
    moderationActions?: ModerationActionRecordUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    searchHistory?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
    onboardingProgress?: OnboardingProgressUncheckedCreateNestedOneWithoutUserInput
    messagesSent?: MessageLimitUncheckedCreateNestedManyWithoutUserInput
    feedPreferences?: FeedPreferenceUncheckedCreateNestedOneWithoutUserInput
    blockedUsers?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
  }

  export type UserCreateOrConnectWithoutAccountTypeChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountTypeChangesInput, UserUncheckedCreateWithoutAccountTypeChangesInput>
  }

  export type UserUpsertWithoutAccountTypeChangesInput = {
    update: XOR<UserUpdateWithoutAccountTypeChangesInput, UserUncheckedUpdateWithoutAccountTypeChangesInput>
    create: XOR<UserCreateWithoutAccountTypeChangesInput, UserUncheckedCreateWithoutAccountTypeChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountTypeChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountTypeChangesInput, UserUncheckedUpdateWithoutAccountTypeChangesInput>
  }

  export type UserUpdateWithoutAccountTypeChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUpdateOneWithoutUserNestedInput
    videos?: VideoUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    saves?: SaveUpdateManyWithoutUserNestedInput
    shares?: ShareUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUpdateManyWithoutViewerNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUpdateOneWithoutUserNestedInput
    messagesSent?: MessageLimitUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountTypeChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    founderProfile?: FounderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorProfile?: InvestorProfileUncheckedUpdateOneWithoutUserNestedInput
    builderProfile?: BuilderProfileUncheckedUpdateOneWithoutUserNestedInput
    investorVerification?: InvestorVerificationUncheckedUpdateOneWithoutUserNestedInput
    videos?: VideoUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    saves?: SaveUncheckedUpdateManyWithoutUserNestedInput
    shares?: ShareUncheckedUpdateManyWithoutUserNestedInput
    videoViews?: VideoViewUncheckedUpdateManyWithoutViewerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversations1?: ConversationUncheckedUpdateManyWithoutParticipant1NestedInput
    conversations2?: ConversationUncheckedUpdateManyWithoutParticipant2NestedInput
    expressedInterests?: ExpressInterestUncheckedUpdateManyWithoutInvestorNestedInput
    receivedInterests?: ExpressInterestUncheckedUpdateManyWithoutFounderNestedInput
    profileRevealsAsInvestor?: ProfileRevealUncheckedUpdateManyWithoutInvestorNestedInput
    profileRevealsAsFounder?: ProfileRevealUncheckedUpdateManyWithoutFounderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notificationPrefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    contentReports?: ContentReportUncheckedUpdateManyWithoutReporterNestedInput
    moderationActions?: ModerationActionRecordUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    searchHistory?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
    onboardingProgress?: OnboardingProgressUncheckedUpdateOneWithoutUserNestedInput
    messagesSent?: MessageLimitUncheckedUpdateManyWithoutUserNestedInput
    feedPreferences?: FeedPreferenceUncheckedUpdateOneWithoutUserNestedInput
    blockedUsers?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
  }

  export type VideoCreateManyUserInput = {
    id?: string
    videoUrl: string
    thumbnailUrl?: string | null
    type: $Enums.VideoType
    visibility?: $Enums.VideoVisibility
    isPinned?: boolean
    caption?: string | null
    duration: number
    tags?: VideoCreatetagsInput | string[]
    qualityScore?: number | null
    viewCount?: number
    likeCount?: number
    commentCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    videoId: string
    content: string
    parentId?: string | null
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyUserInput = {
    id?: string
    videoId: string
    createdAt?: Date | string
  }

  export type SaveCreateManyUserInput = {
    id?: string
    videoId: string
    listId?: string | null
    createdAt?: Date | string
  }

  export type ShareCreateManyUserInput = {
    id?: string
    videoId: string
    platform: string
    createdAt?: Date | string
  }

  export type VideoViewCreateManyViewerInput = {
    id?: string
    videoId: string
    watchTime?: number
    completed?: boolean
    replays?: number
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    content: string
    type?: string
    attachmentUrl?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ConversationCreateManyParticipant1Input = {
    id?: string
    participant2Id: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyParticipant2Input = {
    id?: string
    participant1Id: string
    status?: $Enums.ConversationStatus
    isRevealed?: boolean
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpressInterestCreateManyInvestorInput = {
    id?: string
    founderId: string
    videoId: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpressInterestCreateManyFounderInput = {
    id?: string
    investorId: string
    videoId: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileRevealCreateManyInvestorInput = {
    id?: string
    founderId: string
    revealedAt?: Date | string
  }

  export type ProfileRevealCreateManyFounderInput = {
    id?: string
    investorId: string
    revealedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    priority?: $Enums.NotificationPriority
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationPreferenceCreateManyUserInput = {
    id?: string
    type: string
    pushEnabled?: boolean
    emailEnabled?: boolean
  }

  export type ContentReportCreateManyReporterInput = {
    id?: string
    videoId: string
    category: $Enums.ReportCategory
    details?: string | null
    status?: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModerationActionRecordCreateManyUserInput = {
    id?: string
    action: $Enums.ModerationAction
    reason: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    device?: string | null
    ip?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SearchHistoryCreateManyUserInput = {
    id?: string
    query: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AccountTypeChangeCreateManyUserInput = {
    id?: string
    fromType: $Enums.AccountType
    toType: $Enums.AccountType
    changedAt?: Date | string
  }

  export type MessageLimitCreateManyUserInput = {
    id?: string
    period: string
    count?: number
    resetsAt: Date | string
    createdAt?: Date | string
  }

  export type BlockCreateManyBlockerInput = {
    id?: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockCreateManyBlockedInput = {
    id?: string
    blockerId: string
    createdAt?: Date | string
  }

  export type VideoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUpdateOneWithoutVideoNestedInput
    comments?: CommentUpdateManyWithoutVideoNestedInput
    likes?: LikeUpdateManyWithoutVideoNestedInput
    saves?: SaveUpdateManyWithoutVideoNestedInput
    shares?: ShareUpdateManyWithoutVideoNestedInput
    views?: VideoViewUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transcript?: VideoTranscriptUncheckedUpdateOneWithoutVideoNestedInput
    analytics?: VideoAnalyticsUncheckedUpdateOneWithoutVideoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutVideoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutVideoNestedInput
    saves?: SaveUncheckedUpdateManyWithoutVideoNestedInput
    shares?: ShareUncheckedUpdateManyWithoutVideoNestedInput
    views?: VideoViewUncheckedUpdateManyWithoutVideoNestedInput
    reports?: ContentReportUncheckedUpdateManyWithoutVideoNestedInput
    expressInterests?: ExpressInterestUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType
    visibility?: EnumVideoVisibilityFieldUpdateOperationsInput | $Enums.VideoVisibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    tags?: VideoUpdatetagsInput | string[]
    qualityScore?: NullableIntFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutSavesNestedInput
    list?: SaveListUpdateOneWithoutSavesNestedInput
  }

  export type SaveUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutSharesNestedInput
  }

  export type ShareUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoViewUpdateWithoutViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutViewsNestedInput
  }

  export type VideoViewUncheckedUpdateWithoutViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoViewUncheckedUpdateManyWithoutViewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutParticipant1Input = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant2?: UserUpdateOneRequiredWithoutConversations2NestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipant1Input = {
    id?: StringFieldUpdateOperationsInput | string
    participant2Id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutParticipant1Input = {
    id?: StringFieldUpdateOperationsInput | string
    participant2Id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutParticipant2Input = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant1?: UserUpdateOneRequiredWithoutConversations1NestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipant2Input = {
    id?: StringFieldUpdateOperationsInput | string
    participant1Id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutParticipant2Input = {
    id?: StringFieldUpdateOperationsInput | string
    participant1Id?: StringFieldUpdateOperationsInput | string
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    isRevealed?: BoolFieldUpdateOperationsInput | boolean
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpressInterestUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutReceivedInterestsNestedInput
    video?: VideoUpdateOneRequiredWithoutExpressInterestsNestedInput
  }

  export type ExpressInterestUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpressInterestUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpressInterestUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: UserUpdateOneRequiredWithoutExpressedInterestsNestedInput
    video?: VideoUpdateOneRequiredWithoutExpressInterestsNestedInput
  }

  export type ExpressInterestUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpressInterestUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileRevealUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutProfileRevealsAsFounderNestedInput
  }

  export type ProfileRevealUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileRevealUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileRevealUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: UserUpdateOneRequiredWithoutProfileRevealsAsInvestorNestedInput
  }

  export type ProfileRevealUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileRevealUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    revealedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContentReportUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ContentReportUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReportUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationActionRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationActionRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModerationActionRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumModerationActionFieldUpdateOperationsInput | $Enums.ModerationAction
    reason?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountTypeChangeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    toType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountTypeChangeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    toType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountTypeChangeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    toType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLimitUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLimitUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLimitUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocked?: UserUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpdateWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: UserUpdateOneRequiredWithoutBlockedUsersNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialLinkCreateManyProfileInput = {
    id?: string
    platform: string
    url: string
  }

  export type SocialLinkUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PortfolioCreateManyInvestorProfileInput = {
    id?: string
    companyName: string
    companyUrl?: string | null
    investmentYear?: number | null
  }

  export type PortfolioUpdateWithoutInvestorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    investmentYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PortfolioUncheckedUpdateWithoutInvestorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    investmentYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PortfolioUncheckedUpdateManyWithoutInvestorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    investmentYear?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentCreateManyVideoInput = {
    id?: string
    userId: string
    content: string
    parentId?: string | null
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyVideoInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type SaveCreateManyVideoInput = {
    id?: string
    userId: string
    listId?: string | null
    createdAt?: Date | string
  }

  export type ShareCreateManyVideoInput = {
    id?: string
    userId: string
    platform: string
    createdAt?: Date | string
  }

  export type VideoViewCreateManyVideoInput = {
    id?: string
    viewerId: string
    watchTime?: number
    completed?: boolean
    replays?: number
    createdAt?: Date | string
  }

  export type ContentReportCreateManyVideoInput = {
    id?: string
    reporterId: string
    category: $Enums.ReportCategory
    details?: string | null
    status?: string
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ExpressInterestCreateManyVideoInput = {
    id?: string
    investorId: string
    founderId: string
    status?: string
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavesNestedInput
    list?: SaveListUpdateOneWithoutSavesNestedInput
  }

  export type SaveUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    listId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharesNestedInput
  }

  export type ShareUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoViewUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewer?: UserUpdateOneRequiredWithoutVideoViewsNestedInput
  }

  export type VideoViewUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewerId?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoViewUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewerId?: StringFieldUpdateOperationsInput | string
    watchTime?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    replays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReportUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutContentReportsNestedInput
  }

  export type ContentReportUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentReportUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    category?: EnumReportCategoryFieldUpdateOperationsInput | $Enums.ReportCategory
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpressInterestUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: UserUpdateOneRequiredWithoutExpressedInterestsNestedInput
    founder?: UserUpdateOneRequiredWithoutReceivedInterestsNestedInput
  }

  export type ExpressInterestUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpressInterestUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    founderId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    videoId: string
    userId: string
    content: string
    isHidden?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveCreateManyListInput = {
    id?: string
    videoId: string
    userId: string
    createdAt?: Date | string
  }

  export type SaveUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoUpdateOneRequiredWithoutSavesNestedInput
    user?: UserUpdateOneRequiredWithoutSavesNestedInput
  }

  export type SaveUncheckedUpdateWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaveUncheckedUpdateManyWithoutListInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    content: string
    type?: string
    attachmentUrl?: string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProfileCountOutputTypeDefaultArgs instead
     */
    export type UserProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestorProfileCountOutputTypeDefaultArgs instead
     */
    export type InvestorProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestorProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoCountOutputTypeDefaultArgs instead
     */
    export type VideoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaveListCountOutputTypeDefaultArgs instead
     */
    export type SaveListCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaveListCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockDefaultArgs instead
     */
    export type BlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProfileDefaultArgs instead
     */
    export type UserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SocialLinkDefaultArgs instead
     */
    export type SocialLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SocialLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FounderProfileDefaultArgs instead
     */
    export type FounderProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FounderProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FundraisingDetailsDefaultArgs instead
     */
    export type FundraisingDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FundraisingDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestorProfileDefaultArgs instead
     */
    export type InvestorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestorProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortfolioDefaultArgs instead
     */
    export type PortfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortfolioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuilderProfileDefaultArgs instead
     */
    export type BuilderProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuilderProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvestorVerificationDefaultArgs instead
     */
    export type InvestorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvestorVerificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoDefaultArgs instead
     */
    export type VideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoTranscriptDefaultArgs instead
     */
    export type VideoTranscriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoTranscriptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoAnalyticsDefaultArgs instead
     */
    export type VideoAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoViewDefaultArgs instead
     */
    export type VideoViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoViewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LikeDefaultArgs instead
     */
    export type LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaveDefaultArgs instead
     */
    export type SaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaveListDefaultArgs instead
     */
    export type SaveListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaveListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShareDefaultArgs instead
     */
    export type ShareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FollowDefaultArgs instead
     */
    export type FollowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FollowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpressInterestDefaultArgs instead
     */
    export type ExpressInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpressInterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileRevealDefaultArgs instead
     */
    export type ProfileRevealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileRevealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageLimitDefaultArgs instead
     */
    export type MessageLimitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageLimitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentReportDefaultArgs instead
     */
    export type ContentReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentFlagDefaultArgs instead
     */
    export type ContentFlagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentFlagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModerationActionRecordDefaultArgs instead
     */
    export type ModerationActionRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModerationActionRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeaturedContentDefaultArgs instead
     */
    export type FeaturedContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeaturedContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationPreferenceDefaultArgs instead
     */
    export type NotificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedPreferenceDefaultArgs instead
     */
    export type FeedPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SearchHistoryDefaultArgs instead
     */
    export type SearchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SearchHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OnboardingProgressDefaultArgs instead
     */
    export type OnboardingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OnboardingProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountTypeChangeDefaultArgs instead
     */
    export type AccountTypeChangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountTypeChangeDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}